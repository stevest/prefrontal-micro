//Kiki initial experiment
// 30 March 2006 
//use corrected diameters for basal dendrites


//BACK_GROUND = 0 // set to 1 when using background synapses
synch = 0        // synapses are stimulated randomly (NOT synchronously), set to 1 for synchronous stimulation

load_proc("nrnmainmenu")
load_template("ExperimentControl")         // load needed templates
load_template("EPSPTuning")
load_template("RangeRef")
cvode_active(0)

objref econ                               // initialize template parameters
show_errs=1
debug_lev=1
econ=new ExperimentControl(show_errs,debug_lev)
econ.self_define(econ)
econ.morphology_dir = "../../morphology/pfc"                // set location for morphology files
econ.add_lib_dir("Terrence","../../lib")                    // set location for library files
econ.generic_dir    = "../../experiment"                   // set location for cell-setup file
econ.data_dir       = "data"                               // set directory to store data

actual_resolution=75                                        // maximum nseg number 
desired_resolution=1

//Load morphology files

econ.xopen_geometry_dependent("ratpfc22")     //C3_5, regular spiking   

printf ("morphology file opened")

//econ.xopen_geometry_dependent("cell-analysis")         // load user-defined semantics on morphology 
//cell_analysis(econ) 
//print "cell-anaylysis"

econ.xopen_generic("cell-setup")                       // load cell-setup to
printf("Opened. Setting up cell\n")                   // specify all mechanisms,
maximum_segment_length=actual_resolution              // membrane properties etc	 
cell_setup(econ)


//correct diameters at basal dendrites
forsec basal {
	diam = diam *1
	}


//Set duration of the run and dt
econ.defvar("Simulation Control", "tstop", "2000", "Defines when the simulation stops.") 
econ.defvar("Simulation Control", "dt", "0.1", "Timestep")econ.defvar("Simulation Control", "steps_per_ms", "10", "How many points are plotted per ms")
setdt()

/* 
// --------------------------------------------------------------------------------------------
//Current clamp for correcting membrane potential when needed under blockade conditions

access soma
objref ic
ic = new IClamp(0.5)
ic.del = 300
ic.dur = tstop-ic.del
ic.amp = 0.025

access apical_dendrite[71]
objref ic2
ic2 = new IClamp(0.5)
ic2.del = 300
ic2.dur = tstop-ic.del
ic2.amp = 0.035
//-------------------------------------------------------------------------------------------------
*/



//Noise procedure

//INSERT MOD FILE FOR SINE WAVE
/*

objref sinw, w, ramp

forsec soma_list {
w = new Random()
w.poisson(0.1)

sinw  =  new SinClamp(0.5)
sinw.del=0
sinw.dur=tstop
sinw.freq = 100
w.play(&sinw.pkamp)
}
*/


// Open library functions that will be needed
econ.xopen_library("Terrence","choose-secs")    // used to randomly select sections from a list
econ.xopen_library("Terrence","basic-graphics") // used to plot graphics 
//econ.xopen_library("Terrence","spikecount")     // used to count spikes
econ.xopen_library("Terrence","salloc")         // used to allocate synapses on sections

load_template("SynapseBand")                    // template for making bands of synapses

print "library_functions_loaded" 
//----------------------------------------------------------------------------------------------------
//set number of branches and number of synapses to be put on
//-----------------------------------------------------------
init_cluster_number = 10 //10 //10   //number of branches to place synapses on 
init_cluster_size =20 //50 //10  //50  //3    //3  //synapses in each branch for basal
basal_synapses= init_cluster_number * init_cluster_size
all_synapses = init_cluster_number * init_cluster_size
trunk_cluster_number = 50
trunk_cluster_size = 1
trunk_synapses = trunk_cluster_number*trunk_cluster_size
//for ratpfc22, ratio2=18, ratio1=10, 23 for 2.5,27 for 3 
ratio = 3

inh_cluster_number=1
inh_cluster_size=3  //3
inh_synapses=inh_cluster_number*inh_cluster_size

max_synapses=1000
//--------------------------------------------------------------- 

//Define all objects used in the procedures
//------------------------------------------

objref cluster_list, trunk_list, AS_list, splot, rpid, band1,band2, band3, band4, ns1[trunk_synapses], nc1[trunk_synapses], ns2[all_synapses], nc2[trunk_synapses], ampat[trunk_synapses], nmdat[trunk_synapses], nc3[basal_synapses], ampab[basal_synapses], nmdab[basal_synapses], nc4[basal_synapses], ns4[inh_synapses], nc6[inh_synapses], nc7[inh_synapses], gabaan[inh_synapses], gababn[inh_synapses]
objref stepp
objref vf
strdef tmpstr

//set values for different variables
//-----------------------------------
delstima=5
delstimb =1500  //50
delstims= 5  // 300
delsecond = 1000
delstim_inh=2000

//============================================================================================
// procedure to place ampa, nmda on basal dendrites
proc synapse_location_basal() {local b, b1, l, cluster_number, cluster_size, delstim1, total_synapses
	


	cluster_number = $2			//number of branches
	cluster_size = $3			//number of synapses per branch
	delstim1 = $4
	l = $5
	total_synapses = $6

	//Randomly pick different branches to put synapses on it

	cluster_list = new SectionList()
	
	for b = 0, cluster_number-1 {
		$o1.pick_and_remove()	//select the branch
		print "pick and remove"
		cluster_list.append()
		//cluster_list.printnames()
		}
	

	//Distribute the synapses uniformly

	
	forsec cluster_list {

		nseg = cluster_size
 	
		
		for b1 = 1, cluster_size {

		//posn1 = 0.5
		posn1 = (2*b1-1)/(2 * cluster_size)
	
		//5/2/08 validation based on Schiller paper, nat neuro 2007, 0.12mV at the soma
		//ampaweight = 0.0003       //5 for apical
		ampaweight = 0.00015  //*18        //for ratpfc22, multiply for apical


 	  	nmdaweight = ampaweight*ratio
		
		ampab[l] = new GLU(posn1) 
		nmdab[l] = new NMDA(posn1)
	
		ns2[l] = new NetStimm(0.5)
		ns2[l].start = 0
		ns2[l].number =1  //10  	//number of APs
		ns2[l].interval =20      //interval in ms between AP
		ns2[l].noise=0   //0.05
		
			
	
		nc3[l] = new NetCon(ns2[l], ampab[l])
		nc3[l].delay = delstimb    //ms
		nc3[l].weight = ampaweight
			
		nc4[l] = new NetCon(ns2[l], nmdab[l])
		nc4[l].delay = delstimb  
		nc4[l].weight = nmdaweight   //*0.1
	
		splot.point_mark(ampab[l],COLOR+1)
	
		l=l+1
	
	}
}
	
}


//=====================================================================
//Pharmacological procedures
//values and sadp
//1==> 5mV
//0.95==> 2mV
//0.97==>3mV



gcanvalue=1.045*0
//procedure for induction of sadp
//In cell-setup, gip3 = 0.0001, gCAN=0.0001
proc sadp() {
forsec apical {
for(x) {
	fi2=gcanvalue	//factor for ican
	if(ismembrane("ican"))  for(x) { gbar_ican(x)= gbar_ican(x)*fi2 } 
	}}}

proc sadpsoma() {
forsec somatic {
for(x) {
	fi1=0     //factor for ip3
	fi2=gcanvalue   	//factor for ican
	if(ismembrane("ip3")) for(x) { gcabar_ip3(x)= gcabar_ip3(x)*fi1 }
	if(ismembrane("ican"))  for(x) { gbar_ican(x)= gbar_ican(x)*fi2 } 
	}}}

proc sadpbasal() {
forsec basal {
for(x) {
	fb=gcanvalue
	if(ismembrane("ican")) for(x) {gbar_ican(x)=gbar_ican(x)*fb}
	}}}


//---------------------------------------------------------------------------

//TTX
proc ttx() {
ft=0
forall {
	for(x) {
      	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*ft }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*ft }	
	}}}
//-------------------------------------

//--------------------------------------------------------------------------------
proc Kblock(){
forall{
for(x){
	fk=0
	if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	//if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }} 
	//if(ismembrane("mykca")) { for(x) {  gk_mykca(x)= gk_mykca(x)*fk }} 
	}}}


proc d1() {
f = 0
forall if(ismembrane("calc")) { for(x) {  pcabar_calc(x)= pcabar_calc(x)*f }}
forall if(ismembrane("cal")) { for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*f }}
forall if(ismembrane("can")) { for(x) {  gcalbar_can(x)= gcalbar_can(x)*f }}
forall if(ismembrane("car")) { for(x) {  gcabar_car(x)= gcabar_car(x)*f }}
forall if(ismembrane("cat")) { for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*f }}
}

proc hblock() {
forall {
for(x) {if(ismembrane("h")) { for(x) {  gbar_h(x)= gbar_h(x)*0.9 }}}}}

//Current clamp for correcting membrane potential when needed under blockade conditions
objref ic
proc current_correct() {
access soma
//objref ic
ic = new IClamp(0.5)
ic.del = 0
ic.dur = tstop
ic.amp = 0.05
}

//--------------------------------------------------------------------------------



//-----------------------Vclamp
objref vc, vsoma

proc vclamp() {
//access soma[0]
//vclamp at soma to study currents
forsec somatic {
for(x){
vc = new VClamp(0.5)
vc.dur[0]=tstop
vc.amp[0]=60	//soma.v(0.5)


//vsoma = new Vector()
//vsoma.record(&soma[0].v(0.5))
//vsoma.play(&vc.amp[0], 0.1)
}}
}


//Call pharamacological procedures
sadp()
sadpsoma()
sadpbasal()
Kblock()
//d1()
ttx()
vclamp()
//hblock()
//current_correct()
//----------------------------------------------------------------------------------------------------

//Graphics in the experiments

econ.xopen_library("Terrence","basic-graphics")   // open library file for graphics
addgraph("soma[0].v(0.5)",-70,-50)	//soma
// for ratpfc22
/*addgraph_2("dend[0].v(0.5)",0,tstop,-75,60) //basal 17um
addgraph_2("dend[2].v(0.5)",0,tstop,-75,60) //basal 48um
addgraph_2("dend[4].v(0.5)",0,tstop,-75,60) //basal 55um
addgraph_2("dend[9].v(0.5)",0,tstop,-75,60) //basal 92um
addgraph_2("dend[9].v(0.833333)",0,tstop,-75,60) //basal 145um
addgraph_2("dend[16].v(0.25)",0,tstop,-75,60) //basal 62um
addgraph_2("dend[16].v(0.75)",0,tstop,-75,60) //basal 123um
*/

//for C3_4
//basal dendrites
//addgraph_2("dend[0].v(0.5)",0,tstop,-75,60) //basal 14um
//addgraph_2("dend[1].v(0.5)",0,tstop,-75,60) //basal 34um
addgraph_2("dend[2].v(0.5)",0,tstop,-75,60) //basal 47um
//addgraph_2("dend[4].v(0.5)",0,tstop,-75,60) //basal 55um
//addgraph_2("dend[3].v(0.5)",0,tstop,-75,60) //basal 78um
addgraph_2("dend[7].v(0.5)",0,tstop,-75,60) //basal 114um
//addgraph_2("dend[8].v(0.5)",0,tstop,-75,60) //basal 130um
//addgraph_2("dend[8].v(1)",0,tstop,-75,60) //basal 151um
//addgraph_2("dend[20].v(0.5)",0,tstop,-75,60) //basal 154um



//addgraph("soma[0].in_ican(0.5)",-1,1)	//soma

//Define objects for recording
objref vsoma, ip3rec, icanrec, cairec,vtrunk100, vtrunk200, vtrunk300, vtrunk400, vtrunk500, vtrunk600
objref vb7, vb2, vb1089, vb840, vb827
objref vb906cairec, vb884cairec, vb1032cairec, vb1089cairec, vb840cairec
objref	vb961, vb990
objref inarec

//define objects for files
strdef temp
objref somaref, cairef, icanref, ip3ref,t100ref, t200ref, t300ref, t400ref, t500ref, t600ref
objref vb7ref, vb2ref, vb1089ref, vb840ref, vb888ref, vb827ref
objref vb906cai,  vb1032cai, vb1089cai, vb840cai, vb884cai
objref vb961ref, vb990ref
objref inaref

//define objects for filenames

//Make folder to store recorded waves into text files   
strdef wave_vectors
wave_vectors="data/nmdawaves"
sprint(econ.syscmd, "mkdir -p %s",wave_vectors)
system(econ.syscmd) 


//==================================================================================================
//Run Experiment -----------------------------------------------------------------------------------
//===================================================================================================
//econ.xopen_library("Terrence","verbose-system")

for runs = 19,19 {

 	splot=new Shape()   
      	COLOR=1+runs
      	rpid=new Random(runs)
      	PID=int(rpid.uniform(1,10000))  // random seed for AMPA/NMDA synapses
      	PID=-PID // choose branchwise  
      	//rpid=new Random(runs+eiter+1)
      	//PIDh=int(rpid.uniform(1,10000)) // random seed for GABA synapses
 
      	lo=0                           // smallest distance of selected obliques from soma
      	hi=10000                        // maximum  distance of selected obliques from soma
	actual_resolution = 75
	desired_resolution = 1
	

	//Record and save waveforms
	//Define objects outside the run procedure
	
	for i = 0,9{
		
		vsoma = new Vector()
		vsoma.record(&soma[0].v(0.5))

/*
		cairec = new Vector(tstop/dt)  //record cai at the soma
		cairec.record(&apical_dendrite[14].cai(0.5))
*/
//currents

		icanrec = new Vector(tstop/dt)  //record ican at the soma
		icanrec.record(&soma[0].in_ican(0.5))
		
/*		inarec = new Vector(tstop/dt)  //record ican at the soma
		inarec.record(&apical_dendrite[21].ina(0.5))

		ip3rec = new Vector(tstop/dt)  //record somacar (ip3receptor-like) at the soma
		ip3rec.record(&apical_dendrite[14].ica_ip3(0.5))


//cai in stimulated dendrites by run
		
		vb906cairec = new Vector()
		vb906cairec.record(&apical_dendrite[906].cai(0.5))
		
		vb1032cairec = new Vector()
		vb1032cairec.record(&apical_dendrite[1032].cai(0.5))

		vb1089cairec = new Vector()
		vb1089cairec.record(&apical_dendrite[1089].cai(0.5))

		vb840cairec = new Vector()
		vb840cairec.record(&apical_dendrite[840].cai(0.5))

		vb884cairec = new Vector()
		vb884cairec.record(&apical_dendrite[884].cai(0.5))
*/

//voltage in stimulated dendrites
		vb7 = new Vector()
		vb7.record(&dend[7].v(0.5))
		
		vb2 = new Vector()
		vb2.record(&dend[2].v(0.5))
/*
		vb1089 = new Vector()
		vb1089.record(&apical_dendrite[1089].v(0.5))

		vb840 = new Vector()
		vb840.record(&apical_dendrite[840].v(0.5))

		vb888 = new Vector()
		vb888.record(&apical_dendrite[888].v(0.5))

		
*/
	

	//List for sadp validation
	trunk_list = new SectionList()
		apic[0] trunk_list.append()	
		apic[2] trunk_list.append()
		apic[4] trunk_list.append()
		apic[5] trunk_list.append()		//first branch off
		apic[10] trunk_list.append()		//first branch off

//list for validation synaptic currents on basal dendrites
		AS_list = new SectionList()
		
//for ratpfc22
		//dend[0] AS_list.append() //basal 17um
		  //dend[3] AS_list.append() //basal 33um	
		//dend[2] AS_list.append() //basal 55um
		//dend[9] AS_list.append() //basal 92um
		//dend[9]  AS_list.append() //basal 145um
		//dend[16] AS_list.append() //basal 62um
		//dend[16] AS_list.append() //basal 123um	

//for C3_4
		//dend[0] AS_list.append() //basal 14um
		//dend[1] AS_list.append() //basal 34um	
		//dend[4] AS_list.append() //basal 47um
		//dend[3] AS_list.append() //basal 55um
		dend[7]  AS_list.append() //basal 78um
		//dend[8] AS_list.append() //basal 114um
		//dend[20] AS_list.append() //basal 154um


	//make a band (list) of randomly selected obliques within lo and hi microns from soma
       	band1 = new SynapseBand(apical,lo,hi,actual_resolution,desired_resolution,PID)  //only apical trunk
	band2 = new SynapseBand(basal,lo,hi,actual_resolution,desired_resolution,PID) //basal_tree
	band3 = new SynapseBand(AS_list,lo,hi,actual_resolution,desired_resolution,PID)
	band4 = new SynapseBand(somatic,lo,hi,actual_resolution,desired_resolution,PID)
	
}


//Run procedure to place ampa and nmda

        
     	k=0
	m=0
	l=0 //initialize the nubmer of synapses used in each run
	n=0

	trunk_synapses=trunk_synapses+1
	basal_synapses= basal_synapses+1

//activate synapses on basal_tree
	synapse_location_basal(band2, init_cluster_number, init_cluster_size, delstimb, l, basal_synapses) 
//activate synapses on apical trunk (use same procedure as for basal)
	//synapse_location_basal(band2, init_cluster_number, init_cluster_size, delstimb, l, basal_synapses) 

print runs


finitialize(v_init)
run()

		somaref = new File()
		sprint(temp, "%s/nsoma-%d.dat", wave_vectors, runs)
		somaref.wopen(temp)
		somaref.printf("soma-%d", runs, "%s\n")
		somaref.printf("\n")
		vsoma.printf(somaref, "%f\n")
		somaref.close()
	
/*		cairef = new File()
		sprint(temp, "%s/cai-%d.dat",  wave_vectors, runs)
		cairef.wopen(temp)
		cairec.printf(cairef, "%f\n")
		cairef.close()
*/
		vb2ref = new File()
		sprint(temp, "%s/vdend2-%d.dat", wave_vectors, runs)
		vb2ref.wopen(temp)
		vb2ref.printf("vb2-%d", runs, "%s\n")
		vb2ref.printf("\n")
		vb2.printf(vb2ref, "%f\n")
		vb2ref.close()


		vb7ref = new File()
		sprint(temp, "%s/vdend7-%d.dat", wave_vectors, runs)
		vb7ref.wopen(temp)		
		vb7ref.printf("vb7-%d", runs, "%s\n")
		vb7ref.printf("\n")
		vb7.printf(vb7ref, "%f\n")
		vb7ref.close()
/*
		vb888ref = new File()
		sprint(temp, "%s/basal888-%d.dat", wave_vectors, runs)
		vb888ref.wopen(temp)
		vb888ref.printf("vb888-%d", runs, "%s\n")
		vb888ref.printf("\n")
		vb888.printf(vb888ref, "%f\n")
		vb888ref.close()

		vb840ref = new File()
		sprint(temp, "%s/basal840-%d.dat", wave_vectors, runs)
		vb840ref.wopen(temp)
		vb840ref.printf("vb840-%d", runs, "%s\n")
		vb840ref.printf("\n")
		vb840.printf(vb840ref, "%f\n")
		vb840ref.close()


		vb906cai = new File()
		sprint(temp, "%s/basal906cai-%d.dat", wave_vectors, runs)
		vb906cai.wopen(temp)		
		vb906cai.printf("vb906cai-%d", runs, "%s\n")
		vb906cai.printf("\n")
		vb906cairec.printf(vb906cai, "%f\n")
		vb906cai.close()

		vb884cai = new File()
		sprint(temp, "%s/basal884cai-%d.dat", wave_vectors, runs)
		vb884cai.wopen(temp)
		vb884cai.printf("vb884cai-%d", runs, "%s\n")
		vb884cai.printf("\n")
		vb884cairec.printf(vb884cai, "%f\n")
		vb884cai.close()

		vb840cai = new File()
		sprint(temp, "%s/basal840cai-%d.dat", wave_vectors, runs)
		vb840cai.wopen(temp)
		vb840cai.printf("vb840cai-%d", runs, "%s\n")
		vb840cai.printf("\n")
		vb840cairec.printf(vb840cai, "%f\n")
		vb840cai.close()


		vb827ref = new File()
		sprint(temp, "%s/basal827-%d.dat", wave_vectors, runs)
		vb827ref.wopen(temp)
		vb827ref.printf("vb827-%d", runs, "%s\n")
		vb827ref.printf("\n")
		vb827.printf(vb827ref, "%f\n")
		vb827ref.close()

		t100ref = new File()
		sprint(temp, "%s/trunk100-%d.dat", wave_vectors, runs)
		t100ref.wopen(temp)
		vtrunk100.printf(t100ref, "%f\n")
		t100ref.close() 


		t200ref = new File()
		sprint(temp, "%s/trunk200-%d.dat", wave_vectors, runs)
		t200ref.wopen(temp)
		vtrunk200.printf(t200ref, "%f\n")
		t200ref.close() 


		t300ref = new File()
		sprint(temp, "%s/trunk300-%d.dat", wave_vectors, runs)
		t300ref.wopen(temp)
		vtrunk300.printf(t300ref, "%f\n")
		t300ref.close()


		t400ref = new File()
		sprint(temp, "%s/trunk400-%d.dat", wave_vectors, runs)
		t400ref.wopen(temp)
		vtrunk400.printf(t400ref, "%f\n")
		t400ref.close() 


		t500ref = new File()
		sprint(temp, "%s/trunk500-%d.dat", wave_vectors, runs)
		t500ref.wopen(temp)
		vtrunk500.printf(t500ref, "%f\n")
		t500ref.close() 

		t600ref = new File()
		sprint(temp, "%s/trunk600-%d.dat", wave_vectors, runs)
		t600ref.wopen(temp)
		vtrunk600.printf(t600ref, "%f\n")
		t600ref.close() 
*/
		icanref = new File()
		sprint(temp, "%s/ican-%d.dat",  wave_vectors, runs)
		icanref.wopen(temp)
		icanrec.printf(icanref, "%f\n")
		icanref.close() 

/*		inaref = new File()
		sprint(temp, "%s/ina-%d.dat",  wave_vectors, runs)
		inaref.wopen(temp)
		inarec.printf(inaref, "%f\n")
		inaref.close() 

*/

}

//=====================Finish Running Experiment===================================================
