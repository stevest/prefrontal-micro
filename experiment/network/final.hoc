//--------------Set parameters and run this for the net (generated from MATLAB scripts)
//--------------Written 1/8/13 Stefanos
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//define a basic assert function (dah):
proc assert(){ 
//print "Asserting: ", $1
	if(!$1){	
		print "Assertion error. Exiting..."
		quit()
	}
}
//----------------------------------------Set parameters--------------------------------------------------------------//
//Import netrork parameters (Connectivity, synaptic weights etc..) from MATLAB
strdef NMDA_MECH, EXEC_CMD
EXEC_CMD = ""

if (EXPERIMENT) { //if Structured...
	sprint(EXEC_CMD,"{xopen(\"experiment_%d/importNetworkParametersSTR.hoc\")}",ID)
} else {
	sprint(EXEC_CMD,"{xopen(\"experiment_%d/importNetworkParametersRND.hoc\")}",ID)
}
//Use execute1() instead of execute() feed the bool into assert
//execute1() does not like the ~ (even if documented otherwise...)
//Also the ~ encloses command in {}, but that is not happening. Go figure..
assert(execute1(EXEC_CMD))

EXEC_CMD = ""
{sprint(EXEC_CMD,"{xopen(\"experiment_%d/importNetworkStimulationHeader.hoc\")}",ID)}
assert(execute1(EXEC_CMD))

/*EXEC_CMD = ""
sprint(EXEC_CMD,"~xopen(\"experiment_%d/importNetworkInhibition.hoc\")",ID)
execute(EXEC_CMD)*/
//if(!xopen("importNetworkParameters.hoc")){print "ERROR	Failed to import network parameters!"}

EXEC_CMD = ""
{sprint(EXEC_CMD,"{xopen(\"experiment_%d/importBackgroundStimParamsHeader.hoc\")}",ID)}
assert(execute1(EXEC_CMD))
//if(!xopen("importBackgroundStimParams.hoc")){print "ERROR	Failed to import network parameters!"}


EXEC_CMD = ""
{sprint(EXEC_CMD,"{xopen(\"experiment_%d/importStimulationParameters.hoc\")}",ID)}
assert(execute1(EXEC_CMD))



//xopen("gap.hoc") //for PV gup junctions


//if(!xopen("importStimulationParameters.hoc")){print "ERROR	Failed to import network parameters!"}
//xopen("importBasal_fAHP.hoc")
//xopen("importBasal_sAHP.hoc")
if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}


//parse stimulation parameters
objref PcellStimList
PcellStimList = new Vector(nPCcells,0)

if(EXPERIMENT){ //if Structured...
	for i=0,PcellStimListSTR.nrow-1{
		PcellStimList.x[PcellStimListSTR.x[i][CLUSTER_ID]]=1

	}
} else {
	for i=0,PcellStimListRND.nrow-1{
		PcellStimList.x[PcellStimListRND.x[i][CLUSTER_ID]] = 1

	}
}


//procedure to choose which Pyramidal morphologies we want in network
if(!xopen("chooseMorphologies.hoc")){print "ERROR	Failed to load choose morphologies!"}
//argument: percentage of IB cells morphologies in network, random seed:
chooseMorphologies(60,0)

if(!xopen("../../lib/basic-graphics.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("../define_objects.hoc")){print "ERROR	Failed to import parameters!"}

if(SIMPLIFIED){
	if(!xopen("pfc_pc_temp.hoc") ){print "ERROR	Failed to load L5Pyramidal hoc!"}
}else{
	if(!xopen("../RS1cell.hoc") ){print "ERROR	Failed to load L5Pyramidal hoc!"}
}

assert(xopen("pv.hoc"))
assert(xopen("cb.hoc")) // Xenia's interneurons: load template for CB/LTS interneuron
assert(xopen("cr.hoc")) // Xenia's interneurons

//fADP for morphology #3:
fadp=0.0//1.27//MUST BE SET FOR EACH MORPHOLOGY!!! //.35// (maximum ~7mV (normal gyrw sta 4mV)me train sta 20Hz (5 clamps diarkeias 1ms, ana 50 ms)current clamp)

if(!xopen("NMDA_Array_1_5.hoc")){print "ERROR	Failed to import NMDA synaptic weights!"}
if(!xopen("AMPA_Array_1_1.hoc")	){print "ERROR	Failed to import AMPA synaptic weights!"}
if(!xopen("NMDA_Array_BG_1_1.hoc")){print "ERROR	Failed to import NMDA synaptic weights!"}

if(SIMPLIFIED){
	//overwrite with NASSI's values:
	//-------------------Set synaptic weights
	ampaweightpr=	0.00024			//Initial stimulus
	nmdaweightpr=	0.22			//Initial stimulus
	ampaweight=	0.00019		//According to Wang(2008)
	gabaweight=	6.9e-4 			//According to Woo(2007)
	gabaweightb=1.05e-4
	ampaweightin=	7.5e-4			//according to Wang,Gao,2009
	nmdaweightin=	3.2e-4			//ratio inmda/iampa for interneuron *0.5(Wang,Gao,2009)
	autogabaweight=	5.1e-4			//According to Bacci (2003) 
	//------------------Set # of synapses
	synapses_backb=15//16//18//60//100
	synapses_backpr=15//16//18//60//100
	synapses_backa=15//16//18//60//100
	synapses_backinh=40
	synapses_inh=1

	//override complex background spiketrains:
	BG_dendSyn = synapses_backb
	BG_apicSyn = synapses_backa
	BG_apicprSyn = synapses_backpr
	BG_PVSyn = synapses_backinh


	Stim_MaxSyn_apic = 40 //synapses sto meeting 27/4/15,,,//40//27//90			//initial stimulation
	Stim_MaxSyn_basal=0//120	//initial stimulation

	/*
	gababweights.x[0]=1.05e-4		//0.2
	gababweights.x[1]=2.22e-4		//0.4
	gababweights.x[2]=3.38e-4		//0.6
	gababweights.x[3]=4.65e-4		//0.8
	*/
	autogabaweight =	5.1e-4
	//gabaweight_pv2pc_b = 1.05e-4 //0.2 GABAb/GABAa ratio

	gabaweight_pv2pc_a = gabaweight    //3.8// GABA gia to RAND connectivity //OVERRIDED!!
	gabaweight_pv2pc_b = gabaweightb    //3.8// GABA gia to RAND connectivity //OVERRIDED!!


	/*nmdaweights.x[0]=0.25		//1.1 ratio //NASSI
	nmdaweights.x[1]=0.35		//1.5
	nmdaweights.x[2]=0.47		//1.9
	nmdaweights.x[3]=0.585		//2.3*/
	for i=0,55{
		nmdaArr.x[i] = NMDAfactor * 0.585
		nmdaArr_bg.x[i] = NMDAfactor_bg * 0.22
	}
	nmdaweight = NMDAfactor * 0.585
	//ampaweight=	0.00019	//NASSI
	for i=0,55{
		ampaArr.x[i] = AMPAfactor * ampaweight	
	}

} else {
// Complex morphologies case:

	Stim_MaxSyn_apic = 100//85 working with gaba 1.0 //27//90			//initial stimulation
	Stim_MaxSyn_basal = 100//82 working with gaba 1.0
	taur_cad = 50//36
	taumin_kca = 0
	//gbar_kca = gbar_kca/100
}

if(!xopen ("network.hoc")){print "ERROR	Failed to import network structure!"}


assert(xopen ("record_par.hoc"))

proc report_gidvecs() { local i, rank
	// reports distribution of cells across hosts
	PC.barrier()  // wait for all hosts to get to this point
	if (PC.id==0) printf("\ngidvecs on %d host(s)\n",PC.nhost)
	for rank=0, PC.nhost-1 {  // host 0 first, then 1, 2, etc.
		if (rank==PC.id) {
			//printf("@host %d: %dPC, %dPV, %dCB, %dCR\n",PC.id,PCcells.count(), PVcells.count(), CBcells.count(), CRcells.count() )
			PCgids.printf()      
			//PVgids.printf()            
			//CBgids.printf()    
			//CRgids.printf()      
		}
	{ PC.barrier() } // wait for all hosts to get to this point
	}
}

/*
// returns true if a given gid is running on the current host
func is_gid_here(){
	gid=$1
	if((gid%PC.nhost)==PC.id) {return(1)}
	return(0)
}

//returns true if the given gid is running on the given host
func is_gid_in_host(){local gid,hostid
	gid=$1
	hostid=$2
	if ((gid%PC.nhost)==hostid) {return(1)}
	return(0)
}

proc printallkbars(){localobj vfilePC
	data_dir = "data"
	strdef syscmd, vfilePC_filename
	sprint(syscmd,"mkdir -p %s",data_dir)
	system(syscmd)
	vfilePC = new File()	
	sprint(vfilePC_filename,"%s/kbsp_dist.dat", data_dir)  
	vfilePC.wopen(vfilePC_filename)
	printf("gkabar\n")
	forsec cell0_list{//dend_list{
		for(x){
			if(ismembrane("kad")) { 
				vfilePC.printf("%1.5f %1.5f\n",distance(), gkabar_kad(0.5))
			}
			if(ismembrane("kap")) { 
				vfilePC.printf("%1.5f %1.5f\n",distance(), gkabar_kap(0.5))
			}
		}
	}
	vfilePC.close()
}
*/


//--------------------------------------Graphs
if(!PARALLEL){
	//if(PLOT){for j=0, 10 {addgraph_2("PCcells.o(j).soma.v(0.5)", 0,tstop, -70, 50)}}
	//addgraph_2("PCcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)
	/*addgraph_2("PCcells[1].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[2].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[3].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[4].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[5].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[6].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[7].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[8].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PCcells[9].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("PVcells[0].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("CBcells[0].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("CRcells[0].soma.v(0.5)", 0,tstop, -70, 50)*/
	//addgraph_2("Pcells[0].soma.v(0.5)", 0,tstop, -70, 50)
	//addgraph_2("Pcells[2].soma.v(0.5)", 0,tstop, -70, 50)
	/*addgraph_2("Pcells[3].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("Pcells[4].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("Pcells[5].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("Pcells[6].soma.v(0.5)", 0,tstop, -70, 50)
	addgraph_2("Pcells[7].soma.v(0.5)", 0,tstop, -70, 50)*/
	//addgraph_2("Pcells[0].dend[7].v(0.5)", 0,tstop, -70, 50)
	//addgraph_2("Pcells[0].soma[0].cai(0.5)", 0,tstop, 0, 0.01)
	//addgraph("Pcell[0].soma.ik_kca(0.5)",-70,50)
	//addgraph("Pcell[0].soma.ik_Ks(0.5)",-70,50)
}



//addgraph_2("INcells[0].soma.v(0.5)", 0,tstop, -80, 50)
//if(PLOT){splot=new Shape()}
//forsec Pcells[0].somatic {shape.color(2)}
//forsec Pcells[0].axonal {shape.color(5)}
//forsec Pcells[0].basal {shape.color(3)}
//forsec Pcells[0].apical {shape.color(6)}

//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//
//---For many experiments
strdef syscmd, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr ,exp_dir


strdef temp
//objref vsoma1, vsoma2, vsoma3, vsoma4, insoma, insomab, curampa, curnmda, curgabaa, curgabab, DendDist, Params
//objref campa[PC2PC_MaxSyn], ct[8][Stim_MaxSyn], cnmda[PC2PC_MaxSyn], cnmdat[Stim_MaxSyn], cgabaa[PV2PC_MaxSyn], campaa[PC_MaxAutosyn], cnmdaa[PC_MaxAutosyn], campain[Stim_MaxSyn], cnmdain[Stim_MaxSyn], cgabaat[PV2PC_MaxSyn], cgabab[PV2PC_MaxSyn], cgababt[PV2PC_MaxSyn], ampac, nmdac, gabaac, gababc	
//objref gababweights, nmdaweights, adpweights
//----record total cell population spike activity
objref timevec, idvec, recncs, tobj, nil, total_activity
//xopen("values_gabaweight.hoc")
//xopen("values_nmda.hoc")
//xopen("values_adp.hoc")

strdef foutput

objref ic2[5]
proc train() {
	initDelay = 10
	for i=0,4 {
		PCcells.o(0).soma ic2[i]=new IClamp(0.5)
		ic2[i].del=initDelay	
		ic2[i].dur=5
		ic2[i].amp=3//(nA)
		initDelay = initDelay + 50
}}

sadp_soma()
sadp_dend()
sadp_apical()  //mplokara kai stous apical

//strdef vfilePC_filename
assert(sprint(exp_dir,"experiment_%d",ID))
assert(sprint(syscmd,"mkdir -p %s",exp_dir))

if(!system(syscmd)){
	sprint(pprintStr,"Directory %s already exists",exp_dir)
	pprint(pprintStr)
}
assert(sprint(data_dir,"%s",EXP))
assert(sprint(syscmd,"mkdir -p %s/%s",exp_dir,data_dir))
if(!system(syscmd)){
	sprint(pprintStr,"Directory %s already exists",data_dir)
	pprint(pprintStr)
 }


proc vclamp_proc() {
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {vc = new VClamp(0.5)}
		vc.amp[0]= $2
		vc.dur[0]=tstop
	}
}

proc TTX_proc() {
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {
			for(x) {
				if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
				if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
			}
		}
		forsec PC.gid2cell($1).apical {
			for(x) {
				if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
				if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
			}
		}
		forsec PC.gid2cell($1).basal {
			for(x) {
				if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
				if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
			}
		}
	}
}

proc iclamp_proc() {
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[0] = new IClamp(0.5)}
		ic[0].amp = $2
		ic[0].dur = 100
		ic[0].del = 1100
	}
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[1] = new IClamp(0.5)}
		ic[1].amp = $2
		ic[1].dur = 100
		ic[1].del = 1300
	}
	/*if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[2] = new IClamp(0.5)}
		ic[2].amp = $2
		ic[2].dur = 137.0
		ic[2].del = 715.3
	}
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[3] = new IClamp(0.5)}
		ic[3].amp = $2
		ic[3].dur = 205.2
		ic[3].del = 1733.4
	}
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[4] = new IClamp(0.5)}
		ic[4].amp = $2
		ic[4].dur = 116.0
		ic[4].del = 2583.9
	}
	if (PC.gid_exists($1)) { 
		PC.gid2cell($1).soma {ic[5] = new IClamp(0.5)}
		ic[5].amp = -0.1
		ic[5].dur = tstop
		ic[5].del = 0
	}*/
}

//tstop = 1600 
//n=int(tstop/dt)
objref Wvec,Gvec
Wvec = new Vector(6)
Gvec = new Vector(6)
Wvec.x[0] = 0.25
Wvec.x[1] = 0.35
Wvec.x[2] = 0.47
Wvec.x[3] = 0.585
Wvec.x[4] = 0.685
Wvec.x[5] = 0.785
Gvec.x[0] = 0.4 
Gvec.x[1] = 0.6
Gvec.x[2] = 0.8
Gvec.x[3] = 1.0
Gvec.x[4] = 1.2
Gvec.x[5] = 1.4

TOTALRUNS = 7//Wvec.size() * Gvec.size()
for runs = 6, TOTALRUNS-1 {
	Gidx = runs%Gvec.size()
	Widx = int(runs * Gvec.size() / (Wvec.size() * Gvec.size()))
print "Runs is: ",runs
print "Gidx is: ", Gidx
print "Widx is: ", Widx

	if(PARALLEL){
		if(DEBUG){report_gidvecs()}
		if (PC.id == 0) {
			sprint(syscmd,"mkdir -p multi_core")
			system(syscmd)
		}
		{ PC.barrier()	}
		{ PC.set_maxstep(steps_per_ms) }
		if (PC.id==0){ 
			printf("Current run is: %d\n",runs)
			print "Loading ... ",runs, " in host ", PC.id
			print "maxstep=",steps_per_ms
		}  
	}else{
		//foutput = "single_core"
		//sprint(syscmd,"mkdir -p %s/",foutput) 	
		//if(!system(syscmd)) print "Directory ",foutput," already exists"
		assert(xopen("recordandsave/record.hoc"))
		assert(xopen("recordandsave/save_data.hoc"))
	}

	

	//Import respective stimulation/background spikes:
	EXEC_CMD = ""
	//sprint(EXEC_CMD,"{xopen(\"experiment_%d/importNetworkStimulation_run_%04d.hoc\")}",ID,runs+1)
	sprint(EXEC_CMD,"{xopen(\"experiment_%d/importNetworkStimulation_run_%04d.hoc\")}",ID,1)
	pprint(EXEC_CMD)
	assert(execute1(EXEC_CMD))
	EXEC_CMD = ""
	//sprint(EXEC_CMD,"{xopen(\"experiment_%d/importBackgroundStimParams_run_%04d.hoc\")}",ID,runs+1)
	sprint(EXEC_CMD,"{xopen(\"experiment_%d/importBackgroundStimParams_run_%04d.hoc\")}",ID,1)
	pprint(EXEC_CMD)
	assert(execute1(EXEC_CMD))
	
	//override complex background spiketrains:
	BG_dendSyn = 15//16
	BG_apicSyn = 15//16
	BG_apicprSyn = 15//16
	BG_PVSyn = 40
	
	//override complex background spiketrains:
	//BG_dendSyn = synapses_backb
	//BG_apicSyn = synapses_backa
	//BG_apicprSyn = synapses_backpr
	//BG_PVSyn = synapses_backinh
	
	
	//ECA_30()
	//thinner_basal()
	//thinner_apical()
	stimulation(0,0)   //synaptic location Random seed, axon conductanse delay Random seed
	//clampStim(runs)
	//backgroundActivity(0,0) //NO PARALLEL SAFE : try producing the sequence in one node then stimulate each cell
	//backgroundActivityPV(0,0) //~11Hz Petersen Carl
	/*backgroundActivityCB(runs) //~2Hz Petersen Carl
	backgroundActivityCR(runs) //~2Hz Petersen Carl
	*/
	
	//if runs is a constant Randoms do not change (synapse location etc..)
	connectPC2PC(0,0,Wvec.x[Widx])// synaptic location Random seed, axon conductanse delay Random seed
	GABAbFactor = Gvec.x[Gidx]
	connectPV2PV(0,0)// ssynaptic location Random seed, axon conductanse delay Random seed
	connectPC2PV(0,0)// synaptic location Random seed, axon conductanse delay Random seed
	connectPV2PC(0,0)// synaptic location Random seed, axon conductanse delay Random seed
	/*connectPC2CB(runs)
	connectPC2CR(runs)	
	connectCB2PC(runs)
	connectCR2PC(runs)
	connectCR2CB(runs)*/
	//noise(0)
	//train()
	//TTX_proc(GPYID) 
	//iclamp_proc(0,-0.1)

	/*
	if (VCLAMP){
		vclamp_proc(GPYID,VCLAMP)
	}
	*/

	//PCcells.o(0).dend[0] { sectionPointMechSnapshot() }
	//PCcells.o(2).soma[0] { sectionMembraneMechSnapshot("somaMech.txt") }
	//PCcells.o(0).dend[0] { print nseg}

	if(PARALLEL){
		recordedCells = new Vector()
		for lala=0,offsets.x(5)-1{ // record all cells!
		  par_rec_membrane_voltage(lala)
		}
		spikerecord()//record spike events of each cell 
		par_rec_cai(0)
		//record_source_spikes()

		//if(VCLAMP){par_rec_vclamp_current(GPYID)}

		stdinit()
		runtime=startsw()
		PC.psolve(tstop)
		runtime = startsw() - runtime

		if (PC.id==0){
			print "node ", PC.id, "reached tstop"
		}
		{ PC.barrier()	} 
		par_save_membrane_voltage(data_dir,CLUSTER_ID,ID, ISBINARY)
		par_save_synaptic_locations_PCrec(data_dir,CLUSTER_ID,ID,0)
		//par_save_inmda(data_dir,CLUSTER_ID,ID,0)
		//par_save_sumall_inmda(data_dir,CLUSTER_ID,ID,0)
		//par_save_icacai(data_dir,CLUSTER_ID,ID,0)
		//par_save_inhibition(data_dir, CLUSTER_ID,ID,0)
		//spikeout(data_dir,CLUSTER_ID,ID,ISBINARY)//Save PV spike events
		//par_save_synaptic_delays(data_dir,CLUSTER_ID,ID,ISBINARY)

		//par_save_cai(0,CLUSTER_ID,ID)
		//save_source_spikes(data_dir,CLUSTER_ID,ID)
		//save_source_DIST(data_dir,CLUSTER_ID,ID)
		//if(VCLAMP){par_save_vclamp_current(data_dir,CLUSTER_ID,ID)}
	}else{
		rec_membrane_voltage()

		if(PLOT){
		for j=0, PCcells.count()-1 {
			PCcells.o(j).soma { //etsi doulevei sto @$#%!@#$%@#$% NEURON...
				addgraph_2("v(0.5)", 0,tstop, -70, 50)
			}
		}
		PCcells.o(0).dend[11] { //etsi doulevei sto @$#%!@#$%@#$% NEURON...
				addgraph_2("v(0.5)", 0,tstop, -70, 50)
		}
		//PCcells.o(0) { //etsi doulevei sto @$#%!@#$%@#$% NEURON...
			addgraph_2("nmdaOnPC[0][0][0].inmda(0.5)", 0,tstop, -70, 50)
		//}
}


		runtime=startsw()
		run()
		runtime = startsw() - runtime
		printf("Runtime: %10.4g\n", runtime)
		
		//if(DEBUG){printf("DEBUG: Saving runs Params...\n")}
		//save_distances()
		//if(DEBUG){printf("DEBUG: DONE Saving Distances...\n")}
		save_membrane_voltage(data_dir,CLUSTER_ID,ID)
		//if(DEBUG){printf("DEBUG: DONE Saving Voltages...\n")}
		//save_PID()
		//if(DEBUG){printf("DEBUG: DONE Saving PIDs...\n")}
	}
	
	/*for qz=0,PCcells.count()-1 {
		//printf("%d\n", PCgids.x(qzq))
		sprint(tempString,"somaMech%d.txt",PCgids.x(qz))
		print tempString
		PCcells.o(qz).dend[0] { sectionMembraneMechSnapshot(tempString) }
	}*/
	printf("Runtime: %10.4g\n", runtime)
}

if(PARALLEL){
	//printallkbars()
	//print "Work done on node ", PC.id
	{ PC.runworker() }
	{ PC.done() }// tell workers to quit
	print "Success"
	quit()
}


