//Set parameters and run this for the net (generated from MATLAB scripts)
//Written 1/8/13 stamatiad.st@gmail.com
DEBUG=1
ISBINARY=0
//Get the serial_no as an integer:
SNd=0
sscanf(SN,"%d",&SNd)
// OVVERIDES CAREFULL DO NOT COMMIT!
strdef PATH, PPRINT_CMD, EXEC_CMD, temp, STDOUT, PPRINT_CMD,pprintStr
//PATH = "/home/cluster/stefanos/Documents/GitHub/prefrontal-micro/experiment/network/"
PATH = SIMHOME
inittime=startsw()
//The assert argument:
//An assert is there to help you, by alerting you to errors that must never occur in the first place.
proc assert(){ 
	if(!$1){	
		print "Assertion error. Exiting..."
		quit()
	}
}
objref PC
if (name_declared("PARALLEL")!=5) { // PARALLEL has not been assigned a numerical value from command line
        PARALLEL = 0 //Default single core
}
if(PARALLEL){
        {PC=new ParallelContext()}
        if(PC.id==0){ printf("Microcircuit running in %d CORES !\n\n", PC.nhost()) }
}else{
         printf("Microcircuit running in 'SINGLE CORE' !\n\n")
}
if(NO_MG){
         printf("Microcircuit running with no Mg blockage!\n\n")
} 
//process to print only on node zero (if parallel):
proc pprint(){
        //if (name_declared("PC")==2){
        if (PARALLEL){
                if(PC.id==0){print $s1}
        } else {
                print $s1
	}
}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}
{system("echo $(date)", PPRINT_CMD)}
{sprint(STDOUT, "NEURON MPIRUN STARTING AT: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//JOBID is generated from SGE so get it: {sprint(STDOUT, "JOB NAME: %s",JOBNAME)}
{pprint(STDOUT)}
{system("echo $JOB_ID", PPRINT_CMD)}
{sprint(STDOUT, "JOB ID: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//{system("echo $JOB_NAME	", PPRINT_CMD)}
//{sprint(JOBNAME, "%s",PPRINT_CMD)}
//JOBNAME: read it from arguments, because of envars bug.
{pprint("Git sha1: ")}
{pprint(GITSHA1)}
//objref strFun
//{strFun = new StringFunctions()}
//{strFun.left(JOBNAME,strFun.len(JOBNAME)-1)}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}

if(PARALLEL){

} else {
//if(!load_file("nrniv.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//TODO: this should go in a variable outside the simulation:
//{load_file("/home/cluster/stefanos/Libraries/nrn/share/nrn/lib/hoc/stdrun.hoc")}
{load_file("./stdrun.hoc")}
//Don't load NEURONS gui, since it contains a init() that messes with my custom initialization
//if(!load_file("nrniv.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
}
if(PARALLEL){PC.barrier}
if(1){pprint("Load NEURON environment.")}
//----------------------------------------Set parameters--------------------------------------------------------------//
//Import netrork parameters (Connectivity, synaptic weights etc..) from MATLAB
EXEC_CMD = ""
sprint(EXEC_CMD,"{xopen(\"%simportNetworkParameters_%s_SN%d_.hoc\")}", PATH, EXPERIMENT, SNd)
if(PARALLEL){PC.barrier}
tstop = TSTOP_SEC * 1000
//Use execute1() instead of execute() feed the bool into assert
//execute1() does not like the ~ (even if documented otherwise...)
//Also the ~ encloses command in {}, but that is not happening. Go figure..
pprint(EXEC_CMD)
if(1){assert(execute1(EXEC_CMD))}
if(1){pprint("Load Network Parameters.")}

if(PARALLEL){PC.barrier}

{sprint(EXEC_CMD,"{xopen(\"%smain_parameters.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
<<<<<<< HEAD

sprint(pprintStr,"Microcircuit running with simplified morphologies !\n\n")
pprint(pprintStr)

if (name_declared("TRIAL")!=5){
	exit(1)
}
if (name_declared("EXPERIMENT")!=4){
	exit(1)
}
if (name_declared("CLUSTBIAS")!=5){
	exit(1)
}
if (name_declared("EXCITBIAS")!=5){
	exit(1)
}
if (name_declared("INHIBIAS")!=5){
	exit(1)
}

// given a cell index ($1) and the type of cell ($2), return the gid
// As for $2, 0 stands for pyramidal cells, 1 for PVs
objref offsets
{offsets = new Vector()}
{offsets.append(0,nPCcells,nPVcells)}
{offsets.append(offsets.sum(0,offsets.size()-1))}

//global_gid=offsets.v[offsets.size()-1]  // points to the next available gid
func ind2gid(){local i  
  if(numarg()<2) { printf("wrong number of arguments to func ind2gid") }
  i=$1+offsets.sum(0,$2)
  if(i>=offsets.sum(0,$2+1)) { i-=1 }   
  return i 
}

// register the connection target locally given a synapse gid and a synapse mechanism as arguments
// if given additional arguments, it will set them as weight, delay, and threshold, respectively
// http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2158
obfunc makeSynapse(){ localobj nc, src
	if(PARALLEL){
		nc=PC.gid_connect($3,$o4)

	}else{
		src = $o1
		access src.o($2).axon
		nc = new NetCon(&v(x),$o4)
	}
	nc.threshold = $5
	nc.delay = $6
	nc.weight = $7
	return nc
}

func gid2local(){local i localobj arg
	arg = $o1
	for i=0, arg.size()-1 {
		if(arg.x(i) == $2){
			return i
		}
	}
	return -1 //if error
}
=======

sprint(pprintStr,"Microcircuit running with simplified morphologies !\n\n")
pprint(pprintStr)

if (name_declared("TRIAL")!=5){
	exit(1)
}
if (name_declared("EXPERIMENT")!=4){
	exit(1)
}
if (name_declared("CLUSTBIAS")!=5){
	exit(1)
}
if (name_declared("EXCITBIAS")!=5){
	exit(1)
}
if (name_declared("INHIBIAS")!=5){
	exit(1)
}

// given a cell index ($1) and the type of cell ($2), return the gid
// As for $2, 0 stands for pyramidal cells, 1 for PVs
objref offsets
{offsets = new Vector()}
{offsets.append(0,nPCcells,nPVcells)}
{offsets.append(offsets.sum(0,offsets.size()-1))}

//global_gid=offsets.v[offsets.size()-1]  // points to the next available gid
func ind2gid(){local i  
  if(numarg()<2) { printf("wrong number of arguments to func ind2gid") }
  i=$1+offsets.sum(0,$2)
  if(i>=offsets.sum(0,$2+1)) { i-=1 }   
  return i 
}

// register the connection target locally given a synapse gid and a synapse mechanism as arguments
// if given additional arguments, it will set them as weight, delay, and threshold, respectively
// http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2158
obfunc makeSynapse(){ localobj nc, src
	if(PARALLEL){
		nc=PC.gid_connect($3,$o4)

	}else{
		src = $o1
		access src.o($2).axon
		nc = new NetCon(&v(1),$o4)
	}
	nc.threshold = $5
	nc.delay = $6
	nc.weight = $7
	return nc
}

obfunc makeSynapseFromArtificial(){ localobj nc
	nc = new NetCon($o1, $o2)
	nc.threshold = $3
	nc.delay = $4
	nc.weight = $5
	return nc
}

func gid2local(){local i localobj arg
	arg = $o1
	for i=0, arg.size()-1 {
		if(arg.x(i) == $2){
			return i
		}
	}
	return -1 //if error
}

//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}
if(PARALLEL){PC.barrier}
if(1){pprint("Load Main Parameters.")}
//---For many experiments
strdef syscmd, data_dir, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr

if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Stimulation is OK.")}
>>>>>>> debug4

//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}
if(PARALLEL){PC.barrier}
if(1){pprint("Load Main Parameters.")}
//---For many experiments
strdef syscmd, data_dir, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr

if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Stimulation is OK.")}

{sprint(EXEC_CMD,"{xopen(\"%spfc_pc_temp.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load cell templates.")}

{sprint(EXEC_CMD,"{xopen(\"%spv.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load interneuron templates.")}



if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Define network parameters.")}
{sprint(EXEC_CMD,"{xopen(\"%snetwork.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load network parameters.")}

{sprint(EXEC_CMD,"{xopen(\"%srecord_par.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}

if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Load record routines.")}

objref timevec, idvec, recncs, tobj, nil, total_activity

if(PARALLEL){
	{ PC.set_maxstep(steps_per_ms) }
}

if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{stimulation(%d,%d,%d)}",SNd,TRIAL,LEARN_COND)}
	{assert(execute1(EXEC_CMD))}
	//stimulation(0,0)   //synaptic location Random seed, axon conductanse delay Random seed
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}

//if RUN is a constant Randoms do not change (synapse location etc..)
//connectPC2PC(0,0,Wvec.x[Widx])// synaptic location Random seed, axon conductanse delay Random seed
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPC2PC(%d,%d,%d)}",SNd,TRIAL,LEARN_COND)}
	{assert(execute1(EXEC_CMD))}
	sprint(PPRINT_CMD,"%s executed OK.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	//connectPC2PC(0,0,0.585)// synaptic location Random seed, axon conductanse delay Random seed
}
//GABAbFactor = 10.7//Gvec.x[Gidx]
//network working with 0.47 (1.9) NMDA/AMPA, 10.7 gababfactor and 70 synchronus stim synapses
if(0){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPV2PV(%d,%d,%d)}",SNd,TRIAL,LEARN_COND)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPV2PV(0,0)// ssynaptic location Random seed, axon conductanse delay Random seed
}
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPC2PV(%d,%d,%d)}",SNd,TRIAL,LEARN_COND)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPC2PV(0,0)// synaptic location Random seed, axon conductanse delay Random seed
}
if(0){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPV2PC(%d,%d,%d)}",SNd,TRIAL,LEARN_COND)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPV2PC(0,0)// synaptic location Random seed, axon conductanse delay Random seed
}

if(0){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{noise(%d)}",TRIAL)}
	{assert(execute1(EXEC_CMD))}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}

//Run the simulation
//=============================================================================
for pyr=0,nPCcells-1{ // record all cells!
  rec_soma_voltage(pyr)
  rec_dend_voltage(pyr)
}
for pvs=nPCcells,nPCcells+nPVcells-1{ // record all cells!
  rec_soma_voltage(pvs)
}
{pprint("----------------------------------------------------------------------------------------")}
{pprint("Commencing run!")}
{pprint("----------------------------------------------------------------------------------------")}
inittime = startsw() - inittime
{sprint(PPRINT_CMD,"Network Initialization time: %10.4g minutes.\n", inittime/60)}
{pprint(PPRINT_CMD)}
inittime=startsw()
//stdinit() //not such function after devel version 7.4
{sprint(EXEC_CMD,"{xopen(\"%sbalance_compartments.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
fadp=0.0//1.27//MUST BE SET FOR EACH MORPHOLOGY!!! //.35// (maximum ~7mV (normal gyrw sta 4mV)me train sta 20Hz (5 clamps diarkeias 1ms, ana 50 ms)current clamp)
balance_compartments()
inittime = startsw() - inittime
{sprint(PPRINT_CMD,"Compartment Initialization (stdinit()) time: %10.4g minutes.\n", inittime/60)}
{pprint(PPRINT_CMD)}
runtime=startsw()
if(PARALLEL){
	PC.psolve(tstop)
}else{
	run()
}
sprint(PPRINT_CMD,"Simulation reached tstop: %d ms.\n",tstop)
{pprint(PPRINT_CMD)}
runtime = startsw() - runtime
{sprint(PPRINT_CMD,"Runtime: %10.4g minutes.\n", runtime/60)}
{pprint(PPRINT_CMD)}
if(PARALLEL){ PC.barrier()}
	
if(1){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_soma_voltage.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_soma_voltage(JOBDIR,TRIAL, ISBINARY)
	{pprint("par_save_soma_voltage() is active.")}
}
if(save_dend_voltage){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_voltage.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_dend_voltage(JOBDIR,TRIAL, ISBINARY)
	{pprint("par_save_dend_voltage() is active.")}
}
if(save_synaptic_locations){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_synaptic_locations_PCrec.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_synaptic_locations_PCrec(JOBDIR,TRIAL,0)
	{pprint("par_save_synaptic_locations_PCrec() is active.")}	
}

if(save_stimulation_locations){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_stimulation_locations_PCrec.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_stimulation_locations_PCrec(JOBDIR,TRIAL,0)
	{pprint("par_save_stimulation_locations_PCrec() is active.")}
}

if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_synaptic_delays.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_synaptic_delays(JOBDIR,TRIAL,ISBINARY)
	{pprint("par_save_synaptic_delays() is active.")}
}

//TODO: these are not made to work without PC!
if(save_bg_iampa){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_bg_iampa.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_bg_iampa(JOBDIR,TRIAL,0)
	{pprint("par_save_bg_iampa() is active.")}
}
if(save_inmda){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_inmda.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_dend_inmda(JOBDIR,TRIAL, ISBINARY)
	{pprint("par_save_dend_inmda() is active.")}
	//par_save_inmda(JOBDIR,TRIAL,ISBINARY)
	//{pprint("par_save_inmda() is active.")}
}
if(save_igaba){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_igaba.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_dend_igaba(JOBDIR,TRIAL, ISBINARY)
	{pprint("par_save_dend_igaba() is active.")}
}



if(PARALLEL){
	{ PC.barrier }
	{ PC.runworker() }
	{ PC.done() }// tell workers to quit
}
//Only master node is active now.
print "Success"
//Run matlab script to analyze the data!.
//print "Running epilog script..."
{sprint(EXEC_CMD,"python %sload_raw_batch.py \"%s\"",PATH,JOBDIR)}
//exitcode = system(EXEC_CMD)
//{sprint(EXEC_CMD,"%sepilog.sh \"%s\" \"%s\"",PATH,PATH,JOBDIR)}
//exitcode = system(EXEC_CMD)
quit()

