//Set parameters and run this for the net (generated from MATLAB scripts)
//Written 1/8/13 stamatiad.st@gmail.com
DEBUG=1
ISBINARY=0
ID=12
// OVVERIDES CAREFULL DO NOT COMMIT!
strdef PATH, PPRINT_CMD, EXEC_CMD, temp, STDOUT, PPRINT_CMD,pprintStr
//PATH = "/home/cluster/stefanos/Documents/GitHub/prefrontal-micro/experiment/network/"
PATH = SIMHOME
inittime=startsw()
//{load_file("/home/cluster/stefanos/Libraries/nrn/share/nrn/lib/hoc/stdrun.hoc")}
//The assert argument:
//An assert is there to help you, by alerting you to errors that must never occur in the first place.
proc assert(){ 
	if(!$1){	
		print "Assertion error. Exiting..."
		quit()
	}
}
objref PC
if (name_declared("PARALLEL")!=5) { // PARALLEL has not been assigned a numerical value from command line
        PARALLEL = 0 //Default single core
}
if(PARALLEL){
        {PC=new ParallelContext()}
        if(PC.id==0){ printf("Microcircuit running in %d CORES !\n\n", PC.nhost()) }
}else{
         printf("Microcircuit running in 'SINGLE CORE' !\n\n")
}
//process to print only on node zero (if parallel):
proc pprint(){
        //if (name_declared("PC")==2){
        if (PARALLEL){
                if(PC.id==0){print $s1}
        } else {
                print $s1
	}
}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}
{system("echo $(date)", PPRINT_CMD)}
{sprint(STDOUT, "NEURON MPIRUN STARTING AT: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//JOBID is generated from SGE so get it: {sprint(STDOUT, "JOB NAME: %s",JOBNAME)}
{pprint(STDOUT)}
{system("echo $JOB_ID", PPRINT_CMD)}
{sprint(STDOUT, "JOB ID: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//{system("echo $JOB_NAME	", PPRINT_CMD)}
//{sprint(JOBNAME, "%s",PPRINT_CMD)}
//JOBNAME: read it from arguments, because of envars bug.
{pprint("Git sha1: ")}
{pprint(GITSHA1)}
//objref strFun
//{strFun = new StringFunctions()}
//{strFun.left(JOBNAME,strFun.len(JOBNAME)-1)}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}

if(PARALLEL){

} else {
if(!load_file("nrniv.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
}
if(PARALLEL){PC.barrier}
if(1){pprint("Load NEURON environment.")}
//----------------------------------------Set parameters--------------------------------------------------------------//
//Import netrork parameters (Connectivity, synaptic weights etc..) from MATLAB
EXEC_CMD = ""
if (EXPERIMENT) { //if Structured...
	{sprint(EXEC_CMD,"{xopen(\"%simportNetworkParametersSTR_SN%s_Fs_%g_Cl_%g_custompv_sn1.hoc\")}",PATH,SN,FS,CL)}
} else {
	sprint(EXEC_CMD,"{xopen(\"%simportNetworkParametersRND_SN%s_Fs_%g_Cl_%g.hoc\")}",PATH,SN,FS,CL)
}
if(PARALLEL){PC.barrier}
tstop = TSTOP_SEC * 1000
//Use execute1() instead of execute() feed the bool into assert
//execute1() does not like the ~ (even if documented otherwise...)
//Also the ~ encloses command in {}, but that is not happening. Go figure..
pprint(EXEC_CMD)
if(1){assert(execute1(EXEC_CMD))}
if(1){pprint("Load Network Parameters.")}

EXEC_CMD = ""
{sprint(EXEC_CMD,"{xopen(\"%simportStimulationParameters_SN%s_Fs_%g_Cl_%g_rndI50_custom.hoc\")}",PATH,SN,FS,CL)}
if(1){assert(execute1(EXEC_CMD))}
if(PARALLEL){PC.barrier}

{sprint(EXEC_CMD,"{xopen(\"%smain_parameters.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}

sprint(pprintStr,"Microcircuit running with simplified morphologies !\n\n")
pprint(pprintStr)

if (name_declared("TRIAL")!=5){
	exit(1)
}
if (name_declared("EXPERIMENT")!=4){
	exit(1)
}
if (name_declared("CLUSTBIAS")!=5){
	exit(1)
}
if (name_declared("EXCITBIAS")!=5){
	exit(1)
}
if (name_declared("INHIBIAS")!=5){
	exit(1)
}

// given a cell index ($1) and the type of cell ($2), return the gid
// As for $2, 0 stands for pyramidal cells, 1 for PVs
objref offsets
{offsets = new Vector()}
{offsets.append(0,nPCcells,nPVcells)}
{offsets.append(offsets.sum(0,offsets.size()-1))}

//global_gid=offsets.v[offsets.size()-1]  // points to the next available gid
func ind2gid(){local i  
  if(numarg()<2) { printf("wrong number of arguments to func ind2gid") }
  i=$1+offsets.sum(0,$2)
  if(i>=offsets.sum(0,$2+1)) { i-=1 }   
  return i 
}

// register the connection target locally given a synapse gid and a synapse mechanism as arguments
// if given additional arguments, it will set them as weight, delay, and threshold, respectively
// http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2158
obfunc makeSynapse(){ localobj nc, src
	if(PARALLEL){
		nc=PC.gid_connect($3,$o4)

	}else{
		src = $o1
		access src.o($2).axon
		nc = new NetCon(&v(x),$o4)
	}
	nc.threshold = $5
	nc.delay = $6
	nc.weight = $7
	return nc
}

func gid2local(){local i localobj arg
	arg = $o1
	for i=0, arg.size()-1 {
		if(arg.x(i) == $2){
			return i
		}
	}
	return -1 //if error
}

//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}
if(PARALLEL){PC.barrier}
if(1){pprint("Load Main Parameters.")}
//---For many experiments
strdef syscmd, data_dir, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr

if(PARALLEL){PC.barrier}
//parse stimulation parameters
objref PcellStimList
{PcellStimList = new Vector(nPCcells,0)}

if(EXPERIMENT){ //if Structured...
	//print "StimulatedPNs.size() = ",StimulatedPNs[CLUSTER_ID].size()
	for i=0,StimulatedPNs[CLUSTER_ID].size()-1{
		//print " ",StimulatedPNs[CLUSTER_ID].x[i]	
		PcellStimList.x[StimulatedPNs[CLUSTER_ID].x[i]]=1
		// {sprint(PPRINT_CMD,"Stimulating cell: %d",StimulatedPNs[CLUSTER_ID].x[i])}
		//if(DEBUG){pprint(PPRINT_CMD)}

	}
//validate stimulation:
assert( PcellStimList.sum() == StimulatedPNs[CLUSTER_ID].size() )
} else {
	for i=0,PcellStimListRND[CLUSTER_ID].size()-1{
		PcellStimList.x[PcellStimListRND[CLUSTER_ID].x[i]] = 1

	}
//validate stimulation:
assert( PcellStimList.sum() == PcellStimListRND[CLUSTER_ID].size() )
}
if(DEBUG){pprint("Stimulation is OK.")}


if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Parse Stimulation Parameters.")}

{sprint(EXEC_CMD,"{xopen(\"%spfc_pc_temp.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load cell templates.")}

{sprint(EXEC_CMD,"{xopen(\"%spv.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load interneuron templates.")}



if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Define network parameters.")}
{sprint(EXEC_CMD,"{xopen(\"%snetwork.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
if(DEBUG){pprint("Load network parameters.")}

{sprint(EXEC_CMD,"{xopen(\"%srecord_par.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}

if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Load record routines.")}

objref timevec, idvec, recncs, tobj, nil, total_activity

if(PARALLEL){
	{ PC.set_maxstep(steps_per_ms) }
}

if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{stimulation(%d,%d,%d)}",SNd,CLUSTER_ID,LOCCL)}
	{assert(execute1(EXEC_CMD))}
	//stimulation(0,0)   //synaptic location Random seed, axon conductanse delay Random seed
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}

//if RUN is a constant Randoms do not change (synapse location etc..)
//connectPC2PC(0,0,Wvec.x[Widx])// synaptic location Random seed, axon conductanse delay Random seed
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPC2PC(%d,%d,%d)}",SNd,CLUSTER_ID,LOCCL)}
	{assert(execute1(EXEC_CMD))}
	sprint(PPRINT_CMD,"%s executed OK.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	//connectPC2PC(0,0,0.585)// synaptic location Random seed, axon conductanse delay Random seed
}
//GABAbFactor = 10.7//Gvec.x[Gidx]
//network working with 0.47 (1.9) NMDA/AMPA, 10.7 gababfactor and 70 synchronus stim synapses
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPV2PV(%d,%d,%d)}",SNd,CLUSTER_ID,LOCCL)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPV2PV(0,0)// ssynaptic location Random seed, axon conductanse delay Random seed
}
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPC2PV(%d,%d,%d)}",SNd,CLUSTER_ID,LOCCL)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPC2PV(0,0)// synaptic location Random seed, axon conductanse delay Random seed
}
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{connectPV2PC(%d,%d,%d)}",SNd,CLUSTER_ID,LOCCL)}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
	{assert(execute1(EXEC_CMD))}
	//connectPV2PC(0,0)// synaptic location Random seed, axon conductanse delay Random seed
}

if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{noise(%d)}",RUN)}
	{assert(execute1(EXEC_CMD))}
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}

if(PARALLEL){
	recordedCells = new Vector()
	for pyr=0,nPCcells-1{ // record all cells!
	  par_rec_soma_voltage(pyr)
	  par_rec_dend_voltage(pyr)
	}
	for pvs=nPCcells,nPCcells+nPVcells-1{ // record all cells!
	  par_rec_soma_voltage(pvs)
	}

	{pprint("----------------------------------------------------------------------------------------")}
	{pprint("Commencing Parallel run!")}
	{pprint("----------------------------------------------------------------------------------------")}
	inittime = startsw() - inittime
	{sprint(PPRINT_CMD,"Network Initialization time: %10.4g minutes.\n", inittime/60)}
	{pprint(PPRINT_CMD)}
	inittime=startsw()
	//stdinit() //not such function after devel version 7.4
	{sprint(EXEC_CMD,"{xopen(\"%sbalance_compartments.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	fadp=0.0//1.27//MUST BE SET FOR EACH MORPHOLOGY!!! //.35// (maximum ~7mV (normal gyrw sta 4mV)me train sta 20Hz (5 clamps diarkeias 1ms, ana 50 ms)current clamp)
	balance_compartments()
	inittime = startsw() - inittime
	{sprint(PPRINT_CMD,"Compartment Initialization (stdinit()) time: %10.4g minutes.\n", inittime/60)}
	{pprint(PPRINT_CMD)}
	runtime=startsw()
	PC.psolve(tstop)
	runtime = startsw() - runtime
	sprint(PPRINT_CMD,"All reached tstop: %d ms.\n",tstop)
	{pprint(PPRINT_CMD)}
	{ PC.barrier()	}
	
	if(1){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_soma_voltage.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_soma_voltage(JOBDIR,CLUSTER_ID, ISBINARY)
		{pprint("par_save_soma_voltage() is active.")}
	}
	if(save_dend_voltage){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_voltage.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_dend_voltage(JOBDIR,CLUSTER_ID, ISBINARY)
		{pprint("par_save_dend_voltage() is active.")}
	}
	if(save_synaptic_locations){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_synaptic_locations_PCrec.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_synaptic_locations_PCrec(JOBDIR,CLUSTER_ID,0)
		{pprint("par_save_synaptic_locations_PCrec() is active.")}	
	}
	
	if(save_stimulation_locations){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_stimulation_locations_PCrec.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_stimulation_locations_PCrec(JOBDIR,CLUSTER_ID,0)
		{pprint("par_save_stimulation_locations_PCrec() is active.")}
	}

	if(save_synaptic_delays){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_synaptic_delays.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_synaptic_delays(JOBDIR,CLUSTER_ID,ISBINARY)
		{pprint("par_save_synaptic_delays() is active.")}
	}

	if(save_bg_iampa){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_bg_iampa.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_bg_iampa(JOBDIR,CLUSTER_ID,0)
		{pprint("par_save_bg_iampa() is active.")}
	}
	if(save_inmda){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_inmda.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_dend_inmda(JOBDIR,CLUSTER_ID, ISBINARY)
		{pprint("par_save_dend_inmda() is active.")}
		//par_save_inmda(JOBDIR,CLUSTER_ID,ISBINARY)
		//{pprint("par_save_inmda() is active.")}
	}
	if(save_igaba){
		{sprint(EXEC_CMD,"{xopen(\"%spar_save_dend_igaba.hoc\")}",PATH)}
		if(1){assert(execute1(EXEC_CMD))}
		par_save_dend_igaba(JOBDIR,CLUSTER_ID, ISBINARY)
		{pprint("par_save_dend_igaba() is active.")}
	}

}

{sprint(PPRINT_CMD,"Runtime: %10.4g minutes.\n", runtime/60)}
{pprint(PPRINT_CMD)}

if(PARALLEL){
	{ PC.barrier }
	{ PC.runworker() }
	{ PC.done() }// tell workers to quit
	//Only master node is active now.
	print "Success"
	//Run matlab script to analyze the data!.
	print "Running epilog script..."
	{sprint(EXEC_CMD,"%sepilog.sh \"%s\" \"%s\"",PATH,PATH,JOBDIR)}
	exitcode = system(EXEC_CMD)
	quit()
}

