// will be Vectors that record all spike times (tvec) 
// see also http://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/classes/parcon.html#spike_record

// store voltage currents to files
strdef str, vfilePC_filename, EXEC_CMD

// If you save the stdout to a file you can sort the results. A nice idiom is sort -k 1n,1n -k 2n,2n temp1 > temp
//All the spike times and cells are the same as in the serial implementation, as we can verify by capturing the outputs of the two programs to files, sorting the parallel output, and comparing
//$ # numeric sort on spike time, then cell id 
//$ sort -n -k 1 -k 2 serout.txt > sorted_serout.txt 
//$ sort -n -k 1 -k 2 parout.txt > sorted_parout.txt 
//$ cmp sorted_serout.txt sorted_parout.txt

// see this here on the topic of storing membrane voltage in a parallel context: http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=1987
objref r_volts[offsets.x[offsets.size()-1]],r_msec[offsets.x[offsets.size()-1]]
objref r_dvolts[offsets.x[offsets.size()-1]]
// each recorded range variable must have a separate tvec which will be different for different cells
objref recordedCells
recordedCells = new Vector()
// recording routines for the parallel context
proc par_rec_membrane_voltage(){local i,s,q  // use gid as parameter
	if (PC.gid_exists($1)) { 
		//if(DEBUG){printf("Recording cell %d voltage on node %d\n", $1,PC.id)}
		s=recordedCells.size()
		r_volts[s]=new Vector(n)
		r_dvolts[s]=new Vector(n)
		r_msec[s]=new Vector(n)
		//Also a known bug:
		//http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2046
		for q=0,n-1 {r_msec[s].x[q]=q*dt }
		PC.gid2cell($1).soma {cv.record(&v(0.5),r_volts[s],r_msec[s],0)}
		PC.gid2cell($1).dend[0] {cv.record(&v(VARPID),r_dvolts[s],r_msec[s],0)}
		recordedCells.append($1)
		//print "Recording cell: ", $1
	}
}

proc par_save_membrane_voltage() {local i,s,j,fctr localobj vfilePC
	/*
	vfilePC = new File()	
	sprint(vfilePC_filename,"%s/%d_%d_%d.%s", $s1,$2,0, RUN,"bin") 
	print "Saving @ ", vfilePC_filename
	vfilePC.wopen(vfilePC_filename)
	fh = vfilePC.isopen()
	fctr = 0
	while (!fh) {
		vfilePC.wopen(vfilePC_filename)
		fh = vfilePC.isopen()
		fctr = fctr + 1
	}
	print "@ ",PC.id," File ",vfilePC_filename," opened after ",fctr, " attempts!"
	vfilePC.close()
*/
	{ PC.barrier() } 
	strdef ext
	if ($4) {
		ext = "bin"
	} else {
		ext = "txt"
	}
	for s=0,recordedCells.size()-1{
		//print "Saving Cell: ",recordedCells.x(s)
		vfilePC = new File()	
		sprint(vfilePC_filename,"%s/%03d_%03d_%03d.%s", $s1,recordedCells.x(s),RUN,$2,ext) 
		//print "Saving @ ", vfilePC_filename
		vfilePC.wopen(vfilePC_filename)
		fh = vfilePC.isopen()
		fctr = 0
		while (!fh) {
			vfilePC.wopen(vfilePC_filename)
			fh = vfilePC.isopen()
			fctr = fctr + 1
		}
		if(fctr>0){print "@ ",PC.id," File ",vfilePC_filename," opened after ",fctr, " attempts!"}
		if ($4) {
			for j=0, r_volts[s].size()-1 {
				vfilePC.vwrite(&r_volts[s].x[j])
			}
		} else {
			r_volts[s].printf(vfilePC,"%8.4f\n")
		}
		vfilePC.close()
	}
	{ PC.barrier() }
	

} //End save membrane voltage proc

objref cuminmdaPC2PC[nPCcells][nPCcells]
proc par_save_inmda(){local i,s,q,srcPC,trgPC  localobj vfilePC// Record GID
	{ PC.barrier() } 
	strdef ext
	if ($4) {
		ext = "bin"
	} else {
		ext = "txt"
	}

	for trg=0,nPCcells-1 {
		for src=0, nPCcells-1 {
			srcPC = ind2gid(src,0)
			trgPC = ind2gid(trg,0)
			//if(srcPC!=trgPC){
				//if (C.x[srcPC][trgPC]) {
				if (object_id(inmdaPC2PC[srcPC][trgPC][0])) {
					cuminmdaPC2PC[srcPC][trgPC] = new Vector(n,0)
					for syn=0, PC2PC_MaxSyn-1 {// for all target neurons on this node
						for k = 0, n-1{
							cuminmdaPC2PC[srcPC][trgPC].x[k] = cuminmdaPC2PC[srcPC][trgPC].x[k] + inmdaPC2PC[srcPC][trgPC][syn].x[k]
						}
					}
					vfilePC = new File()	
					sprint(vfilePC_filename,"%s/inmda_srcPC%03d_trgPC%03d.%s", $s1, srcPC,trgPC,ext) 
					//sprint(vfilePC_filename,"experiment_%d/%s/inmda_trg_%d_runs_%d.%s", $3,EXP,PCgids.x[trg],runs,ext) 
					vfilePC.wopen(vfilePC_filename)
					
					if ($4) {
						for j=0, cuminmdaPC2PC[srcPC][trgPC].size()-1 {
							vfilePC.vwrite(&cuminmdaPC2PC[srcPC][trgPC].x[j])
						}
					} else {
						cuminmdaPC2PC[ind2gid(src,0)][ind2gid(trg,0)].printf(vfilePC,"%8.4f\n")
					}
					vfilePC.close()
				}
			//}
		}
	}
}
/*
proc par_save_synaptic_locations_PCrec(){ local fh, fctr localobj vfilePC 

	{ PC.barrier() } 
	strdef ext
	if ($4) {
	ext = "bin"
	} else {
	ext = "txt"
	}
	//save PC2PC synaptic locations
	for trg=0, nPCcells-1{
		for src=0, nPCcells-1{
			{PC.barrier()}
			if(object_id(pidPC2PC[src][trg])!= 0){
				print "Synaptic locations src: ",src," ,target: ",trg," : "
				for ii=0,pidPC2PC[src][trg].size()-1{
					print pidPC2PC[src][trg].x[ii], " "
				}
			}
		}
	}
}

proc par_save_stimulation_locations_PCrec(){ 
	{ PC.barrier() } 
	strdef ext
	if ($4) {
	ext = "bin"
	} else {
	ext = "txt"
	}
	for src=0, nPCcells-1{
		{PC.barrier()}
		if (object_id(stimpidPC2PC[src]) != 0){
			str = ""
			sprint(str,"Stimulation locations src %d:",src)
			for ii=0,stimpidPC2PC[src].size()-1{
				sprint(str,"%s %f",str, stimpidPC2PC[src].x[ii])
			}
			print str
		}
	}
}

proc par_save_synaptic_delays(){ 
	{ PC.barrier() } 
	for src=0, nPCcells-1{
	for trg=0, nPCcells-1{
		{PC.barrier()}
		if (object_id(delayPC2PC[src][trg]) != 0){
			str = ""
			sprint(str,"Delays src %d, trg %d:",src,trg)
			for ii=0,delayPC2PC[src][trg].size()-1{
				sprint(str,"%s %f",str, delayPC2PC[src][trg].x[ii])
			}
			print str
		}
	}
	}
}
*/
