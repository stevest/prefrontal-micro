//Based on Durstewitz and Gabriel 2006, "Irregular spiking in NMDA-driven prefrontal cortex neurons"
//Written 18-04-08, modified 29/07/09
//xopen ("pfc_pc_temp.hoc") //load template for pyramidal cells
//xopen ("incell.hoc")      //load template for interneuron

//----------------------------Insert variables to be used for stimulations and connections-----------------------------//
//--------------------Insert variable for random placement of synapses and delays in the connections
objref r, f, fin, fpin, finp, fp, stimrand
objref all_msec
all_msec = new Vector(n,0)
for q=0,n-1 {all_msec.x[q]=q*dt }

//---- Section Reference Variables----//
BDendsNo = 18
objref SectionArray[nPCcells][BDendsNo]
objref auxilist_basal[nPCcells] 
for lala=0, (nPCcells-1) {
	auxilist_basal[lala] = new List()
}
objref random_basal[nPCcells]
                    for gaga=0, (nPCcells-1) {
                    	random_basal[gaga] = new SectionList()
                    }
objref rnd, distancesMat, pidMat
distancesMat = new Matrix(nPCcells,(PC2PC_MaxSyn+2)*nPCcells)
pidMat = new Matrix(nPCcells,(PC2PC_MaxSyn+2)*nPCcells)


//-----------------------Stimulations
objref ncAMPA[nPCcells][Stim_MaxSyn], nsNMDA[nPCcells][Stim_MaxSyn],nsAMPA[nPCcells][Stim_MaxSyn], ncNMDA[nPCcells][Stim_MaxSyn], ampapr[nPCcells][Stim_MaxSyn], nmdapr[nPCcells][Stim_MaxSyn]
objref vstim_stim[nPCcells][Stim_MaxSyn]

//PC-PC connections
//autosynapses
objref autoampaOnPC[nPCcells][PC_MaxAutosyn]
objref autonmdaOnPC[nPCcells][PC_MaxAutosyn]
objref conautoampaPC2PC[nPCcells][PC_MaxAutosyn]
objref conautonmdaPC2PC[nPCcells][PC_MaxAutosyn]
//recurrent synapses
objref ampaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref nmdaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref conampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref connmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]


//PV-PV connections
objref gabaOnPV_A[nPVcells][nPVcells][PV2PV_MaxSyn]
objref congabaPV2PV_A[nPVcells][nPVcells][PV2PV_MaxSyn]

//PC-PV connections
objref ampaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref nmdaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref conampaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref connmdaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]


//--------------------PV-PC connections
objref gabaOnPC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref gabaOnPC_B[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_B[nPVcells][nPCcells][PV2PC_MaxSyn]

//--------------------PV background
objref vstim_pv[nPVcells][BG_PVSyn]
objref ampaBGPV[nPVcells][BG_PVSyn]
objref nmdaBGPV[nPVcells][BG_PVSyn]
objref BGPV_NMDA[nPVcells][BG_PVSyn]
objref BGPV_AMPA[nPVcells][BG_PVSyn]

// others
objref PCns, PVns, CBns, CRns
objref PCsw, PVsw, CBsw, CRsw


//--------------------Background activity 
objref vstimd[nPCcells][BG_dendSyn]
objref vstima[nPCcells][BG_apicSyn]
objref vstimp[nPCcells][BG_apicprSyn]
objref ampaBGd[nPCcells][BG_dendSyn]
objref nmdaBGd[nPCcells][BG_dendSyn]
objref ampaBGp[nPCcells][BG_apicprSyn]
objref nmdaBGp[nPCcells][BG_apicprSyn]
objref ampaBGa[nPCcells][BG_apicSyn]
objref nmdaBGa[nPCcells][BG_apicSyn]

objref BG_AMPAd[nPCcells][BG_dendSyn]
objref BG_NMDAd[nPCcells][BG_dendSyn]
objref BG_AMPAa[nPCcells][BG_apicSyn]
objref BG_NMDAa[nPCcells][BG_apicSyn]
objref BG_AMPAp[nPCcells][BG_apicprSyn]
objref BG_NMDAp[nPCcells][BG_apicprSyn]

//----------------------------------------------Insert noise-----------------------------------------------------------//
//INSERT MOD FILE FOR SINE WAVE
objref PCns[nPCcells], PVns[nPCcells], CBns[nPCcells], CRns[nPCcells]
objref PCsw[nPCcells], PVsw[nPCcells], CBsw[nPCcells], CRsw[nPCcells]

proc noise() { local i
	i=0
	forsec PCsoma_list {
			PCns[i] = new Random(i+ID*$1) 
			PCns[i].poisson(0.5)	//was (0.02)	
			PCsw[i] = new membNoise(0.5)
			PCsw[i].dur = tstop //duration of injection
			PCsw[i].freq = 100//180 //80 //how many sinusoidals in a second
			PCsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PCsw[i].getRandObjPtr(PCns[i])
			i = i +1
	}

	i=0
	forsec PVsoma_list {
			PVns[i] = new Random(i+ID*$1+1) 
			PVns[i].poisson(0.5)	//was (0.02)	
			PVsw[i] = new membNoise(0.5)
			PVsw[i].dur=tstop //duration of injection
			PVsw[i].freq = 100 //180 //how many sinusoidals in a second
			PVsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PVsw[i].getRandObjPtr(PVns[i])
			i = i +1
	}
}
//Gap junctions code:
objref par_gaps
par_gaps = new List()
gap_src_gid = 2

/*objref rangap
if (one_tenth_ncell) {
	rangap = new Random()
	rangap.MCellRan4(1)
	rangap.uniform(0,1)
	ranfrac=.1
}*/

proc par_gap_create() { local srcgid , trggid, src
	srcgid = $1
	trggid = $3	
	src = $2
	par_gap_create1(srcgid, trggid, $3)
	/*if (!use_gap) { return }
	if (object_id(rangap)) {
		if (rangap.repick() > ranfrac) { return }
	}
	gap_src_gid += 2
	if ((gid = targetcomp_exists($1, $2)) >= 0) {
		par_gap_create1(gid, $2, gap_src_gid + 1, gap_src_gid, $5)
	}
	if ((gid = targetcomp_exists($3, $4)) >= 0) {
		par_gap_create1(gid, $4, gap_src_gid, gap_src_gid + 1, $5)
	}*/
}
proc par_gap_create_now() {localobj c, g
	c =PC.gid2obj($1)
	c.soma {
		g = new gGapPar(.5)
		par_gaps.append(g)
		PC.target_var(g, &g.vgap, $3)
		PC.source_var(&v(.5), $2)
		g.g = $4
	}
}

//---------------------------Initial stimulation (proximal dendrite)(Kuroda, 1998, Constantinides, 2001)---------------//

objref sns
sns  = new NetStim(0.5)
sns.interval=20//14.28//12.5//SSS 
sns.number=50//70//80//SSS
sns.start=0
sns.noise=0//0.2
strdef EXEC_CMD
//The only way to have conditional execution without parser errors
//is to have the commands executed on runtime. Else parser will complain
//about missing variables.
if(save_stimulation_locations){
	{sprint(EXEC_CMD,"{objref stimpidPC2PC[%d]}",nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
objref r_stimPC[nPCcells], rApic_stimPC[nPCcells], rBasal_stimPC[nPCcells] 
proc stimulation() { local i,j,PID,ApicalNo,rApicIdx,BasalNo,rBasalIdx, interval, number,localID,tmp,ridx,trgGID  localobj r,rApic,rBasal,ri,rvect
	if(PARALLEL){ PC.barrier() }
	//Configure RNG for reproducability over differently distributed parallel environments:
	for kk=0,nPCcells-1{
		r_stimPC[kk] = new Random(ID*$1 + 165 + kk )
		rApic_stimPC[kk] = new Random(ID*$1 + 12 + kk)
		rBasal_stimPC[kk] = new Random(ID*$1 + 67 + kk)
		PID = 0.5//r_stimPC[kk].uniform(0,1)
	}

	for i=0, nPCcells - 1  { 
		if(PcellStimList.x(i)){
		trgGID = ind2gid(i,0) //ONLY FOR PC CELLS!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PCgids,trgGID) //target cell
			}else{
				bool=1
				localID = i
			}

			if( bool ){ //&& PcellStimList.x(i)
				if(save_stimulation_locations){
					{sprint(EXEC_CMD,"{stimpidPC2PC[%d] = new Vector()}",trgGID)}
					{assert(execute1(EXEC_CMD))}
				}
				// Apical input:
				for j=0, (Stim_MaxSyn_apic-1) {
					//PID=r_stimPC[i].repick()
					rApicIdx = int(rApic_stimPC[i].uniform(0,PCcells.o(localID).ApicNo-1))
					if(save_stimulation_locations){
						{sprint(EXEC_CMD,"{stimpidPC2PC[%d].append(%f)}",trgGID,PID)}
						{assert(execute1(EXEC_CMD))}
					}
					rApicIdx = 0 //PROXIMAL!
					PCcells.o(localID).apic[rApicIdx] {ampapr[i][j] = new GLU(PID)}
					PCcells.o(localID).apic[rApicIdx] {nmdapr[i][j] = new nmda_segev(PID)}

					ncAMPA[i][j] = new NetCon(sns, ampapr[i][j]) //vstim_stim[i][j]
					ncAMPA[i][j].delay=500
					ncAMPA[i][j].weight = ampaweightpr// *15//SSS
					ncAMPA[i][j].threshold=-10 

					ncNMDA[i][j] = new NetCon(sns, nmdapr[i][j])
					ncNMDA[i][j].delay=500
					ncNMDA[i][j].weight = nmdaweightpr// *15//SSS
					ncNMDA[i][j].threshold=-10
				}

			} //if bool
		} //if stimulated
	} //for PC cells
} //end proc

objref bgrecvec
strdef bgrecvec_filename
AllBGsyns = BG_dendSyn+BG_apicSyn+BG_apicprSyn+BG_PVSyn
objref bns[AllBGsyns], psn[AllBGsyns]
for k = 0, AllBGsyns-1 {
	psn[k] = new Random(ID*PC.id*AllBGsyns+k)
	psn[k].poisson(0.002)
	bns[k]  = new poissonStim(0.5)
	bns[k].interval=1//SSS 
	bns[k].number=tstop//SSS
	bns[k].start=0
	bns[k].noise=1
	bns[k].noiseFromRandom(psn[k])
}
proc backgroundActivity() { local i,j,PID,RV,RLB,RLA,localID,tmpGID,StimDur,StimFreq,StimNo,SynapsesNo localobj r,rv,rlb,rla
	/*
	//Matlab handles these:
	SynapsesNo = 500
	StimDur = tstop
	StimFreq = 1 // Hz
	StimNo = StimDur/1000 * StimFreq
	*/
	r = new Random(ID*$1 + 300 + PC.id)
	rv = new Random(ID*$1 +400)
	RV = rv.uniform(1, StimDur)
	PID = 0.5//r.uniform(0,1)
	rlb = new Random(ID*$1+160)
	rla = new Random(ID*$1+560)

	for i=0, nPCcells-1 {
		if(PARALLEL){
			tmpGID = ind2gid(i,0) //ONLY FOR PC CELLS!
			bool = PC.gid_exists(tmpGID)
			localID = gid2local(PCgids,tmpGID) //target cell	
		}else{
			bool=1
			localID = i
		}

		if(bool){
			RLB = rlb.uniform(0,PCcells.o(localID).DendNo-1)
			RLA = rla.uniform(0,PCcells.o(localID).ApicNo-1)
			//Import respective stimulation/background spikes:
			EXEC_CMD = ""
			{sprint(EXEC_CMD,"{xopen(\"/home/cluster/stefanos/Documents/Glia/NEWBGST/BG_cellgid%03d_run_%03d.hoc\")}",i+1,$1+1)}
			{assert(execute1(EXEC_CMD))}
			for j=0, BG_dendSyn-1 {
				//RLB = 0
				//PID = (j+1)/(BG_dendSyn+1)// ?!?!? Why is that?
				RLB = 0 // Basals!!
				PCcells.o(localID).dend[RLB] {ampaBGd[i][j]=new GLU(PID)}
				PCcells.o(localID).dend[RLB] {nmdaBGd[i][j]=new nmda_segev(PID)}

				//PID = r.repick()
				RLB = rlb.repick()
				vstimd[i][j] = new VecStim(0.5)
				vstimd[i][j].delay = 0
				EXEC_CMD = ""
				{sprint(EXEC_CMD,"vstimd[%d][%d].play(BGb%03d[%d])",i,j,i,j)}
				{assert(execute1(EXEC_CMD))} //vstimd[i][j].play(BG_Stim_basal[$2][i][j])
				BG_AMPAd[i][j]=new NetCon(vstimd[i][j], ampaBGd[i][j]) //vstimd[i][j]
				BG_AMPAd[i][j].delay=0
				BG_AMPAd[i][j].weight = ampaweight*5 //SSS		
				BG_AMPAd[i][j].threshold=-10 

				BG_NMDAd[i][j]=new NetCon(vstimd[i][j], nmdaBGd[i][j]) //vstimd[i][j]
				BG_NMDAd[i][j].delay=0
				BG_NMDAd[i][j].weight = 0.25*5 //SSS		
				BG_NMDAd[i][j].threshold=-10  
			}


			for j=0, BG_apicSyn-1 {
				//RLA = 0
				//PID = (j+1)/(BG_apicSyn+1)
				RLA = 1 //distal!!
				PCcells.o(localID).apic[RLA] ampaBGa[i][j]=new GLU(PID)
				PCcells.o(localID).apic[RLA] nmdaBGa[i][j]=new nmda_segev(PID)

				//PID = r.repick()
				RLA = rla.repick()
				vstima[i][j] = new VecStim(0.5)
				vstima[i][j].delay = 0
				EXEC_CMD = ""
				{sprint(EXEC_CMD,"vstima[%d][%d].play(BGa%03d[%d])",i,j,i,j)}
				{assert(execute1(EXEC_CMD))}
				//vstima[i][j].play(BG_Stim_Apic[$2][i][j])
				BG_AMPAa[i][j]=new NetCon(vstima[i][j], ampaBGa[i][j])//vstima[i][j]
				BG_AMPAa[i][j].delay=0
				BG_AMPAa[i][j].weight = ampaweightpr*5 //SSS		
				BG_AMPAa[i][j].threshold=-10 

				BG_NMDAa[i][j]=new NetCon(vstima[i][j], nmdaBGa[i][j])
				BG_NMDAa[i][j].delay=0
				BG_NMDAa[i][j].weight = 0.2*5 //SSS		
				BG_NMDAa[i][j].threshold=-10 
			}

			for j=0, BG_apicprSyn-1 {
				//RLA = 0
				//PID = (j+1)/(BG_apicprSyn+1)
				RLA = 0 //proximal!!
				PCcells.o(localID).apic[RLA] ampaBGp[i][j]=new GLU(PID)
				PCcells.o(localID).apic[RLA] nmdaBGp[i][j]=new nmda_segev(PID)

				//PID = r.repick()
				//RLA = rla.repick()
				vstimp[i][j] = new VecStim(0.5)
				vstimp[i][j].delay = 0
				EXEC_CMD = ""
				{sprint(EXEC_CMD,"vstimp[%d][%d].play(BGap%03d[%d])",i,j,i,j)}
				{assert(execute1(EXEC_CMD))}
				//vstimp[i][j].play(BG_Stim_Apicpr[$2][i][j])
				BG_AMPAp[i][j]=new NetCon(vstimp[i][j], ampaBGp[i][j])//vstimp[i][j]
				BG_AMPAp[i][j].delay=0
				BG_AMPAp[i][j].weight = ampaweightpr*5 //SSS		
				BG_AMPAp[i][j].threshold=-10 

				BG_NMDAp[i][j]=new NetCon(vstimp[i][j], nmdaBGp[i][j])
				BG_NMDAp[i][j].delay=0
				BG_NMDAp[i][j].weight =  0.22*5 //SSS		
				BG_NMDAp[i][j].threshold=-10 
			}
		}//end bool
	}
}//end proc

objref pvns
pvns  = new NetStim(0.5)
pvns.number=40//SSS
pvns.interval=tstop/pvns.number//SSS 
pvns.start=0
pvns.noise=1
//----------------------------------------------PV background activity-------------------------------------------------------//
proc backgroundActivityPV() { local PID,trg,syn,bool,localID,trgGID localobj r
	if(PARALLEL){ PC.barrier() }
	r = new Random(ID*$1 + 150)
	PID = 0.5//r.uniform(0,1)

		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					// to dend as in XENIA. (Was at the soma):
					EXEC_CMD = ""
					{sprint(EXEC_CMD,"{xopen(\"/home/cluster/stefanos/Documents/Glia/NEWBGST/BG_cellgid%03d_run_%03d.hoc\")}",trgGID+1,$1+1)}
					{assert(execute1(EXEC_CMD))}
					for syn=0, (BG_PVSyn-1) {

						//PID = r.repick()
						PVcells.o(localID).dend ampaBGPV[trg][syn] = new GLUIN(PID) //no Dends available in the model! (???????)
						PVcells.o(localID).dend nmdaBGPV[trg][syn] = new NMDA(PID)
			
						vstim_pv[trg][syn] = new VecStim(0.5)
						vstim_pv[trg][syn].delay = 0
						EXEC_CMD = ""
						{sprint(EXEC_CMD,"vstim_pv[%d][%d].play(BGs%03d[%d])",trg,syn,trgGID,syn)}
						{assert(execute1(EXEC_CMD))}
						//vstim_pv[trg][syn].play(BG_Stim_SomaPV[$2][trg][syn])

						BGPV_AMPA[trg][syn]=new NetCon(vstim_pv[trg][syn], ampaBGPV[trg][syn]) //vstim_pv[trg][syn]
						BGPV_AMPA[trg][syn].delay=0
						BGPV_AMPA[trg][syn].weight =   ampaweightin*10 //SSS 
						BGPV_AMPA[trg][syn].threshold=-10

						BGPV_NMDA[trg][syn]=new NetCon(vstim_pv[trg][syn], nmdaBGPV[trg][syn])
						BGPV_NMDA[trg][syn].delay=0
						BGPV_NMDA[trg][syn].weight =   nmdaweightin*10 //SSS 
						BGPV_NMDA[trg][syn].threshold=-10
   
					}
				}

	}
} //end procedure 

// recurrent synaptic clusternig algorithm (for variation)
func clustbias(){ local rb,oldPID localobj rbo
	//arguments (many!)
	//$1 = PID old
	//$2 = runs serial number
	oldPID = $1
	//rbo = new Random(ID*$2+PC.id)
	rb = $2//rbo.uniform(0,1)
	//this function may be implemented weird: the (default/old) PID is clustering synapses in the same point on a specific dend,
	//the new PID is deviating from clustering synapses by a random amount with weight 1-CLUSTBIAS.
	//So, smaller values of CLUSTBIAS mean more deviation from clustering the synapses.
	//when CLUSTBIAS==0: new PID == Random(0,1) (non clustered synapses)
	//when CLUSTBIAS==1: new PID == old PID (clustered synapses - default)

	return ((rb-oldPID)* (1-CLUSTBIAS)) + oldPID 
}

// ---------------------------------PC-PC connections, basal dendrite(Thomson, 1997)------------------------------------//

objref clusterDend[nPCcells], clusterPID[nPCcells], clusterDIST
for i=0,nPCcells-1{
	clusterDend[i] = new Vector()
	clusterPID[i] = new Vector()
}
clusterPID = new Vector()
clusterDIST = new Vector(nPCcells)
objref Devents[nPCcells]
strdef temp
objref PIDfile, FIDfile
//objref arrFID[nPCcells][nPCcells][PC2PC_MaxSyn]
//objref arrPID[nPCcells][nPCcells][PC2PC_MaxSyn]
objref dummyNetCon[nPCcells]
if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_synaptic_locations){
	{sprint(EXEC_CMD,"{objref pidPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_inmda){
	{sprint(EXEC_CMD,"{objref inmdaPC2PC[%d][%d][%d]}",nPCcells,nPCcells,PC2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
}
/*objref curnmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref curampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref icaPC2PC[nPCcells]
objref caiPC2PC[nPCcells]
*/
objref RN_PC2PC[nPCcells],r_PC2PC[nPCcells],fp_PC2PC[nPCcells],rDend_PC2PC[nPCcells]
proc connectPC2PC() { local i,j,FIDp,PID,BasalNo,rDendidx,synCtr,trg,src,syn,bool,localID,trgGID,srcGID,localNMDAweight,arg,rn localobj null
	arg = $3
	if(PARALLEL){ PC.barrier() }
	
	//set parallel PID randomness
	for kk=0,nPCcells-1{
		r_PC2PC[kk] = new Random(ID*$1 + 350 + kk ) //ta palia runs (10/8 kai prin) den eixan to PC.id!!
		RN_PC2PC[kk] = new Random(ID*$1 + 360 + kk)
		fp_PC2PC[kk] = new Random(ID*$1 + 3 + kk)	
		rDend_PC2PC[kk] = new Random(ID*$1 + 4 + kk) 
		rn = RN_PC2PC[kk].uniform(0,1)
		PID = r_PC2PC[kk].uniform(0,1)
		FIDp=fp_PC2PC[kk].normal(1.7,0.9)	//According to Thomson(2007)
	}

	//rDend = new Random($1+4 + PC.id ) //ta palia runs (10/8 kai prin) den eixan to PC.id!!
	//rDend = new Random(ID*$1+4) //ta palia runs (10/8 kai prin) den eixan to PC.id!!

	//Create clustering connectivity lists for recurrent connections:
	for i=0, PCcells.count()-1 {
		//i=0
		for syn=0, (PC2PC_MaxSyn-1) {
			PID = r_PC2PC[PCgids.x[i]].repick()
			//PID = VARPID //bias MCMC
			rDendidx = int(rDend_PC2PC[PCgids.x[i]].uniform(0,PCcells.o(i).DendNo-1) )
			clusterDend[PCgids.x[i]].append(rDendidx)
			//uniformly distribute synapses along basals:
			//PID = (1/PC2PC_MaxSyn)/2 + ((1/PC2PC_MaxSyn)*syn)
			//print " uniform spreaded synapse#",syn," is @ PID = ",PID
			clusterPID[PCgids.x[i]].append(PID)
		}
		//PID=r.repick()
	}

	for trg=0, nPCcells-1 {
		for src=0, nPCcells-1 {
			for syn=0, PC2PC_MaxSyn-1 {
				connmdaPC2PC[src][trg][syn] = null
				conampaPC2PC[src][trg][syn] = null
				nmdaOnPC[src][trg][syn] = null
				ampaOnPC[trg][src][syn] = null
			}
		}
	}

	for trg=0, nPCcells-1 { 
		trgGID = ind2gid(trg,0) //PC cells!
		if(PARALLEL){
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell
		}else{
			bool=1
			localID = trg
		}
		for src=0,nPCcells-1 {
			srcGID = ind2gid(src,0) //PC cells!
			if(C.x[srcGID][trgGID]){
				if(srcGID!=trgGID){
					if (bool) { 
						//if(DEBUG){printf("Connectivity constraint: PC%d projects to PC%d\n",PCgids.x(src),PCgids.x(trg))}
						//PCcells.o(localID).soma {distance()}
						//PCcells.o(localID).dend[clusterDend.x(localID)] {clusterDIST.x(localID) = distance(clusterPID.x(localID))}
						//PCcells.o(localID).dend[clusterDend.x(localID)] {print "dendritic segments are ", nseg}
						if(save_synaptic_delays){
							{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						if(save_synaptic_locations){
							{sprint(EXEC_CMD,"{pidPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						for syn=0, (PC2PC_MaxSyn-1) { //for current syn
							//PID=r.repick()
							//rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
							clusterDend[trgGID].x(syn) = 0
							//PID = clustbias(clusterPID[trgGID].x[syn],RN_PC2PC[trg].repick())
							PID = VARPID //bias MCMC
							FIDp = abs(fp_PC2PC[trg].repick())
							if( FIDp <= dt ){ FIDp = dt + 0.01 }
							if(save_synaptic_delays){
								{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",src,trg,FIDp)}
								{assert(execute1(EXEC_CMD))}
							}
							if(save_synaptic_locations){
								{sprint(EXEC_CMD,"{pidPC2PC[%d][%d].append(%f)}",src,trg,PID)}
								{assert(execute1(EXEC_CMD))}
							}
							PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {ampaOnPC[src][trg][syn] = new GLU(PID)}					
							PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {nmdaOnPC[src][trg][syn] = new nmda_segev(PID)}					
							if(save_inmda){
								//if( PcellStimList.x(trg)  ){ 			
									{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
									{assert(execute1(EXEC_CMD))}
									{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d].record(&nmdaOnPC[%d][%d][%d].inmda)}",src,trg,syn,src,trg,syn)}
									{assert(execute1(EXEC_CMD))}
								//}
							}
							conampaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,ampaOnPC[src][trg][syn],-20,FIDp,ampaweight *  W.x[srcGID][trgGID] )
							//if(PcellStimList.x(trgGID) ){ 	//All cells with dopamin are enhanced	
								//connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-20,FIDp,arg  *  W.x[srcGID][trgGID] ) 
								//print "Jolted ", src, " ", trg," with weight ", arg
							//} else {
								connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-20,FIDp,0.25  *  W.x[srcGID][trgGID] )
								//print "Connected ", src, " ", trg," with weight ",0.25
							//}
						}
					}
				}
			}//connectivity matrix
		}
	}

	if(PARALLEL){ PC.barrier() }
	//---------------------------------------------------Insert Autapses(Lubke, 1996)
	for i=0, nPCcells-1 {
		for j=0, PC_MaxAutosyn-1 {
			conautonmdaPC2PC[i][j] = null
			conautoampaPC2PC[i][j] = null
			autonmdaOnPC[i][j] = null
			autoampaOnPC[i][j] = null
		}
	}

	for i=0, PCcells.count()-1 {
		//if (C.x[PCgids.x(i)][PCgids.x(i)]) { //If autapses are enabled..
			if(save_synaptic_delays){
				{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",PCgids.x[i],PCgids.x[i])}
				{assert(execute1(EXEC_CMD))}
			}
			for j=0, (PC_MaxAutosyn-1) { 
				//PID=r_PC2PC[PCgids.x[i]].repick()
				PID = VARPID // bias MCMC
				FIDp = abs(fp_PC2PC[PCgids.x[i]].repick())
				rDendidx = int(rDend_PC2PC[PCgids.x[i]].uniform(0,PCcells.o(i).DendNo-1) )
				if( FIDp <= dt ){ FIDp = dt + 0.01 }
				if(save_synaptic_delays){
					{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",PCgids.x[i],PCgids.x[i],FIDp)}
					{assert(execute1(EXEC_CMD))}
				}
				rDendidx = 0
				PCcells.o(i).dend[rDendidx] autoampaOnPC[i][j] = new GLU(PID) 
				PCcells.o(i).dend[rDendidx] {autonmdaOnPC[i][j] = new nmda_segev(PID)}
		//----------------------Connect autapses
				conautoampaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autoampaOnPC[i][j], -20, FIDp,ampaweight)
				if( PcellStimList.x(PCgids.x(i))  ){ //proxeirotita, na psaxnw sto cluster; ta stimulated einai ligotera!			
					conautonmdaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autonmdaOnPC[i][j], -20, FIDp,arg)
				} else {
					conautonmdaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autonmdaOnPC[i][j], -20, FIDp,0.25)
				}
			}
		//}
	}
} //END procedure initPC



//---------------------------------------------PV-PV connections--------------------------------------------------------//
objref r_PV2PV[nPVcells],fp_PV2PV[nPVcells]
proc connectPV2PV() { local delstimpvpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PV2PV[i] = new Random(ID*$1 + 250 + i )
		fp_PV2PV[i] = new Random(ID*$1 - 100 + i )
		PID = r_PV2PV[i].uniform(0,1)
		delstimpvpv = fp_PV2PV[i].normal(1.76,0.07) //latency from IN-IN, according to Bacci (2003)   
	}

	for src=0, nPVcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //NO NEED to account for PC overhead in matrix, gid are GLOBAL ID ;)
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					if (srcGID == trgGID) { //autapses
						for syn=0, 12-1 { //BACCI 2003
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,autogabaweight )
						}
					} else {
						for syn=0, (1-1) {//SSS Single synapse
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,0.002 )
							//congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,0)
						}
						//Connect gap junctions:
						/*if (gapMatrix.x[src][trg]) {
							if (src < trg) {
								par_gap_create_now(trgGID,gapMatrix.x[src][trg]+gidincr,gapMatrix.x[src][trg]+gidincr-1,0.00005)
							} else {
								par_gap_create_now(trgGID,gapMatrix.x[trg][src]+gidincr-1,gapMatrix.x[trg][src]+gidincr,0.00005)
							}
						}*/
						
					}
					//Gap junctions:
					/*if (GapJunc_connMatrix.x[srcGID][trgGID]) { //autapses
						PID = r.repick ()
						PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAain(PID)
						congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,autogabaweight )
					} */
				}
			}
		}
	}

} // End procedure initPV

//----------------------------------------------PC-PV connections-------------------------------------------------------//
objref r_PC2PV[nPVcells],fp_PC2PV[nPVcells]
proc connectPC2PV() { local delstimpcpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp
	if(PARALLEL){ PC.barrier() }

	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PC2PV[i] = new Random(ID*$1 + 150 + i )
		fp_PC2PV[i] = new Random(ID*$1 * 2 + i)
		PID = r_PC2PV[i].uniform(0,1)
		delstimpcpv = fp_PC2PV[i].normal(0.6, 0.2)		//latency from Pc-In, according to Thomson(2007), also Angulo,Audinat(1999) 
	}

	for src=0, nPCcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,0) //PC cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					// to dend as in XENIA. (Was at the soma):
					for syn=0, (PC2PV_MaxSyn-1) {
						PID = r_PC2PV[PVgids.x[localID]-nPCcells].repick ()
						delstimpcpv=abs(fp_PC2PV[PVgids.x[localID]-nPCcells].repick())
						if(delstimpcpv<=dt){delstimpcpv=dt+0.01}
						PVcells.o(localID).dend {ampaOnPV[src][trg][syn] = new GLUIN(PID)} //no Dends available in the model! (???????)
						PVcells.o(localID).dend {nmdaOnPV[src][trg][syn] = new NMDA(PID)}
						conampaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, ampaOnPV[src][trg][syn], -20, delstimpcpv, ampaweightin)
						connmdaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, nmdaOnPV[src][trg][syn], -20, delstimpcpv, nmdaweightin)    
					}
				}
			}
		}
	}
} //end procedure initPC2PV

// Create vectors to record GABA synaptic current per target:
//objref syncurrGABAa[nPVcells][nPCcells][PV2PC_MaxSyn], syncurrGABAb[nPVcells][nPCcells][PV2PC_MaxSyn]
if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPV2PC[%d][%d]}",nPVcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
//------------------------------------------------PV-PC connections-----------------------------------------------------//
objref r_PV2PC[nPCcells],fp_PV2PC[nPCcells], rDend_PV2PC[nPCcells]
proc connectPV2PC() {local delstimpvpc,PID,NoSynapsesSoma,NoSynapsesDend,BasalNo,rDendidx,rApicidx,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp,rDend
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPCcells-1 {
		r_PV2PC[i] = new Random(ID*$1 + 180 + i )
		fp_PV2PC[i] = new Random(ID*$1 * 8 + i)
		rDend_PV2PC[i] = new Random(ID*$1 + 5 + i)
		PID = r_PV2PC[i].uniform(0,1)
		delstimpvpc=fp_PV2PC[i].normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	}

	//delstimpvpc=fpvpc.normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	NoSynapsesSoma = int((PV2PC_MaxSyn * 34) / 100) //percentage was 46 but why? (paper?)
	NoSynapsesDend = PV2PC_MaxSyn - NoSynapsesSoma

	//-----------------------------Connect
	for src=0, nPVcells-1 {
		for trg=0,nPCcells-1 {
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PCgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					//----------------------------Insert synapses at dendrites
					for syn=0,(NoSynapsesDend-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						rDendidx = int(rDend_PV2PC[PCgids.x[localID]].uniform(0,PCcells.o(localID).DendNo-1) )
						//PID = r.repick()
						//rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
						rDendidx = 0 //dendrites!
						PCcells.o(localID).dend[rDendidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
						PCcells.o(localID).dend[rDendidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
						//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn],5)} //colorize
					}
					//----------------------------Insert synapses at proximal apicals
					PCcells.o(localID).soma { distance() }
					for syn=0,(NoSynapsesDend-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						rApicidx = int(rDend_PV2PC[PCgids.x[localID]].uniform(0,PCcells.o(localID).ApicNo-1) )
						//PID = r.repick()
						//rApicidx = int(rDend.uniform(0,PCcells.o(localID).ApicNo-1) )
						rApicidx = 0 //proximal!
						PCcells.o(localID).apic[rApicidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
						PCcells.o(localID).apic[rApicidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
					}
					//----------------------------Insert synapses at soma
					for syn=0,(NoSynapsesSoma-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						//PID = r.repick()					
						PCcells.o(localID).soma gabaOnPC_A[src][trg][syn+NoSynapsesDend] = new GABAa(PID) //carefull not to overwrite array!
						PCcells.o(localID).soma gabaOnPC_B[src][trg][syn+NoSynapsesDend] = new GABAb(PID)

						//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn+NoSynapsesDend],5)} //colorize
					}

					if(save_synaptic_delays){
						{sprint(EXEC_CMD,"{delayPV2PC[%d][%d] = new Vector()}",src,trg)}
						{assert(execute1(EXEC_CMD))}
					}
					for syn=0, (PV2PC_MaxSyn-1) { //for total number of IN-PC synapses
						delstimpvpc=abs(fp_PV2PC[PCgids.x[localID]].repick())
						//delstimpvpc=abs(fpvpc.repick())
						if(delstimpvpc<=dt){delstimpvpc=dt+0.01}
						congabaPV2PC_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_A[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_a*1) //SSS change weight instead of # of synapses
						congabaPV2PC_B[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_B[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_b*1) //SSS DEFAULT WEIGHT is 4 !!
						if(save_synaptic_delays){
							{sprint(EXEC_CMD,"{delayPV2PC[%d][%d].append(%f)}",src,trg,delstimpvpc)}
							{assert(execute1(EXEC_CMD))}
						}
						/*syncurrGABAa[src][trg][syn] = new Vector(n,0)				
						syncurrGABAb[src][trg][syn] = new Vector(n,0)
						syncurrGABAa[src][trg][syn].record(&gabaOnPC_A[src][trg][syn].i,all_msec)
						syncurrGABAb[src][trg][syn].record(&gabaOnPC_B[src][trg][syn].i,all_msec)*/
						
					}
				}
			}
		}
	}
}  //end procedure initPV2PC


//------------------------------------Pharmacological procedures
proc sadp_soma() {
	forsec PCsoma_list{ //soma_list
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= gbar_ican(x)  *fadp}  //0.0001  *fadp//i Nassi exei pio poly ican !
		}
	}
}
proc sadp_dend() {
	forsec PCdend_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= gbar_ican(x)*fadp} //0.0001*0.1
		}
	}
}

proc sadp_apical() {
	forsec PCapical_list {
		for(x) {
			if(ismembrane("ican"))  for(x) { gbar_ican(x)= gbar_ican(x)*fadp} //0.0001*0.1
		}
	}
}






