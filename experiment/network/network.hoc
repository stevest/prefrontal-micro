//Based on Durstewitz and Gabriel 2006, "Irregular spiking in NMDA-driven prefrontal cortex neurons"


//----------------------------------------------Insert noise-----------------------------------------------------------//
//INSERT MOD FILE FOR SINE WAVE
objref PCns, PVns
objref PCsw, PVsw
objref PCns[nPCcells], PVns[nPCcells]
objref PCsw[nPCcells], PVsw[nPCcells]

proc noise() { local i,GID
	i=0
	forsec PCsoma_list {
			GID = PCgids.x(i)
			PCns[i] = new Random(GID+(nPCcells*$1)*SNd) 
			PCns[i].poisson(0.5)	//was (0.02)	
			PCsw[i] = new membNoise(0.5)
			PCsw[i].dur = tstop //duration of injection
			PCsw[i].freq = 100//180 //80 //how many sinusoidals in a second
			PCsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PCsw[i].getRandObjPtr(PCns[i])
			i = i +1
	}

	i=0
	forsec PVsoma_list {
			GID = PVgids.x(i)
			PVns[i] = new Random(GID+(nPVcells*$1)*SNd) 
			PVns[i].poisson(0.5)	//was (0.02)	
			PVsw[i] = new membNoise(0.5)
			PVsw[i].dur=tstop //duration of injection
			PVsw[i].freq = 100 //180 //how many sinusoidals in a second
			PVsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PVsw[i].getRandObjPtr(PVns[i])
			i = i +1
	}
}

//---------------------------Initial stimulation (proximal dendrite)(Kuroda, 1998, Constantinides, 2001)---------------//
//Had issues with parallel execution of NetStim. Lets hope that his gets executed 
// for all the stimulated cells.
//Particularly the NetStim will be created and connected with netcon, but no activity will follow!
//Still havent came to a conclusion about the erroneus behaviour or any fix, appart from 
// instantiating NetStim outside any proc!

//The only way to have conditional execution without parser errors
//is to have the commands executed on runtime. Else parser will complain
//about missing variables.
if(save_stimulation_locations){
	{sprint(EXEC_CMD,"{objref stimpidPC2PC[%d]}",nPCcells)}
	{assert(execute1(EXEC_CMD))}
}

objref ncAMPA[nPCcells][Stim_MaxSyn], nsNMDA[nPCcells][Stim_MaxSyn],nsAMPA[nPCcells][Stim_MaxSyn], ncNMDA[nPCcells][Stim_MaxSyn], ampapr[nPCcells][Stim_MaxSyn], nmdapr[nPCcells][Stim_MaxSyn]

objref r_stimPC[nPCcells]
objref stim_artcell[nPCcells*Stim_MaxSyn_apic]
//keep the GIDs of the stimulation artificial cells
//ALL NetStim artificial cells MUST lie in node 0!
objref rUniformStim[StimulatedPNs[TRIAL].size()*Stim_MaxSyn_apic], rPoissonStim[StimulatedPNs[TRIAL].size()*Stim_MaxSyn_apic]
objref nhPoissonStim[StimulatedPNs[TRIAL].size()*Stim_MaxSyn_apic]
objref STIM_rate_vect

proc stimulation() { local trg,syn,PID,localID,tmp,ridx,trgGID,artgid,bool  localobj mynil
	//argument 1 is the animal model, argument 2 is the trial no, argument 3 is the learning condition	
	if(PARALLEL){ PC.barrier() }
	//Configure RNG for reproducability over differently distributed parallel environments:
	//Synapses and locations stay the same between trials of the same learning condition
	for kk=0,nPCcells-1{
		//Stimulus synapse location on apical random object:
		r_stimPC[kk] = new Random($1*$3 + 165 + kk )
		PID = r_stimPC[kk].uniform(0,1)
	}
	//Only on node zero, create stimulation artificial cells.
	if(PARALLEL){
		bool = (PC.id==0)
	}else{
		bool=1
	}
	if (bool) { 
		for istim=0, StimulatedPNs[TRIAL].size()-1 {
			// Create rate vector holding the Poisson rates:
			// Estimate Poisson lambda from given stimulation frequency
			lambdaMax = SF / 1000
			STIM_rate_vect = new Vector(tstop, 0)
			for i = stim_start, stim_stop - 1{
				STIM_rate_vect.x[i] = lambdaMax
			}
			// place artificial stimulation cells after all the other PV and PN cells (global ids):
			for syn=0, (Stim_MaxSyn_apic-1) {
				// Stim synapses linear index:
				lin_idx = syn + Stim_MaxSyn_apic * istim
				// Use a Poisson process instead of a random one:
				rUniformStim[lin_idx] = new Random(lin_idx+$1+$2+$3)
				rUniformStim[lin_idx].uniform(0,1)
				rPoissonStim[lin_idx] = new Random(lin_idx+$1+$2+$3)
				rPoissonStim[lin_idx].poisson(lambdaMax)
				nhPoissonStim[lin_idx] = new NonHomPoissonStim()
				nhPoissonStim[lin_idx].trgid = istim
				nhPoissonStim[lin_idx].synid = syn 
				nhPoissonStim[lin_idx].getRandObjPtrUniform(rUniformStim[lin_idx])
				nhPoissonStim[lin_idx].getRandObjPtrPoisson(rPoissonStim[lin_idx])
				nhPoissonStim[lin_idx].lambdaMax = lambdaMax 
				nhPoissonStim[lin_idx].play(STIM_rate_vect)
				//artificial cell gids, append to end of PN+PV cells:
				//artgid = syn + Stim_MaxSyn_apic * istim + nPCcells + nPVcells 
				artgid = lin_idx + nPCcells + nPVcells 
				//print "ArtCell ",artgid
				nhPoissonStim[lin_idx].artcellid = artgid
				//associate artgid with current node:
				PC.set_gid2node(artgid,PC.id)
				//print "Associating artgid=",artgid," with PC.id=",PC.id
				//associate ARTIFICIAL_CELL output to artgid:
				PC.cell(artgid, new NetCon(nhPoissonStim[lin_idx], mynil),1)
			}
		}
	}
	//Wait for association to finish:
	if(PARALLEL){PC.barrier()}

	for istim=0, StimulatedPNs[TRIAL].size()-1 {
		trg = StimulatedPNs[TRIAL].x[istim]
		//print "@trg: ",trg
		trgGID = ind2gid(trg,0) //ONLY FOR PC CELLS!
		if(PARALLEL){
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell
		}else{
			bool=1
			localID = trg
		}
		if( bool ){ //&& PcellStimList.x(trg)
			if(save_stimulation_locations){
				{sprint(EXEC_CMD,"{stimpidPC2PC[%d] = new Vector()}",trgGID)}
				{assert(execute1(EXEC_CMD))}
			}
			// Apical input:
			for syn=0, (Stim_MaxSyn_apic-1) {
				// Stim synapses linear index:
				lin_idx = syn + Stim_MaxSyn_apic * istim

				PID=r_stimPC[trg].repick()
				if(save_stimulation_locations){
					{sprint(EXEC_CMD,"{stimpidPC2PC[%d].append(%f)}",trgGID,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				//Stimulate proximal apicals
				PCcells.o(localID).apic[0] {ampapr[trg][syn] = new GLU(PID)}
				PCcells.o(localID).apic[0] {nmdapr[trg][syn] = new nmda_segev(PID)}
				//artgid = syn + Stim_MaxSyn_apic * istim + nPCcells + nPVcells 
				artgid = lin_idx + nPCcells + nPVcells 

				nmdapr[trg][syn].srcgid = artgid
				nmdapr[trg][syn].cellid = trgGID
				nmdapr[trg][syn].sid = syn
				//print "ArtCell: ",artgid, " stimulates: ",trg
				//TODO: this is wrong for the single core version, right? PCcells should be the stim cells!
				ncAMPA[trg][syn] = makeSynapse(PCcells,0,artgid,ampapr[trg][syn],-10,1,ampaweight_stimulus)
				ncNMDA[trg][syn] = makeSynapse(PCcells,0,artgid,nmdapr[trg][syn],-10,1,nmdaweight_stimulus)
			}

		} //if bool
	} //for stimulated PN cells
} //end proc



objref pvns
pvns  = new NetStim(0.5)
pvns.number=40//SSS
pvns.interval=tstop/pvns.number//SSS 
pvns.start=0
pvns.noise=1

// recurrent synaptic clusternig algorithm (for variation)
func clustbias(){ local rb,oldPID,tmp localobj rbo
	//arguments (many!)
	//$1 = PID old
	//$2 = runs serial number
	oldPID = $1
	//rbo = new Random(SNd*$2+PC.id)
	rb = $2//rbo.uniform(0,1)
	//this function may be implemented weird: the (default/old) PID is clustering synapses in the same point on a specific dend,
	//the new PID is deviating from clustering synapses by a random amount with weight 1-CLUSTBIAS.
	//So, smaller values of CLUSTBIAS mean more deviation from clustering the synapses.
	//when CLUSTBIAS==0: new PID == Random(0,1) (non clustered synapses)
	//when CLUSTBIAS==1: new PID == old PID (clustered synapses - default)
	return ((rb-oldPID)* (1-CLUSTBIAS)) + oldPID 
}

// ---------------------------------PC-PC connections, basal dendrite(Thomson, 1997)------------------------------------//

objref clusterDend[nPCcells], clusterPID[nPCcells]
if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_synaptic_locations){
	{sprint(EXEC_CMD,"{objref pidPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_inmda){
	{sprint(EXEC_CMD,"{objref inmdaPC2PC[%d][%d][%d]}",nPCcells,nPCcells,PC2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
	{sprint(EXEC_CMD,"{objref iampaPC2PC[%d][%d][%d]}",nPCcells,nPCcells,PC2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
	{sprint(EXEC_CMD,"{objref nmdaAPC2PC[%d][%d][%d]}",nPCcells,nPCcells,PC2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
}
if(save_igaba){
	{sprint(EXEC_CMD,"{objref igabaaPV2PC[%d][%d][%d]}",nPVcells,nPCcells,PV2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
	{sprint(EXEC_CMD,"{objref igababPV2PC[%d][%d][%d]}",nPVcells,nPCcells,PV2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
}

//PC-PC connections
//autosynapses
objref autoampaOnPC[nPCcells][PC_MaxAutosyn]
objref autonmdaOnPC[nPCcells][PC_MaxAutosyn]
objref conautoampaPC2PC[nPCcells][PC_MaxAutosyn]
objref conautonmdaPC2PC[nPCcells][PC_MaxAutosyn]
//recurrent synapses
objref ampaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref nmdaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref conampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref connmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]

objref RN_PC2PC[nPCcells],r_PC2PC[nPCcells],fp_PC2PC[nPCcells]
proc connectPC2PC() { local i,j,FIDp,PID,synCtr,trg,src,syn,bool,localID,trgGID,srcGID,rn,rsg localobj null
	//argument 1 is the animal model, argument 2 is the trial no, argument 3 is the learning condition	
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for kk=0,nPCcells-1{
		//SOS added +sth to the seed to get different configs of clustering
		//This is the PID, i.e. synapse location random object:
		r_PC2PC[kk] = new Random($1*$3 + 350 + kk)// No pseudorandom PID variability between runs.
		RN_PC2PC[kk] = new Random($1*$3 + 360 + kk)
		fp_PC2PC[kk] = new Random($1*$3 + 3 + kk)	
		rn = RN_PC2PC[kk].uniform(0,1)
		PID = r_PC2PC[kk].uniform(0,1)
		FIDp=fp_PC2PC[kk].normal(1.7,0.9)	//According to Thomson(2007)
	}

	//Create clustering connectivity lists for recurrent connections:
	for localID=0, PCcells.count()-1 {
		clusterDend[PCgids.x[localID]] = new Vector()
		clusterPID[PCgids.x[localID]] = new Vector()
		for syn=0, (PC2PC_MaxSyn-1) {
			PID = r_PC2PC[PCgids.x[localID]].repick()
			clusterDend[PCgids.x[localID]].append(0)
			//uniformly distribute synapses along basals:
			//PID = (1/PC2PC_MaxSyn)/2 + ((1/PC2PC_MaxSyn)*syn)
			//print " uniform spreaded synapse#",syn," is @ PID = ",PID
			clusterPID[PCgids.x[localID]].append(PID)
			//clusterPID[PCgids.x[i]].append(0.9)// SOS CHANGE PC2PC PID ALWAYS DISTALLY!
		}
	}

	for trg=0, nPCcells-1 { 
		trgGID = ind2gid(trg,0) //PC cells!
		if(PARALLEL){
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell
		}else{
			bool=1
			localID = trg
		}
		for src=0,nPCcells-1 {
			srcGID = ind2gid(src,0) //PC cells!
			//assert that no errors are made:
			assert( (C.nrow() > srcGID) && (C.ncol() > trgGID) )
			assert( (W.nrow() > srcGID) && (W.ncol() > trgGID) )
			if(C.x[srcGID][trgGID]){
				if(srcGID!=trgGID){
					if (bool) { 
						// GID exist in node, but is not registered in PCgids!
						if (localID < 0 ){ print "localID is missing from PCgids! ",localID }
						assert(localID >=0 )

						if(save_synaptic_delays){
							{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						if(save_synaptic_locations){
							{sprint(EXEC_CMD,"{pidPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						for syn=0, PC2PC_MaxSyn-1{
							PID = clusterPID[trgGID].x[syn]
							//PID = clustbias(PIDtmp,RN_PC2PC[trg].repick())
							FIDp = abs(fp_PC2PC[trg].repick())
							if( FIDp <= dt ){ FIDp = dt + 0.01 }
							if(save_synaptic_delays){
								{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",src,trg,FIDp)}
								{assert(execute1(EXEC_CMD))}
							}
							if(save_synaptic_locations){
								{sprint(EXEC_CMD,"{pidPC2PC[%d][%d].append(%f)}",src,trg,PID)}
								{assert(execute1(EXEC_CMD))}
							}
							PCcells.o(localID).dend[0] {ampaOnPC[src][trg][syn] = new GLU(PID)}					
							if(NO_MG){
								PCcells.o(localID).dend[0] {nmdaOnPC[src][trg][syn] = new nmda_nojump(PID)}					
							} else {
								PCcells.o(localID).dend[0] {nmdaOnPC[src][trg][syn] = new nmda_segev(PID)}					
							}

							nmdaOnPC[src][trg][syn].srcgid = srcGID
							nmdaOnPC[src][trg][syn].sid = syn
							nmdaOnPC[srcGID][trg][syn].cellid = trgGID
							nmdaOnPC[srcGID][trg][syn].tau1 = NMDATAU 
							//print "NMDATAU=",nmdaOnPC[srcGID][trg][syn].tau1 
							if(save_inmda){
								{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
								{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d].record(&nmdaOnPC[%d][%d][%d].inmda)}",src,trg,syn,src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
								{sprint(EXEC_CMD,"{iampaPC2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
								{sprint(EXEC_CMD,"{iampaPC2PC[%d][%d][%d].record(&ampaOnPC[%d][%d][%d].iglu)}",src,trg,syn,src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
if (0){//Save iNMDA for each cell separately:
								{sprint(EXEC_CMD,"{nmdaAPC2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
								{sprint(EXEC_CMD,"{nmdaAPC2PC[%d][%d][%d].record(&nmdaOnPC[%d][%d][%d].A)}",src,trg,syn,src,trg,syn)}
								{assert(execute1(EXEC_CMD))}
}
							}
							conampaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,ampaOnPC[src][trg][syn],-10,FIDp,ampaweight *  W.x[srcGID][trgGID] * EXCITBIAS * AMPABIAS)
							connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-10,FIDp,0.25  *  W.x[srcGID][trgGID] * EXCITBIAS * NMDABIAS)
						}
					}
				}
			}//connectivity matrix
		}
	}

	//---------------------------------------------------Insert Autapses(Lubke, 1996)
/*
	for localID=0, PCcells.count()-1 {
		//if (C.x[PCgids.x(i)][PCgids.x(i)]) { //If autapses are enabled..
			trg = PCgids.x[localID]
			src = PCgids.x[localID]
			assert( (src<nPCcells) && (trg<nPCcells) )
			if(save_synaptic_delays){
				{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",src,trg)}
				{assert(execute1(EXEC_CMD))}
			}
			if(save_synaptic_locations){
				{sprint(EXEC_CMD,"{pidPC2PC[%d][%d] = new Vector()}",src,trg)}
				{assert(execute1(EXEC_CMD))}
			}
			
			for syn=0, (PC_MaxAutosyn-1) { 
				PID=r_PC2PC[trg].repick()
				FIDp = abs(fp_PC2PC[trg].repick())
				//rDendidx = int(rDend_PC2PC[trg].uniform(0,PCcells.o(localID).DendNo-1) )
				rDendidx = 0
				if( FIDp <= dt ){ FIDp = dt + 0.01 }
				if(save_synaptic_delays){
					{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",src,trg,FIDp)}
					{assert(execute1(EXEC_CMD))}
				}
				if(save_synaptic_locations){
					{sprint(EXEC_CMD,"{pidPC2PC[%d][%d].append(%f)}",trg,trg,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				PCcells.o(localID).dend[rDendidx] {autoampaOnPC[trg][syn] = new GLU(PID)}
				PCcells.o(localID).dend[rDendidx] {autonmdaOnPC[trg][syn] = new nmda_segev(PID)}

				//conautoampaPC2PC[trg][syn] = makeSynapse(PCcells,localID,trg,autoampaOnPC[trg][syn], -10, FIDp,ampaweight)
				//conautonmdaPC2PC[trg][syn] = makeSynapse(PCcells,localID,trg,autonmdaOnPC[trg][syn], -10, FIDp,0.25)
			}
		//}
	}
*/
} //END procedure initPC


//---------------------------------------------PV-PV connections--------------------------------------------------------//
//PV-PV connections
objref gabaOnPV_A[nPVcells][nPVcells][PV2PV_MaxSyn]
objref congabaPV2PV_A[nPVcells][nPVcells][PV2PV_MaxSyn]

objref r_PV2PV[nPVcells],fp_PV2PV[nPVcells]
proc connectPV2PV() { local delstimpvpv,PID,src,trg,syn,bool,localID,trgGID,srcGID 
	//argument 1 is the animal model, argument 2 is the trial no, argument 3 is the learning condition	
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PV2PV[i] = new Random($1*$3 + 250 + i )
		fp_PV2PV[i] = new Random($1*$3 - 100 + i )
		PID = r_PV2PV[i].uniform(0,1)
		delstimpvpv = fp_PV2PV[i].normal(1.76,0.07) //latency from IN-IN, according to Bacci (2003)   
	}

	for src=0, nPVcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //NO NEED to account for PC overhead in matrix, gid are GLOBAL ID ;)
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					if (srcGID == trgGID) { //autapses
						for syn=0, 1-1 { //BACCI 2003
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-10,delstimpvpv,autogabaweight )
						}
					} else {
						for syn=0, (1-1) {//SSS Single synapse
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-10,delstimpvpv, gabaweightin)
						}
						
					}
				}
			}
		}
	}

} // End procedure initPV

//----------------------------------------------PC-PV connections-------------------------------------------------------//
//PC-PV connections
objref ampaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref nmdaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref conampaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref connmdaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]

objref r_PC2PV[nPVcells],fp_PC2PV[nPVcells]
proc connectPC2PV() { local delstimpcpv,PID,src,trg,syn,bool,localID,trgGID,srcGID 
	//argument 1 is the animal model, argument 2 is the trial no, argument 3 is the learning condition	
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PC2PV[i] = new Random($1*$3 + 150 + i )
		fp_PC2PV[i] = new Random($1*$3 * 2 + i)
		PID = r_PC2PV[i].uniform(0,1)
		delstimpcpv = fp_PC2PV[i].normal(0.6, 0.2)		//latency from Pc-In, according to Thomson(2007), also Angulo,Audinat(1999) 
	}

	for src=0, nPCcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,0) //PC cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					// Markram2004: 60% basal, 30% a pical, 10% soma.
					for syn=0, (PC2PV_MaxSyn-1) {
						PID = r_PC2PV[PVgids.x[localID]-nPCcells].repick ()
						//BIAS : Proximal to the soma:
						PID = 0.01
						delstimpcpv=abs(fp_PC2PV[PVgids.x[localID]-nPCcells].repick())
						if(delstimpcpv<=dt){delstimpcpv=dt+0.01}
						PVcells.o(localID).dend {ampaOnPV[src][trg][syn] = new GLUIN(PID)} //no Dends available in the model! (???????)
						PVcells.o(localID).dend {nmdaOnPV[src][trg][syn] = new NMDA(PID)}
						conampaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, ampaOnPV[src][trg][syn], 0, delstimpcpv, W.x[srcGID][trgGID] * ampaweightin)
						connmdaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, nmdaOnPV[src][trg][syn], 0, delstimpcpv, W.x[srcGID][trgGID] * nmdaweightin)    
					}
				}
			}
		}
	}
} //end procedure initPC2PV

// Create vectors to record GABA synaptic current per target:
//objref syncurrGABAa[nPVcells][nPCcells][PV2PC_MaxSyn], syncurrGABAb[nPVcells][nPCcells][PV2PC_MaxSyn]
if(save_pvsynaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPV2PC[%d][%d]}",nPVcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_pvsynaptic_locations){
	{sprint(EXEC_CMD,"{objref pidPV2PC[%d][%d]}",nPVcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
//------------------------------------------------PV-PC connections-----------------------------------------------------//
objref gabaOnPC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref gabaOnPC_B[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_B[nPVcells][nPCcells][PV2PC_MaxSyn]

objref r_PV2PC[nPCcells],fp_PV2PC[nPCcells]
proc connectPV2PC() {local delstimpvpc,PID,src,trg,syn,bool,localID,trgGID,srcGID,a,b,c,dend_weight 
	//argument 1 is the animal model, argument 2 is the trial no, argument 3 is the learning condition	
// Connect as in Functional effects of distinct innervation styles of pyramidal cells by fast spiking cortical interneurons.
// Use fewer (half) synapses for computational efficiency. So One at the soma and three at the dendrite.
// 1/3 of the synapses at the soma, with dendritic ones  been weakier (*0.33).
// Average current at the soma must be ~ 20pA (Figure 2E)
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPCcells-1 {
		r_PV2PC[i] = new Random($1*$3 + 180 + i + TRIAL )
		fp_PV2PC[i] = new Random($1*$3 * 8 + i+ TRIAL)
		PID = r_PV2PC[i].uniform(0,1)
		delstimpvpc=fp_PV2PC[i].normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	}

	//This weight corresponds to the conductance in uS of a charge 61.4615fC as in Kubota et al. 2015 eLife.
	soma_weight = 3.6234e-04 // mean somatic conductance  in uS, (0.36 nS as in Kubota).
	//-----------------------------Connect
	for src=0, nPVcells-1 {
		for trg=0,nPCcells-1 {
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PCgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					//----------------------------Insert synapses at soma
					if(save_pvsynaptic_delays){
						{sprint(EXEC_CMD,"{delayPV2PC[%d][%d] = new Vector()}",src,trg)}
						{assert(execute1(EXEC_CMD))}
					}
					if(save_pvsynaptic_locations){
						{sprint(EXEC_CMD,"{pidPV2PC[%d][%d] = new Vector()}",src,trg)}
						{assert(execute1(EXEC_CMD))}
					}
					for syn=0,3-1 { 
						PID = 0.5 //bias MCMC
						if(save_pvsynaptic_locations){
							{sprint(EXEC_CMD,"{pidPV2PC[%d][%d].append(%f)}",src,trg,PID)}
							{assert(execute1(EXEC_CMD))}
						}
						PCcells.o(localID).soma gabaOnPC_A[src][trg][syn] = new GABAa(PID) //carefull not to overwrite array!
						PCcells.o(localID).soma gabaOnPC_B[src][trg][syn] = new GABAb(PID)
						gabaOnPC_A[src][trg][syn].cellid = trgGID
						gabaOnPC_A[src][trg][syn].srcgid = srcGID
						gabaOnPC_A[src][trg][syn].sid = syn

						delstimpvpc=abs(fp_PV2PC[PCgids.x[localID]].repick())
						if(delstimpvpc<=dt){delstimpvpc=dt+0.01}
						if(save_pvsynaptic_delays){
							{sprint(EXEC_CMD,"{delayPV2PC[%d][%d].append(%f)}",src,trg,delstimpvpc)}
							{assert(execute1(EXEC_CMD))}
						}
						if(save_igaba){
							{sprint(EXEC_CMD,"{igabaaPV2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igabaaPV2PC[%d][%d][%d].record(&gabaOnPC_A[%d][%d][%d].g)}",src,trg,syn,src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igababPV2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igababPV2PC[%d][%d][%d].record(&gabaOnPC_B[%d][%d][%d].g)}",src,trg,syn,src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
						}
						congabaPV2PC_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_A[src][trg][syn], -10, delstimpvpc, W.x[srcGID][trgGID] * soma_weight * gabaweight_pv2pc_a*INHIBIAS) 
						congabaPV2PC_B[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_B[src][trg][syn], -10, delstimpvpc, W.x[srcGID][trgGID] * soma_weight * gabaweight_pv2pc_b*INHIBIAS)
					}
					//----------------------------Insert synapses at dendrites
					for syn=3,PV2PC_MaxSyn-1 { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						if(save_pvsynaptic_locations){
							{sprint(EXEC_CMD,"{pidPV2PC[%d][%d].append(%f)}",src,trg,PID)}
							{assert(execute1(EXEC_CMD))}
						}
						PCcells.o(localID).dend[0] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
						PCcells.o(localID).dend[0] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
						gabaOnPC_A[src][trg][syn].cellid = trgGID
						gabaOnPC_A[src][trg][syn].srcgid = srcGID
						gabaOnPC_A[src][trg][syn].sid = syn
						delstimpvpc=abs(fp_PV2PC[PCgids.x[localID]].repick())
						// Calculated weight based on fitted values:
						// These values are WRONG Don't remember where I got them from:
						//a=-7.50259257e+01
						//b= 6.42232615e-04
						//c= 7.53522217e+01
						a = -0.11811557
						b = 0.1926853
						c = 0.39375158
						// Aftes oi times antistoixoun se average current 6 pA kai max current 7.3pA.
						dend_weight = (c + (PCcells.o(localID).dend[0].L*PID)^b * a) / 1000 // convert to uS
						if(delstimpvpc<=dt){delstimpvpc=dt+0.01}
						if(save_pvsynaptic_delays){
							{sprint(EXEC_CMD,"{delayPV2PC[%d][%d].append(%f)}",src,trg,delstimpvpc)}
							{assert(execute1(EXEC_CMD))}
						}
						if(save_igaba){
							{sprint(EXEC_CMD,"{igabaaPV2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igabaaPV2PC[%d][%d][%d].record(&gabaOnPC_A[%d][%d][%d].i)}",src,trg,syn,src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igababPV2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
							{sprint(EXEC_CMD,"{igababPV2PC[%d][%d][%d].record(&gabaOnPC_B[%d][%d][%d].i)}",src,trg,syn,src,trg,syn)}
							{assert(execute1(EXEC_CMD))}
						}
						congabaPV2PC_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_A[src][trg][syn], -10, delstimpvpc, W.x[srcGID][trgGID] * gabaweight_pv2pc_a*dend_weight*INHIBIAS) 
						congabaPV2PC_B[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_B[src][trg][syn], -10, delstimpvpc, W.x[srcGID][trgGID] * gabaweight_pv2pc_b*dend_weight*INHIBIAS)
					}
				}
			}
		}
	}
}  //end procedure initPV2PC




