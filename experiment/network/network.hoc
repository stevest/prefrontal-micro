//Based on Durstewitz and Gabriel 2006, "Irregular spiking in NMDA-driven prefrontal cortex neurons"
//Written 18-04-08, modified 29/07/09
//xopen ("pfc_pc_temp.hoc") //load template for pyramidal cells
//xopen ("incell.hoc")      //load template for interneuron

//----------------------------Insert variables to be used for stimulations and connections-----------------------------//
//--------------------Insert variable for random placement of synapses and delays in the connections
objref r, f, fin, fpin, finp, fp, stimrand
objref all_msec
all_msec = new Vector(n,0)
for q=0,n-1 {all_msec.x[q]=q*dt }

//---- Section Reference Variables----//
BDendsNo = 18
objref SectionArray[nPCcells][BDendsNo]
objref auxilist_basal[nPCcells] 
for lala=0, (nPCcells-1) {
	auxilist_basal[lala] = new List()
}
objref random_basal[nPCcells]
                    for gaga=0, (nPCcells-1) {
                    	random_basal[gaga] = new SectionList()
                    }
objref rnd, distancesMat, pidMat
distancesMat = new Matrix(nPCcells,(PC2PC_MaxSyn+2)*nPCcells)
pidMat = new Matrix(nPCcells,(PC2PC_MaxSyn+2)*nPCcells)


//-----------------------Stimulations
objref ncAMPA[nPCcells][Stim_MaxSyn], nsNMDA[nPCcells][Stim_MaxSyn],nsAMPA[nPCcells][Stim_MaxSyn], ncNMDA[nPCcells][Stim_MaxSyn], ampapr[nPCcells][Stim_MaxSyn], nmdapr[nPCcells][Stim_MaxSyn]
objref vstim_stim[nPCcells][Stim_MaxSyn]

//PC-PC connections
//autosynapses
objref autoampaOnPC[nPCcells][PC_MaxAutosyn]
objref autonmdaOnPC[nPCcells][PC_MaxAutosyn]
objref conautoampaPC2PC[nPCcells][PC_MaxAutosyn]
objref conautonmdaPC2PC[nPCcells][PC_MaxAutosyn]
//recurrent synapses
objref ampaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref nmdaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref conampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref connmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]


//PV-PV connections
objref gabaOnPV_A[nPVcells][nPVcells][PV2PV_MaxSyn]
objref congabaPV2PV_A[nPVcells][nPVcells][PV2PV_MaxSyn]

//PC-PV connections
objref ampaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref nmdaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref conampaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref connmdaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]


//--------------------PV-PC connections
objref gabaOnPC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref gabaOnPC_B[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_B[nPVcells][nPCcells][PV2PC_MaxSyn]

//--------------------PV background
objref ampaBGPV[nPVcells][BG_PVSyn]
objref nmdaBGPV[nPVcells][BG_PVSyn]
objref BGPV_NMDA[nPVcells][BG_PVSyn]
objref BGPV_AMPA[nPVcells][BG_PVSyn]

// others
objref PCns, PVns, CBns, CRns
objref PCsw, PVsw, CBsw, CRsw


//--------------------Background activity 
objref vstimd[nPCcells][BG_dendSyn]
objref vstima[nPCcells][BG_apicSyn]
objref vstimp[nPCcells][BG_apicprSyn]
objref ampaBGd[nPCcells][BG_dendSyn]
objref nmdaBGd[nPCcells][BG_dendSyn]
objref ampaBGp[nPCcells][BG_apicprSyn]
objref nmdaBGp[nPCcells][BG_apicprSyn]
objref ampaBGa[nPCcells][BG_apicSyn]
objref nmdaBGa[nPCcells][BG_apicSyn]

objref BG_AMPAd[nPCcells][BG_dendSyn]
objref BG_NMDAd[nPCcells][BG_dendSyn]
objref BG_AMPAa[nPCcells][BG_apicSyn]
objref BG_NMDAa[nPCcells][BG_apicSyn]
objref BG_AMPAp[nPCcells][BG_apicprSyn]
objref BG_NMDAp[nPCcells][BG_apicprSyn]

// Record events artificial neurons:
/*
objref ERvectors[nPCcells]
objref ERneurons[nPCcells]
proc events_recorder() {
	if (PC.id == 0) {
		for k=0, nPCcells-1 {
			ERvectors[k] = new Vector()
			ERneurons[k] = new ERneuron()
			ERneurons[k].recordto(ERvectors[k])
		}
	}
}
*/

//----------------------------------------------Insert noise-----------------------------------------------------------//
//INSERT MOD FILE FOR SINE WAVE
objref PCns[nPCcells], PVns[nPCcells], CBns[nPCcells], CRns[nPCcells]
objref PCsw[nPCcells], PVsw[nPCcells], CBsw[nPCcells], CRsw[nPCcells]

proc noise() { local i,GID
	i=0
	forsec PCsoma_list {
			GID = PCgids.x(i)
			PCns[i] = new Random(GID+(nPCcells*$1)*SNd) 
			PCns[i].poisson(0.5)	//was (0.02)	
			PCsw[i] = new membNoise(0.5)
			PCsw[i].dur = tstop //duration of injection
			PCsw[i].freq = 100//180 //80 //how many sinusoidals in a second
			PCsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PCsw[i].getRandObjPtr(PCns[i])
			i = i +1
	}

	i=0
	forsec PVsoma_list {
			GID = PVgids.x(i)
			PVns[i] = new Random(GID+(nPVcells*$1)*SNd) 
			PVns[i].poisson(0.5)	//was (0.02)	
			PVsw[i] = new membNoise(0.5)
			PVsw[i].dur=tstop //duration of injection
			PVsw[i].freq = 100 //180 //how many sinusoidals in a second
			PVsw[i].pkampMax = 0.2 //(nA) injected current amplitude 
			PVsw[i].getRandObjPtr(PVns[i])
			i = i +1
	}
}
//Gap junctions code:
objref par_gaps
par_gaps = new List()
gap_src_gid = 2

/*objref rangap
if (one_tenth_ncell) {
	rangap = new Random()
	rangap.MCellRan4(1)
	rangap.uniform(0,1)
	ranfrac=.1
}*/

proc par_gap_create() { local srcgid , trggid, src
	srcgid = $1
	trggid = $3	
	src = $2
	par_gap_create1(srcgid, trggid, $3)
	/*if (!use_gap) { return }
	if (object_id(rangap)) {
		if (rangap.repick() > ranfrac) { return }
	}
	gap_src_gid += 2
	if ((gid = targetcomp_exists($1, $2)) >= 0) {
		par_gap_create1(gid, $2, gap_src_gid + 1, gap_src_gid, $5)
	}
	if ((gid = targetcomp_exists($3, $4)) >= 0) {
		par_gap_create1(gid, $4, gap_src_gid, gap_src_gid + 1, $5)
	}*/
}
proc par_gap_create_now() {localobj c, g
	c =PC.gid2obj($1)
	c.soma {
		g = new gGapPar(.5)
		par_gaps.append(g)
		PC.target_var(g, &g.vgap, $3)
		PC.source_var(&v(.5), $2)
		g.g = $4 }
}

//---------------------------Initial stimulation (proximal dendrite)(Kuroda, 1998, Constantinides, 2001)---------------//
//Had issues with parallel execution of NetStim. Lets hope that his gets executed 
// for all the stimulated cells.
//Particularly the NetStim will be created and connected with netcon, but no activity will follow!
//Still havent came to a conclusion about the erroneus behaviour or any fix, appart from 
// instantiating NetStim outside any proc!
objref sns
sns  = new NetStim(0.5)
sns.interval=20//14.28//12.5//SSS 
sns.number=50//70//80//SSS
sns.start=0
sns.noise=0.2
strdef EXEC_CMD
//The only way to have conditional execution without parser errors
//is to have the commands executed on runtime. Else parser will complain
//about missing variables.
if(save_stimulation_locations){
	{sprint(EXEC_CMD,"{objref stimpidPC2PC[%d]}",nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
objref r_stimPC[nPCcells], rApic_stimPC[nPCcells], rBasal_stimPC[nPCcells] 
objref stim_artcell[nPCcells*Stim_MaxSyn_apic]
objref STIMgids, STIMcells
//keep the GIDs of the stimulation artificial cells
//ALL NetStim artificial cells MUST lie in node 0!
STIMgids = new Vector()
STIMcells = new List()
proc stimulation() { local trg,syn,PID,ApicalNo,rApicIdx,BasalNo,rBasalIdx, interval, number,localID,tmp,ridx,trgGID,artgid  localobj r,rApic,rBasal,ri,rvect,mynil,artcell
	if(PARALLEL){ PC.barrier() }
	//Configure RNG for reproducability over differently distributed parallel environments:
	for kk=0,nPCcells-1{
		r_stimPC[kk] = new Random(SNd*$1 + 165 + kk )
		rApic_stimPC[kk] = new Random(SNd*$1 + 12 + kk)
		rBasal_stimPC[kk] = new Random(SNd*$1 + 67 + kk)
		PID = r_stimPC[kk].uniform(0,1)
	}
	for trg=0, nPCcells-1 {
		if(PARALLEL){
			bool = (PC.id==0)
		}else{
			bool=1
		}
		if (bool) { 
			for syn=0, (Stim_MaxSyn_apic-1) {
				artcell = new NetStim()
				artcell.interval = 20
				artcell.number = 50
				artcell.start = 0
				artcell.noise = 0.2
				//artificial cell gids:
				//MAKE SURE NO GIDS ARE THE SAME!
				artgid = trg + syn*nPCcells + nPCcells + nPVcells 
				//associate artgid with current node (first node):
				PC.set_gid2node(artgid,PC.id)
				//print "Associating artgid=",artgid," with PC.id=",PC.id
				//associate ARTIFICIAL_CELL output to artgid:
				PC.cell(artgid,new NetCon(artcell, mynil),1)
				STIMcells.append(artcell)
			}
		}
	}

	for trg=0, nPCcells - 1  { 
		if(PcellStimList.x(trg)){
			trgGID = ind2gid(trg,0) //ONLY FOR PC CELLS!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PCgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}

			if( bool ){ //&& PcellStimList.x(trg)
				if(save_stimulation_locations){
					{sprint(EXEC_CMD,"{stimpidPC2PC[%d] = new Vector()}",trgGID)}
					{assert(execute1(EXEC_CMD))}
				}
		print "@=",PC.id," stimulating pyramidal=",trgGID
				// Apical input:
				for syn=0, (Stim_MaxSyn_apic-1) {
					PID=r_stimPC[trg].repick()
					rApicIdx = int(rApic_stimPC[trg].uniform(0,PCcells.o(localID).ApicNo-1))
					if(save_stimulation_locations){
						{sprint(EXEC_CMD,"{stimpidPC2PC[%d].append(%f)}",trgGID,PID)}
						{assert(execute1(EXEC_CMD))}
					}
					rApicIdx = 0 //PROXIMAL!
					PCcells.o(localID).apic[rApicIdx] {ampapr[trg][syn] = new GLU(PID)}
					PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn] = new nmda_segev(PID)}
					PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn].mybeta = 0.0}
					PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn].cellid = trgGID}

					artgid = trg + syn*nPCcells + nPCcells + nPVcells 

					ncAMPA[trg][syn] = makeSynapse(PCcells,0,artgid,ampapr[trg][syn],-10,1000,ampaweight_stimulus)
					ncNMDA[trg][syn] = makeSynapse(PCcells,0,artgid,nmdapr[trg][syn],-10,1000,nmdaweight_stimulus)
/*
					ncAMPA[trg][syn] = new NetCon(sns, ampapr[trg][syn]) //vstim_stim[trg][syn]
					ncAMPA[trg][syn].delay=1000
					ncAMPA[trg][syn].weight = ampaweight_stimulus// *15//SSS
					ncAMPA[trg][syn].threshold=-10 

					ncNMDA[trg][syn] = new NetCon(sns, nmdapr[trg][syn])
					ncNMDA[trg][syn].delay=1000
					ncNMDA[trg][syn].weight = nmdaweight_stimulus// *15//SSS
					ncNMDA[trg][syn].threshold=-10
*/
				}

			} //if bool
		} //if stimulated
	} //for PC cells
} //end proc

objref bgrecvec
strdef bgrecvec_filename
AllBGsyns = BG_dendSyn+BG_apicSyn+BG_apicprSyn+BG_PVSyn
objref bns[AllBGsyns], psn[AllBGsyns]
for k = 0, AllBGsyns-1 {
	psn[k] = new Random(SNd*PC.id*AllBGsyns+k)
	psn[k].poisson(0.002)
	bns[k]  = new poissonStim(0.5)
	bns[k].interval=1//SSS 
	bns[k].number=tstop//SSS
	bns[k].start=0
	bns[k].noise=1
	bns[k].noiseFromRandom(psn[k])
}

objref rUniform_dend[nPCcells*BG_dendSyn], rPoisson_dend[nPCcells*BG_dendSyn]
objref rUniform_apic[nPCcells*BG_apicSyn], rPoisson_apic[nPCcells*BG_apicSyn]
objref rUniform_apicpr[nPCcells*BG_apicprSyn], rPoisson_apicpr[nPCcells*BG_apicprSyn]
objref nhPoissonStim_dend[nPCcells*BG_dendSyn]
objref nhPoissonStim_apic[nPCcells*BG_apicSyn]
objref nhPoissonStim_apicpr[nPCcells*BG_apicprSyn]
objref rateVect
objref netstim_dend[nPCcells*BG_dendSyn]

if(save_background_locations){
	//which PID in which dendrite (basal, apical, apical pr)
	{sprint(EXEC_CMD,"{objref bgstimpid[%d][%d]}",3,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}

if(save_bg_iampa){
	{sprint(EXEC_CMD,"{objref bg_iampa[%d][%d]}",nPCcells,BG_dendSyn)}
	{assert(execute1(EXEC_CMD))}
}
objref ns1
ns1=new NetStim()
ns1.interval=10
ns1.number=40
ns1.start=0
ns1.noise=0
//myr = new Random(0)
//myr.normal(0, 0.3)
proc backgroundActivity() { local artgid,trg,syn_dend, syn_apic,syn_apicpr,PID,RV,RLB,RLA,localID,trgGID,StimDur,StimFreq,StimNo,SynapsesNo localobj mynil,r,rv,rlb,rla
	r = new Random(SNd*$1 + 300 + PC.id)
	rv = new Random(SNd*$1 +400)
	RV = rv.uniform(1, StimDur)
	PID = r.uniform(0,1)
	rlb = new Random(SNd*$1+160)
	rla = new Random(SNd*$1+560)

	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{xopen(\"%sRateVectors/rateVect_%03d.hoc\")}",SIMGLIA,$1)}
	{assert(execute1(EXEC_CMD))}
	lambdaMax = rateVect.max() 

	for trg=0, nPCcells-1 {
		if(PARALLEL){
			bool = (PC.id==0)
		}else{
			bool=1
		}
		if (bool) { 
			for syn_dend=0, (BG_dendSyn-1) {
				rUniform_dend[trg + (nPCcells*syn_dend)] = new Random(trg + (nPCcells*syn_dend))
				rUniform_dend[trg + (nPCcells*syn_dend)].uniform(0,1)
				rPoisson_dend[trg + (nPCcells*syn_dend)] = new Random(trg + (nPCcells*syn_dend))
				rPoisson_dend[trg + (nPCcells*syn_dend)].poisson(lambdaMax)
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)] = new NonHomPoissonStim()
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].cellid = trg
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].synid = syn_dend 
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].getRandObjPtrUniform(rUniform_dend[trg + (nPCcells*syn_dend)])
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].getRandObjPtrPoisson(rPoisson_dend[trg + (nPCcells*syn_dend)])
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].lambdaMax = lambdaMax 
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].play(rateVect)

				//artificial cell gids:
				artgid = nPCcells+nPVcells+(nPCcells*Stim_MaxSyn_apic) + trg + (nPCcells*syn_dend)
				//associate artgid with current node:
				PC.set_gid2node(artgid,PC.id)
				//print "Associating artgid=",artgid," with PC.id=",PC.id
				//associate ARTIFICIAL_CELL output to artgid:
				PC.cell(artgid,new NetCon(nhPoissonStim_dend[trg + (nPCcells*syn_dend)], mynil),1)
			}
		}
	}

	if(PARALLEL){PC.barrier()}

	for trg=0, nPCcells-1 {
		if(PARALLEL){
			trgGID = ind2gid(trg,0) //ONLY FOR PC CELLS!
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell	
		}else{
			bool=1
			localID = trg
		}

		if(bool){
			RLB = rlb.uniform(0,PCcells.o(localID).DendNo-1)
			RLA = rla.uniform(0,PCcells.o(localID).ApicNo-1)

			if(save_background_locations){
				{sprint(EXEC_CMD,"{bgstimpid[0][%d] = new Vector()}",trgGID)}
				{assert(execute1(EXEC_CMD))}
				{sprint(EXEC_CMD,"{bgstimpid[1][%d] = new Vector()}",trgGID)}
				{assert(execute1(EXEC_CMD))}
				{sprint(EXEC_CMD,"{bgstimpid[2][%d] = new Vector()}",trgGID)}
				{assert(execute1(EXEC_CMD))}
			}

			RLB = 0 // Basals!!
			for syn_dend=0, BG_dendSyn-1 {
				PID = r.repick()
				if(save_background_locations){
					{sprint(EXEC_CMD,"{bgstimpid[0][%d].append(%f)}",trgGID,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				PCcells.o(localID).dend {ampaBGd[trg][syn_dend]=new GLU(PID)}
				PCcells.o(localID).dend {nmdaBGd[trg][syn_dend]=new nmda_segev(PID)}

				//artgid = nAllCells + trg + (nPCcells*syn_dend)
				artgid = nPCcells+nPVcells+(nPCcells*Stim_MaxSyn_apic) + trg + (nPCcells*syn_dend)
				BG_AMPAd[trg][syn_dend] = makeSynapse(PCcells,0,artgid,ampaBGd[trg][syn_dend],-10,1,bg_ampa_weight_d)
				BG_NMDAd[trg][syn_dend] = makeSynapse(PCcells,0,artgid,nmdaBGd[trg][syn_dend],-10,1,bg_nmda_weight_d)
//print "@=",PC.id," trgGID=",trgGID," Even if delcared above, ns1 is: ",object_id(ns1)," and interval is: ",ns1.interval
				//BG_AMPAd[trg][syn_dend] = new NetCon(ns1, ampaBGd[trg][syn_dend],-10,1,bg_ampa_weight_d)
				//BG_NMDAd[trg][syn_dend] = new NetCon(ns1, nmdaBGd[trg][syn_dend],-10,1,bg_nmda_weight_d)

				if(save_bg_iampa){
						{sprint(EXEC_CMD,"{bg_iampa[%d][%d] = new Vector()}",trg,syn_dend)}
						{assert(execute1(EXEC_CMD))}
						{sprint(EXEC_CMD,"{bg_iampa[%d][%d].record(&ampaBGd[%d][%d].iglu)}",trg,syn_dend,trg,syn_dend)}
						{assert(execute1(EXEC_CMD))}
				}
			}

			for syn_apicpr=0, BG_apicprSyn-1 {
				RLA = 0 //proximal!!
				PID = r.repick()
				if(save_background_locations){
					{sprint(EXEC_CMD,"{bgstimpid[1][%d].append(%f)}",trgGID,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				PCcells.o(localID).apic[RLA] ampaBGp[trg][syn_apicpr]=new GLU(PID)
				PCcells.o(localID).apic[RLA] nmdaBGp[trg][syn_apicpr]=new nmda_segev(PID)

				//artgid = nAllCells + trg + (nPCcells*syn_apicpr)
				artgid = nPCcells+nPVcells+(nPCcells*Stim_MaxSyn_apic)+(nPCcells*BG_dendSyn) + trg + (nPCcells*syn_apicpr)
				BG_AMPAp[trg][syn_apicpr] = makeSynapse(PCcells,0,artgid,ampaBGp[trg][syn_apicpr],-10,1,bg_ampa_weight_pr)
				BG_NMDAp[trg][syn_apicpr] = makeSynapse(PCcells,0,artgid,nmdaBGp[trg][syn_apicpr],-10,1,bg_nmda_weight_pr)

			}

			RLA = 1 //distal!!
			for syn_apic=0, BG_apicSyn-1 {
				PID = r.repick()
				if(save_background_locations){
					{sprint(EXEC_CMD,"{bgstimpid[2][%d].append(%f)}",trgGID,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				PCcells.o(localID).apic[RLA] ampaBGa[trg][syn_apic]=new GLU(PID)
				PCcells.o(localID).apic[RLA] nmdaBGa[trg][syn_apic]=new nmda_segev(PID)

				//artgid = nAllCells + trg + (nPCcells*syn_apic)
				artgid = nPCcells+nPVcells+(nPCcells*Stim_MaxSyn_apic)+(nPCcells*BG_dendSyn)+(nPCcells*BG_apicprSyn) + trg + (nPCcells*syn_apic)
				BG_AMPAa[trg][syn_apic] = makeSynapse(PCcells,0,artgid,ampaBGa[trg][syn_apic],-10,1,bg_ampa_weight_a)
				BG_NMDAa[trg][syn_apic] = makeSynapse(PCcells,0,artgid,nmdaBGa[trg][syn_apic],-10,1,bg_nmda_weight_a)

			}
		}//end bool
	}
}//end proc


objref pvns
pvns  = new NetStim(0.5)
pvns.number=40//SSS
pvns.interval=tstop/pvns.number//SSS 
pvns.start=0
pvns.noise=1

objref rUniformPV[nPVcells*BG_PVSyn], rPoissonPV[nPVcells*BG_PVSyn]
objref nhPoissonStimPV[nPVcells*BG_PVSyn]
objref netstim_dendpv[nPVcells*BG_PVSyn]
//----------------------------------------------PV background activity-------------------------------------------------------//
proc backgroundActivityPV() { local artgid,PID,trg,syn,bool,localID,trgGID localobj mynil,r
	if(PARALLEL){ PC.barrier() }
	r = new Random(SNd*$1 + 150)
	PID = r.uniform(0,1)

	// Create NonHomogenousPoisson stimulus only in node 0:
	for trg=0, nPVcells-1 {
		if(PARALLEL){
			bool = (PC.id==0)
		}else{
			bool=1
		}
		if (bool) { 
			EXEC_CMD = ""
			{sprint(EXEC_CMD,"{xopen(\"%sRateVectors/rateVect_%03d.hoc\")}",SIMGLIA,$1)}
			{assert(execute1(EXEC_CMD))}
			lambdaMax = rateVect.max() 
			for syn=0, (BG_PVSyn-1) {
				rUniformPV[trg + (nPVcells*syn)] = new Random(trg + (nPVcells*syn))
				rUniformPV[trg + (nPVcells*syn)].uniform(0,1)
				rPoissonPV[trg + (nPVcells*syn)] = new Random(trg + (nPVcells*syn))
				rPoissonPV[trg + (nPVcells*syn)].poisson(lambdaMax)
				nhPoissonStimPV[trg + (nPVcells*syn)] = new NonHomPoissonStim()
				nhPoissonStimPV[trg + (nPVcells*syn)].cellid = trg+nPCcells 
				nhPoissonStimPV[trg + (nPVcells*syn)].synid = syn 
				nhPoissonStimPV[trg + (nPVcells*syn)].getRandObjPtrUniform(rUniformPV[trg + (nPVcells*syn)])
				nhPoissonStimPV[trg + (nPVcells*syn)].getRandObjPtrPoisson(rPoissonPV[trg + (nPVcells*syn)])
				nhPoissonStimPV[trg + (nPVcells*syn)].lambdaMax = lambdaMax 
				nhPoissonStimPV[trg + (nPVcells*syn)].play(rateVect)

				//artificial cell gids:
				artgid = nAllCells + nPCcells*(BG_dendSyn+BG_apicSyn+BG_apicprSyn) + trg + (nPVcells*syn)
				//associate artgid with current node:
				PC.set_gid2node(artgid,PC.id)
				//print "Associating artgid=",artgid," with PC.id=",PC.id
				//associate ARTIFICIAL_CELL output to artgid:
				PC.cell(artgid,new NetCon(nhPoissonStimPV[trg + (nPVcells*syn)], mynil),1)

			}
		}
	}
	//Wait for association to finish:
	if(PARALLEL){PC.barrier()}

	for trg=0, nPVcells-1 {
		if(PARALLEL){
			trgGID = ind2gid(trg,1) //PV cells!
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PVgids,trgGID) //target cell
		}else{
			bool=1
			localID = trg
		}
		if (bool) { 
			for syn=0, (BG_PVSyn-1) {
				PID = r.repick()
				PVcells.o(localID).dend ampaBGPV[trg][syn] = new GLUIN(PID) //no Dends available in the model! (???????)
				PVcells.o(localID).dend nmdaBGPV[trg][syn] = new NMDA(PID)
	
				artgid = nAllCells + nPCcells*(BG_dendSyn+BG_apicSyn+BG_apicprSyn) + trg + (nPVcells*syn)
				BGPV_AMPA[trg][syn] = makeSynapse(PVcells,0,artgid,ampaBGPV[trg][syn],-10,1,ampaweightin)
				BGPV_NMDA[trg][syn] = makeSynapse(PVcells,0,artgid,nmdaBGPV[trg][syn],-10,1,nmdaweightin)
			}
		}

	}
} //end procedure 

// recurrent synaptic clusternig algorithm (for variation)
func clustbias(){ local rb,oldPID localobj rbo
	//arguments (many!)
	//$1 = PID old
	//$2 = runs serial number
	oldPID = $1
	//rbo = new Random(SNd*$2+PC.id)
	rb = $2//rbo.uniform(0,1)
	//this function may be implemented weird: the (default/old) PID is clustering synapses in the same point on a specific dend,
	//the new PID is deviating from clustering synapses by a random amount with weight 1-CLUSTBIAS.
	//So, smaller values of CLUSTBIAS mean more deviation from clustering the synapses.
	//when CLUSTBIAS==0: new PID == Random(0,1) (non clustered synapses)
	//when CLUSTBIAS==1: new PID == old PID (clustered synapses - default)

	return ((rb-oldPID)* (1-CLUSTBIAS)) + oldPID 
}

// ---------------------------------PC-PC connections, basal dendrite(Thomson, 1997)------------------------------------//

objref clusterDend[nPCcells], clusterPID[nPCcells], clusterDIST
for i=0,nPCcells-1{
	clusterDend[i] = new Vector()
	clusterPID[i] = new Vector()
}
clusterPID = new Vector()
clusterDIST = new Vector(nPCcells)
objref Devents[nPCcells]
strdef temp
objref PIDfile, FIDfile
//objref arrFID[nPCcells][nPCcells][PC2PC_MaxSyn]
//objref arrPID[nPCcells][nPCcells][PC2PC_MaxSyn]
objref dummyNetCon[nPCcells]
if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_synaptic_locations){
	{sprint(EXEC_CMD,"{objref pidPC2PC[%d][%d]}",nPCcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
if(save_inmda){
	{sprint(EXEC_CMD,"{objref inmdaPC2PC[%d][%d][%d]}",nPCcells,nPCcells,PC2PC_MaxSyn)}
	{assert(execute1(EXEC_CMD))}
}
/*objref curnmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref curampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref icaPC2PC[nPCcells]
objref caiPC2PC[nPCcells]
*/
objref RN_PC2PC[nPCcells],r_PC2PC[nPCcells],fp_PC2PC[nPCcells],rDend_PC2PC[nPCcells]
proc connectPC2PC() { local i,j,FIDp,PID,BasalNo,rDendidx,synCtr,trg,src,syn,bool,localID,trgGID,srcGID,localNMDAweight,arg,rn localobj null
	arg = $3
	if(PARALLEL){ PC.barrier() }
	
	//set parallel PID randomness
	for kk=0,nPCcells-1{
		r_PC2PC[kk] = new Random(SNd*$1 + 350 + kk ) //ta palia runs (10/8 kai prin) den eixan to PC.id!!
		RN_PC2PC[kk] = new Random(SNd*$1 + 360 + kk)
		fp_PC2PC[kk] = new Random(SNd*$1 + 3 + kk)	
		rDend_PC2PC[kk] = new Random(SNd*$1 + 4 + kk) 
		rn = RN_PC2PC[kk].uniform(0,1)
		PID = r_PC2PC[kk].uniform(0,1)
		FIDp=fp_PC2PC[kk].normal(1.7,0.9)	//According to Thomson(2007)
	}

	//rDend = new Random($1+4 + PC.id ) //ta palia runs (10/8 kai prin) den eixan to PC.id!!
	//rDend = new Random(SNd*$1+4) //ta palia runs (10/8 kai prin) den eixan to PC.id!!

	//Create clustering connectivity lists for recurrent connections:
	for i=0, PCcells.count()-1 {
		//i=0
		for syn=0, (PC2PC_MaxSyn-1) {
			PID = r_PC2PC[PCgids.x[i]].repick()
			//PID = VARPID //bias MCMC
			rDendidx = int(rDend_PC2PC[PCgids.x[i]].uniform(0,PCcells.o(i).DendNo-1) )
			clusterDend[PCgids.x[i]].append(rDendidx)
			//uniformly distribute synapses along basals:
			//PID = (1/PC2PC_MaxSyn)/2 + ((1/PC2PC_MaxSyn)*syn)
			//print " uniform spreaded synapse#",syn," is @ PID = ",PID
			clusterPID[PCgids.x[i]].append(PID)
		}
		//PID=r.repick()
	}

	for trg=0, nPCcells-1 {
		for src=0, nPCcells-1 {
			for syn=0, PC2PC_MaxSyn-1 {
				connmdaPC2PC[src][trg][syn] = null
				conampaPC2PC[src][trg][syn] = null
				nmdaOnPC[src][trg][syn] = null
				ampaOnPC[trg][src][syn] = null
			}
		}
	}

	for trg=0, nPCcells-1 { 
		trgGID = ind2gid(trg,0) //PC cells!
		if(PARALLEL){
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell
		}else{
			bool=1
			localID = trg
		}
		for src=0,nPCcells-1 {
			srcGID = ind2gid(src,0) //PC cells!
			if(C.x[srcGID][trgGID]){
				if(srcGID!=trgGID){
					if (bool) { 
						//if(DEBUG){printf("Connectivity constraint: PC%d projects to PC%d\n",PCgids.x(src),PCgids.x(trg))}
						//PCcells.o(localID).soma {distance()}
						//PCcells.o(localID).dend[clusterDend.x(localID)] {clusterDIST.x(localID) = distance(clusterPID.x(localID))}
						//PCcells.o(localID).dend[clusterDend.x(localID)] {print "dendritic segments are ", nseg}
						if(save_synaptic_delays){
							{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						if(save_synaptic_locations){
							{sprint(EXEC_CMD,"{pidPC2PC[%d][%d] = new Vector()}",src,trg)}
							{assert(execute1(EXEC_CMD))}
						}
						for syn=0, (PC2PC_MaxSyn-1) { //for current syn
							//PID=r.repick()
							//rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
							clusterDend[trgGID].x(syn) = 0
							PID = clustbias(clusterPID[trgGID].x[syn],RN_PC2PC[trg].repick())
							//PID = VARPID //bias MCMC
							FIDp = abs(fp_PC2PC[trg].repick())
							if( FIDp <= dt ){ FIDp = dt + 0.01 }
							if(save_synaptic_delays){
								{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",src,trg,FIDp)}
								{assert(execute1(EXEC_CMD))}
							}
							if(save_synaptic_locations){
								{sprint(EXEC_CMD,"{pidPC2PC[%d][%d].append(%f)}",src,trg,PID)}
								{assert(execute1(EXEC_CMD))}
							}
							PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {ampaOnPC[src][trg][syn] = new GLU(PID)}					
							PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {nmdaOnPC[src][trg][syn] = new nmda_segev(PID)}					
							//if (trgGID == 85) {
								PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {nmdaOnPC[src][trg][syn].mybeta = NMDA_BETA}
							//}
							PCcells.o(localID).dend[clusterDend[trgGID].x(syn)] {nmdaOnPC[src][trg][syn].cellid = trgGID}
							if(save_inmda){
								//if( PcellStimList.x(trg)  ){ 			
									{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d] = new Vector()}",src,trg,syn)}
									{assert(execute1(EXEC_CMD))}
									{sprint(EXEC_CMD,"{inmdaPC2PC[%d][%d][%d].record(&nmdaOnPC[%d][%d][%d].inmda)}",src,trg,syn,src,trg,syn)}
									{assert(execute1(EXEC_CMD))}
								//}
							}
							conampaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,ampaOnPC[src][trg][syn],-20,FIDp,ampaweight *  W.x[srcGID][trgGID] * EXCITBIAS)
							//if(PcellStimList.x(trgGID) ){ 	//All cells with dopamin are enhanced	
								//connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-20,FIDp,arg  *  W.x[srcGID][trgGID] ) 
								//print "Jolted ", src, " ", trg," with weight ", arg
							//} else {
								connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-20,FIDp,0.25  *  W.x[srcGID][trgGID] * EXCITBIAS)
								//print "Connected ", src, " ", trg," with weight ",0.25
							//}
						}
					}
				}
			}//connectivity matrix
		}
	}

	if(PARALLEL){ PC.barrier() }
	//---------------------------------------------------Insert Autapses(Lubke, 1996)
	for i=0, nPCcells-1 {
		for j=0, PC_MaxAutosyn-1 {
			conautonmdaPC2PC[i][j] = null
			conautoampaPC2PC[i][j] = null
			autonmdaOnPC[i][j] = null
			autoampaOnPC[i][j] = null
		}
	}

	for i=0, PCcells.count()-1 {
		//if (C.x[PCgids.x(i)][PCgids.x(i)]) { //If autapses are enabled..
			if(save_synaptic_delays){
				{sprint(EXEC_CMD,"{delayPC2PC[%d][%d] = new Vector()}",PCgids.x[i],PCgids.x[i])}
				{assert(execute1(EXEC_CMD))}
			}
			for j=0, (PC_MaxAutosyn-1) { 
				PID=r_PC2PC[PCgids.x[i]].repick()
				//PID = VARPID // bias MCMC
				FIDp = abs(fp_PC2PC[PCgids.x[i]].repick())
				rDendidx = int(rDend_PC2PC[PCgids.x[i]].uniform(0,PCcells.o(i).DendNo-1) )
				if( FIDp <= dt ){ FIDp = dt + 0.01 }
				if(save_synaptic_delays){
					{sprint(EXEC_CMD,"{delayPC2PC[%d][%d].append(%f)}",PCgids.x[i],PCgids.x[i],FIDp)}
					{assert(execute1(EXEC_CMD))}
				}
				rDendidx = 0
				PCcells.o(i).dend[rDendidx] autoampaOnPC[i][j] = new GLU(PID) 
				PCcells.o(i).dend[rDendidx] {autonmdaOnPC[i][j] = new nmda_segev(PID)}
		//----------------------Connect autapses
				conautoampaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autoampaOnPC[i][j], -20, FIDp,ampaweight)
				if( PcellStimList.x(PCgids.x(i))  ){ //proxeirotita, na psaxnw sto cluster; ta stimulated einai ligotera!			
					conautonmdaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autonmdaOnPC[i][j], -20, FIDp,arg)
				} else {
					conautonmdaPC2PC[i][j] = makeSynapse(PCcells,i,PCgids.x(i),autonmdaOnPC[i][j], -20, FIDp,0.25)
				}
			}
		//}
	}
} //END procedure initPC



//---------------------------------------------PV-PV connections--------------------------------------------------------//
objref r_PV2PV[nPVcells],fp_PV2PV[nPVcells]
proc connectPV2PV() { local delstimpvpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PV2PV[i] = new Random(SNd*$1 + 250 + i )
		fp_PV2PV[i] = new Random(SNd*$1 - 100 + i )
		PID = r_PV2PV[i].uniform(0,1)
		delstimpvpv = fp_PV2PV[i].normal(1.76,0.07) //latency from IN-IN, according to Bacci (2003)   
	}

	for src=0, nPVcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //NO NEED to account for PC overhead in matrix, gid are GLOBAL ID ;)
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					if (srcGID == trgGID) { //autapses
						for syn=0, 12-1 { //BACCI 2003
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,autogabaweight )
						}
					} else {
						for syn=0, (1-1) {//SSS Single synapse
							PID = r_PV2PV[PVgids.x[localID]-nPCcells].repick ()
							delstimpvpv=abs(fp_PV2PV[PVgids.x[localID]-nPCcells].repick())
							if(delstimpvpv<=dt){delstimpvpv=dt+0.01}
							PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAa(PID)//was GABAain
							congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,0.002 )
							//congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,0)
						}
						//Connect gap junctions:
						/*if (gapMatrix.x[src][trg]) {
							if (src < trg) {
								par_gap_create_now(trgGID,gapMatrix.x[src][trg]+gidincr,gapMatrix.x[src][trg]+gidincr-1,0.00005)
							} else {
								par_gap_create_now(trgGID,gapMatrix.x[trg][src]+gidincr-1,gapMatrix.x[trg][src]+gidincr,0.00005)
							}
						}*/
						
					}
					//Gap junctions:
					/*if (GapJunc_connMatrix.x[srcGID][trgGID]) { //autapses
						PID = r.repick ()
						PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAain(PID)
						congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,autogabaweight )
					} */
				}
			}
		}
	}

} // End procedure initPV

//----------------------------------------------PC-PV connections-------------------------------------------------------//
objref r_PC2PV[nPVcells],fp_PC2PV[nPVcells]
proc connectPC2PV() { local delstimpcpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp
	if(PARALLEL){ PC.barrier() }

	//set parallel PID randomness
	for i=0, nPVcells-1 {
		r_PC2PV[i] = new Random(SNd*$1 + 150 + i )
		fp_PC2PV[i] = new Random(SNd*$1 * 2 + i)
		PID = r_PC2PV[i].uniform(0,1)
		delstimpcpv = fp_PC2PV[i].normal(0.6, 0.2)		//latency from Pc-In, according to Thomson(2007), also Angulo,Audinat(1999) 
	}

	for src=0, nPCcells-1 {
		for trg=0, nPVcells-1 {
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,0) //PC cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PVgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					// Markram2004: 60% basal, 30% a pical, 10% soma.
					for syn=0, (PC2PV_MaxSyn-1) {
						PID = r_PC2PV[PVgids.x[localID]-nPCcells].repick ()
						//BIAS : Proximal to the soma:
						PID = 0.01
						delstimpcpv=abs(fp_PC2PV[PVgids.x[localID]-nPCcells].repick())
						if(delstimpcpv<=dt){delstimpcpv=dt+0.01}
						PVcells.o(localID).dend {ampaOnPV[src][trg][syn] = new GLUIN(PID)} //no Dends available in the model! (???????)
						PVcells.o(localID).dend {nmdaOnPV[src][trg][syn] = new NMDA(PID)}
						conampaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, ampaOnPV[src][trg][syn], -20, delstimpcpv, ampaweightin)
						connmdaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, nmdaOnPV[src][trg][syn], -20, delstimpcpv, nmdaweightin)    
					}
				}
			}
		}
	}
} //end procedure initPC2PV

// Create vectors to record GABA synaptic current per target:
//objref syncurrGABAa[nPVcells][nPCcells][PV2PC_MaxSyn], syncurrGABAb[nPVcells][nPCcells][PV2PC_MaxSyn]
if(save_synaptic_delays){
	{sprint(EXEC_CMD,"{objref delayPV2PC[%d][%d]}",nPVcells,nPCcells)}
	{assert(execute1(EXEC_CMD))}
}
//------------------------------------------------PV-PC connections-----------------------------------------------------//
objref r_PV2PC[nPCcells],fp_PV2PC[nPCcells], rDend_PV2PC[nPCcells]
proc connectPV2PC() {local delstimpvpc,PID,NoSynapsesSoma,NoSynapsesDend,BasalNo,rDendidx,rApicidx,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fp,rDend
	if(PARALLEL){ PC.barrier() }
	//set parallel PID randomness
	for i=0, nPCcells-1 {
		r_PV2PC[i] = new Random(SNd*$1 + 180 + i )
		fp_PV2PC[i] = new Random(SNd*$1 * 8 + i)
		rDend_PV2PC[i] = new Random(SNd*$1 + 5 + i)
		PID = r_PV2PC[i].uniform(0,1)
		delstimpvpc=fp_PV2PC[i].normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	}

	//delstimpvpc=fpvpc.normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	NoSynapsesSoma = int((PV2PC_MaxSyn * 34) / 100) //percentage was 46 but why? (paper?)
	NoSynapsesDend = PV2PC_MaxSyn - NoSynapsesSoma

	//-----------------------------Connect
	for src=0, nPVcells-1 {
		for trg=0,nPCcells-1 {
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,1) //PV cells!
			if (C.x[srcGID][trgGID]) { //if connection exists; account for PC overhead in matrix
				if(PARALLEL){
					bool = PC.gid_exists(trgGID)
					localID = gid2local(PCgids,trgGID) //target cell
				}else{
					bool=1
					localID = trg
				}
				if (bool) { 
					//----------------------------Insert synapses at dendrites
					for syn=0,(NoSynapsesDend-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						rDendidx = int(rDend_PV2PC[PCgids.x[localID]].uniform(0,PCcells.o(localID).DendNo-1) )
						//PID = r.repick()
						//rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
						rDendidx = 0 //dendrites!
						PCcells.o(localID).dend[rDendidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
						PCcells.o(localID).dend[rDendidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
						//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn],5)} //colorize
					}
					//----------------------------Insert synapses at proximal apicals
					PCcells.o(localID).soma { distance() }
					for syn=0,(NoSynapsesDend-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						rApicidx = int(rDend_PV2PC[PCgids.x[localID]].uniform(0,PCcells.o(localID).ApicNo-1) )
						//PID = r.repick()
						//rApicidx = int(rDend.uniform(0,PCcells.o(localID).ApicNo-1) )
						rApicidx = 0 //proximal!
						PCcells.o(localID).apic[rApicidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
						PCcells.o(localID).apic[rApicidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
					}
					//----------------------------Insert synapses at soma
					for syn=0,(NoSynapsesSoma-1) { 
						PID = r_PV2PC[PCgids.x[localID]].repick ()
						PID = 0.5 //bias MCMC
						//PID = r.repick()					
						PCcells.o(localID).soma gabaOnPC_A[src][trg][syn+NoSynapsesDend] = new GABAa(PID) //carefull not to overwrite array!
						PCcells.o(localID).soma gabaOnPC_B[src][trg][syn+NoSynapsesDend] = new GABAb(PID)

						//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn+NoSynapsesDend],5)} //colorize
					}

					if(save_synaptic_delays){
						{sprint(EXEC_CMD,"{delayPV2PC[%d][%d] = new Vector()}",src,trg)}
						{assert(execute1(EXEC_CMD))}
					}
					for syn=0, (PV2PC_MaxSyn-1) { //for total number of IN-PC synapses
						delstimpvpc=abs(fp_PV2PC[PCgids.x[localID]].repick())
						//delstimpvpc=abs(fpvpc.repick())
						if(delstimpvpc<=dt){delstimpvpc=dt+0.01}
						congabaPV2PC_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_A[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_a*INHIBIAS) //SSS change weight instead of # of synapses
						congabaPV2PC_B[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_B[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_b*INHIBIAS) //SSS DEFAULT WEIGHT is 4 !!
						if(save_synaptic_delays){
							{sprint(EXEC_CMD,"{delayPV2PC[%d][%d].append(%f)}",src,trg,delstimpvpc)}
							{assert(execute1(EXEC_CMD))}
						}
						/*syncurrGABAa[src][trg][syn] = new Vector(n,0)				
						syncurrGABAb[src][trg][syn] = new Vector(n,0)
						syncurrGABAa[src][trg][syn].record(&gabaOnPC_A[src][trg][syn].i,all_msec)
						syncurrGABAb[src][trg][syn].record(&gabaOnPC_B[src][trg][syn].i,all_msec)*/
						
					}
				}
			}
		}
	}
}  //end procedure initPV2PC


//------------------------------------Pharmacological procedures
proc sadp_soma() {
	forsec PCsoma_list{ //soma_list
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= gbar_ican(x)  *fadp}  //0.0001  *fadp//i Nassi exei pio poly ican !
		}
	}
}
proc sadp_dend() {
	forsec PCdend_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= gbar_ican(x)*fadp} //0.0001*0.1
		}
	}
}

proc sadp_apical() {
	forsec PCapical_list {
		for(x) {
			if(ismembrane("ican"))  for(x) { gbar_ican(x)= gbar_ican(x)*fadp} //0.0001*0.1
		}
	}
}






