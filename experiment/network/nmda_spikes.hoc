strdef STDOUT, PPRINT_CMD,EXEC_CMD, PATH, STRING
PATH = "/home/cluster/stefanos/Documents/GitHub/prefrontal-micro/experiment/network/"
if(!load_file("/home/cluster/stefanos/Libraries/nrn/share/nrn/lib/hoc/nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//{load_file("/home/cluster/stefanos/Libraries/nrn/share/nrn/lib/hoc/stdrun.hoc")}
objref PC
PC = new ParallelContext()
PARALLEL  = 0

tstop = 700 
//{xopen("./DATA/vstim.hoc")}
xopen("./main_parameters.hoc")
//steps_per_ms=10
//dt=1/steps_per_ms
//n=int(tstop/dt)
//celsius=34
DEND_NSEG = 5

nPCcells = 1

/*
v_init = -66 
objref cv
cv=new CVode(0)
if(cv.active(0)){print "ERRORRRR!"}	     //Do NOT use CVODE solver!
if(!cv.use_long_double(1)){print "ERRORRRR!"}//was cvode
if(!cv.cache_efficient(1)){print "ERRORRRR!"}
*/

{xopen("pfc_pc_temp.hoc")}

//Balance each cell compartment to the prefered voltage and comply with NEURON initialization routines.
proc balance_compartments() {
	//Do not call finitialize with v_init argument, because it sets it in all cells
	// created up to this point!
	finitialize()
	fcurrent()
	forsec PCcell_list {
		//print "In PCcell_list"
		for (x) {
			//print "V is: ",v
			if (ismembrane("na_ion")) {e_passive(x)=v(x)+ina(x)/g_passive(x)} 
			if (ismembrane("k_ion")) {e_passive(x)=e_passive(x)+ik(x)/g_passive(x)} 
			if (ismembrane("ca_ion")) {e_passive(x)=e_passive(x)+ica(x)/g_passive(x)}
			if (ismembrane("h")) {e_passive(x)=e_passive(x)+ihi(x)/g_passive(x)}
		}
	}
	fcurrent()
	/*if (cv.active()) {
		cv.re_init()
	}       else {
		fcurrent()
	}*/
	frecord_init()
}


//-------------------Set synaptic weights
objref r, PCv,PCi, vsoma
objref PCvd, PCvdd, PCvddd

synapses = SYNAPSES

objref NS[synapses]
NSnoise = 0 

r = new Random(0)
r.normal(0, 0.3)

objref rl
rl = new Random()
rl.uniform(0,1)

objref ampapr[synapses], nmdapr[synapses], nc1[synapses], nc2[synapses]
objref gabaa[4], gabab[4], ncga[4], ncgb[4]

nmdabias = 4 //TEMP CHANGE! REVERT BACK TO 2!!
//When using the nojump, pipe the erf down a little bit..
excitbias = 1

objref nil
objref iNMDA[synapses]
objref NMDA_A[synapses]
objref totalINMDA
objref totalNMDA_A

NS=new NetStim()
NS.interval=ISI//isir.repick()
NS.number=NUMBER//10
NS.start=200
NS.noise=NSnoise

/*
objref stimvec
stimvec = new Vector()
stimvec.append(200)
stimvec.append(205)
stimvec.append(210)
stimvec.append(215)
stimvec.append(220)
stimvec.append(230)
stimvec.append(270)
stimvec.append(290)
stimvec.append(400)
stimvec.append(450)
*/

/*
NS = new VecStim()
NS.play(stimvec)
NS.delay=1
*/


nmdaflag = 1
nojump = 0
PID=0.4
for blah = 1, 1{
			print "---------------------"
			//PID=0.5//rl.repick()

			for syn=0,synapses-1{
				print " Placing synapse : ",syn
				nmdapr[syn] = nil
				ampapr[syn] = nil
				nc1[syn] = nil
				nc2[syn] = nil
				if (nmdaflag){
					if (nojump){
						PCcells.o(0).dend[0] nmdapr[syn] = new nmda_nojump(PID)
					} else {
						PCcells.o(0).dend[0] nmdapr[syn] = new nmda_segev(PID)
					}
					//nmdapr[syn].tau1 = NMDATAU
					//nmdapr[syn].sid = syn 
					//nmdapr[syn].cellid = 0 
					//nmdapr[syn].srcgid = 1 
					nc2[syn]=new NetCon(NS, nmdapr[syn])
					nc2[syn].delay=1
					nc2[syn].weight= 0.25 * 0.5 * excitbias * nmdabias //4.2 
					//nc2[syn].weight= 0.25 * 25 * 2// excitbias * nmda bias
				//}else{
					PCcells.o(0).dend[0] ampapr[syn] = new GLU(PID)
					nc1[syn]=new NetCon(NS, ampapr[syn])
					nc1[syn].delay=1
					nc1[syn].weight=ampaweight* 0.5 * excitbias 
					//nc1[syn].weight=ampaweight//  wfVect.x[wf]// nw*0.1
				}
				
			}

/*
			for syn=0,1-1{
				print " Placing INHIBITORY synapse : ",syn
				PCcells.o(0).soma gabaa[syn] = new GABAa(0.5)
				PCcells.o(0).soma gabab[syn] = new GABAb(0.5)
				ncga[syn]=new NetCon(NS[0], gabaa[syn])
				ncga[syn].delay=100
				ncga[syn].weight=gabaweight_pv2pc_a
				ncgb[syn]=new NetCon(NS[0], gabab[syn])
				ncgb[syn].delay=100
				ncgb[syn].weight=gabaweight_pv2pc_b
			}

			for syn=1,4-1{
				PID = rl.repick()
				print " Placing INHIBITORY synapse : ",syn," PID=",PID
				PCcells.o(0).dend[0] gabaa[syn] = new GABAa(PID)
				PCcells.o(0).dend[0] gabab[syn] = new GABAb(PID)
				ncga[syn]=new NetCon(NS[0], gabaa[syn])
				ncga[syn].delay=100
				ncga[syn].weight=gabaweight_pv2pc_a * 0.33
				ncgb[syn]=new NetCon(NS[0], gabab[syn])
				ncgb[syn].delay=100
				ncgb[syn].weight=gabaweight_pv2pc_b * 0.33
			}
*/

			PCv = new Vector(n,0)
			PCv.record(&PCcells.o(0).soma.v(0.5)) 
			if (nmdaflag){
				//record NMDA current from each synapse
				for syn = 0,synapses-1{
					iNMDA[syn] = new Vector(n,0)
					iNMDA[syn].record(&nmdapr[syn].inmda) 
					NMDA_A[syn] = new Vector(n,0)
					NMDA_A[syn].record(&nmdapr[syn].NLalpha) 

				}
			}
			//PCv.record(&PCcells.o(0).soma.i_passive(0.5)) 
/*
			PCi = new Vector()
			PCi.record(&gabab[0].i) 
			PCvd = new Vector()
			PCvd.record(&PCcells.o(0).dend.v(0.1)) 
			PCvdd = new Vector()
			PCvdd.record(&PCcells.o(0).dend.v(0.5)) 
			PCvddd = new Vector()
			PCvddd.record(&PCcells.o(0).dend.v(0.9)) 
*/

			balance_compartments()
			run()
print "RUN FINISHED"
			vsoma = new File()		

			//sprint(STRING,"DATA/nmda_w%07.3f_pid%.3f.txt", wfVect.x[wf], PID)

			if (nmdaflag) {
				//sprint(STRING,"DATA/soma_NMDA_%d_%d_%d.txt",ISI,NUMBER,NMDATAU)
				if (nojump){
					sprint(STRING,"DATA/soma_NMDA_nojump_%d_%0.1f_%0.1f.txt",synapses,PID,excitbias)
				} else{
					sprint(STRING,"DATA/soma_NMDA_%d_%0.1f_%f.txt",synapses,PID,excitbias)
				}
			}else{
				sprint(STRING,"DATA/soma_AMPA_%d_%d.txt",ISI,NUMBER)
			}
			print STRING
			vsoma.wopen(STRING)
			for j=0, PCv.size()-1 {
				vsoma.printf ("%f\n",PCv.x[j])
			}
			vsoma.close()

print "Vsoma saved"
			if (nmdaflag) {
				totalINMDA = new Vector(n,0)
				for syn = 0,synapses-1{
					for k=0,iNMDA[syn].size()-2{
						totalINMDA.x[k] = totalINMDA.x[k] + iNMDA[syn].x[k]
					}

				}
print "Inmda concatinated"
				sprint(STRING,"DATA/iNMDA_%d_%d_%d.txt",ISI,NUMBER,NMDATAU)
				vsoma.wopen(STRING)
				for j=0, totalINMDA.size()-1 {
					vsoma.printf ("%f\n",totalINMDA.x[j])
				}
				vsoma.close()

				totalNMDA_A = new Vector(n,0)
				for syn = 0,synapses-1{
					for k=0,NMDA_A[syn].size()-2{
						totalNMDA_A.x[k] = totalNMDA_A.x[k] + NMDA_A[syn].x[k]
					}

				}
print "Inmda concatinated"
				sprint(STRING,"DATA/NMDA_A_%d_%d_%d.txt",ISI,NUMBER,NMDATAU)
				vsoma.wopen(STRING)
				for j=0, totalNMDA_A.size()-1 {
					vsoma.printf ("%f\n",totalNMDA_A.x[j])
				}
				vsoma.close()
print "Inmda saved"
			}else{
			}
/*

			sprint(STRING,"DATA/gababi_%.3f.txt",gabaweight_pv2pc_a )
			print STRING
			vsoma.wopen(STRING)
			for j=0, PCi.size()-1 {
				vsoma.printf ("%f\n",PCi.x[j])
			}
			vsoma.close()


			vsoma = new File()		
			sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.1)
			vsoma.wopen(STRING)
			for j=0, PCvd.size()-1 {
				vsoma.printf ("%f\n",PCvd.x[j])
			}
			vsoma.close()

			vsoma = new File()		
			sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.5)
			vsoma.wopen(STRING)
			for j=0, PCvdd.size()-1 {
				vsoma.printf ("%f\n",PCvdd.x[j])
			}
			vsoma.close()

			vsoma = new File()		
			sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.9)
			vsoma.wopen(STRING)
			for j=0, PCvddd.size()-1 {
				vsoma.printf ("%f\n",PCvddd.x[j])
			}
			vsoma.close()
*/

} //for nmdaflag
