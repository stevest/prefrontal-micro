//--------------Set parameters and run this for the net (4 Pcells and 1 Interneuron)
//--------------Written 8-5-08, modified 08-10-08
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//----------------------------------------Set parameters--------------------------------------------------------------//
/*nPCcells=1
nPVcells=1
if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}   */
//override parameters for this validation runs:
nPCcells=1
nPVcells=1
PARALLEL = 0
objref PC

tstop=1000
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
TOTALRUNS = 10
PLOT = 0
DEBUG = 0

objref cv
cv=new CVode(0)

cv.active(0)	     //Do NOT use CVODE solver!
cv.use_long_double(1) //was cvode
cv.cache_efficient(1)


if(!xopen("../../lib/basic-graphics.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("../define_objects.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("pv.hoc")){print "ERROR	Failed to load interneuron hoc!"}

ampaweightin=	7.5e-4	/6		//according to Wang,Gao,2009
nmdaweightin=	3.2e-4	/6		//ratio inmda/iampa for interneuron *0.5(Wang,Gao,2009)

//Create PV cells
//--------------------------------------Graphs
//addgraph_2("PVcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)



//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//

//---------------------------------Procedure for various checks------------------------------------------------//


// train for fADP validation:
objref icTrain[5]

proc train() {
initDelay = 1000
for i=0,4 {
		PVcells.o(0).soma { icTrain[i]=new IClamp(0.5) }
		icTrain[i].del=initDelay	
		icTrain[i].dur=5
		icTrain[i].amp=3//(nA)
		initDelay = initDelay + 50
}}

//--------------------------------------------------------------IClamp
objref ic
proc currentClamp() {
	PVcells.o(0).soma { ic=new IClamp(0.5) }
	ic.del=100
	ic.dur=500//2000
	ic.amp=IC_AMP
}

//--------------------------------------------------------------VClamp
objref vc
proc vclamp() {
	PVcells.o(0).soma { vc = new VClamp(0.5) }
	vc.amp[0] = $1 //FREAKING NEURON WANTS THIS AS AN ARRAY POINTER!!!
	vc.dur[0] = $2//tstop
//for FS autapses testing...
	/*vc.amp[1] = 10
	vc.dur[1] = 1
	vc.amp[2] = -70
	vc.dur[2] = 1999*/
}

objref vsoma, volt,curr, time
proc rec_soma_Voltage(){
	volt=new Vector(n)
	time=new Vector(n) //different dt vector needed from $@#%@$#% NEURON..
	for j=0,n-1 {time.x[j]=j*dt }
	PVcells.o(0).soma { cv.record(&v(0.5),volt,time,1) }
}
proc save_soma_Voltage() {
	vsoma = new File()		
	sprint(temp,"%s_%d.txt", $s1,runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, volt.size()-1 { 
		vsoma.printf ("%f\n",volt.x[sb])
	}
	vsoma.close()
}
proc rec_VClamp_Current(){
  curr=new Vector(n)
  time=new Vector(n) 
  for j=0,n-1 {time.x[j]=j*dt }
  PVcells.o(0).soma cv.record(&vc.i,curr,time,0) 
}

proc save_VClamp_Current() {    
	vsoma = new File()		
	sprint(temp,"%s_%d.txt", $s1, runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, curr.size()-1 { 
	  vsoma.printf ("%f\n",curr.x[sb])
	}
	vsoma.close()
}


proc KblockNassiOLD(){
forall{
for(x){
	fk=0
	//if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	// H Nassi DEN to mplokare (commented) //den mplokarontai apo tous blockers tou Kaliou!
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }}  //slow Ca
	if(ismembrane("mykca")) { for(x) {  gkbar_mykca(x)= gkbar_mykca(x)*fk }} //fast Ca
	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
	if(ismembrane("can")) for(x) {  gcalbar_can(x)= gcalbar_can(x)*0 }
	if(ismembrane("cat")) for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*0 } //mplokaroume k ta Ca, giati den kanoun diafora sto amplitude, alla einai pio sta8era sto Vclamp!	
	if(ismembrane("cal")) for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*0 }
	//if(ismembrane("calc")) for(x) {  gcabar_calc(x)= gcabar_calc(x)*0 }
	if(ismembrane("car")) for(x) {  gcabar_car(x)= gcabar_car(x)*0 }
	}}}



//PC2PV 12 synapses : Xenia paper
objref pv_nmda[12], pv_ampa[12], nc_ampa[12], nc_nmda[12],nc_gabaa[12], pv_gabaa[12]
objref ns
ns = new NetStim(0.5)
ns.interval = 10
ns.number = 1
ns.noise = 0
ns.start = 0
proc PC2PV() { local PID localobj r
	r = new Random(150)
	PID = r.uniform(0,1)
	for syn = 0, 11{
		/*PVcells.o(0).dend {pv_ampa[syn] = new GLUIN(PID)}
		PVcells.o(0).dend {pv_nmda[syn] = new NMDA(PID)}*/
		PVcells.o(0).soma {pv_gabaa[syn] = new GABAain(PID)}
		/*nc_ampa[syn]  = new NetCon(ns, pv_ampa[syn])
		nc_ampa[syn].delay = 0
		nc_ampa[syn].weight = ampaweightin
		nc_ampa[syn].threshold = -20
		nc_nmda[syn]  = new NetCon(ns, pv_nmda[syn])
		nc_nmda[syn].delay =0
		nc_nmda[syn].weight = nmdaweightin
		nc_nmda[syn].threshold = -20*/
		nc_gabaa[syn]  = new NetCon(&PVcells.o(0).soma.v, pv_gabaa[syn])
		nc_gabaa[syn].delay =0
		nc_gabaa[syn].weight = 0//nmdaweightin
		nc_gabaa[syn].threshold = -20

	}
}

pv_w_nmda = 0.000324 //NMDA amp=37.9 pA as in Wang, Gao , 2009
pv_w_ampa = 0.0008 //AMPA amp=104 pA as in Wang, Gao , 2009
	
proc PVNMDA_AMPA() { local PID localobj r
	r = new Random(150+$1)
	PID = r.uniform(0,1)
	for syn = 0, 2-1{ //Synapses 2, Nassi
		if($2==1){
			PVcells.o(0).soma {pv_nmda[syn] = new NMDA(PID)}
			nc_nmda[syn]  = new NetCon(ns, pv_nmda[syn])
			nc_nmda[syn].delay =400
			nc_nmda[syn].weight = pv_w_nmda
			nc_nmda[syn].threshold = -20
		}else{
			PVcells.o(0).soma {pv_ampa[syn] = new GLUIN(PID)}
			nc_ampa[syn]  = new NetCon(ns, pv_ampa[syn])
			nc_ampa[syn].delay = 400
			nc_ampa[syn].weight = pv_w_ampa
			nc_ampa[syn].threshold = -20
		}
	}
}



PVautogabaweight=0.0073*0.88 /10 //wste to current tou Vclamp na einai 350 pA (twn autapses) Bacci, 2003

proc PVautapses() { local PID localobj r
	r = new Random(150)
	PID = r.uniform(0,1)
	for syn = 0, 11{
		PVcells.o(0).soma {pv_gabaa[syn] = new GABAa(PID)}
		nc_gabaa[syn]  = new NetCon(&PVcells.o(0).soma.v, pv_gabaa[syn])
		nc_gabaa[syn].delay =4.4
		nc_gabaa[syn].weight = PVautogabaweight //nmdaweightin
		nc_gabaa[syn].threshold = -20
	}
}



objref PCns[nPCcells], PVns[nPCcells], CBns[nPCcells], CRns[nPCcells]
objref PCsw[nPCcells], PVsw[nPCcells], CBsw[nPCcells], CRsw[nPCcells]
objref inw[100][100][100]
objref insinw[200]

proc noise() { local i

	i=0
	forsec PVsoma_list {
		inw[0][0][i]=new Random(1000+$1)
		inw[0][0][i].poisson(0.02)
		insinw[i]=new SinClamp(0.5)
		insinw[i].del=0      
		insinw[i].dur=tstop
		insinw[i].freq =100
insinw[i].pkamp = 0.01
		inw[0][0][i].play(&insinw[i].pkamp)
		i=i+1
	} 
}

//-----------------------------------------------------Multiple Runs
//createPVs()
strdef syscmd, foldername, filename
foldername = "valid_PV"
//sprint(syscmd,"mkdir -p /%s/",foldername) 
//system(syscmd) 
sprint(filename,"%s/%s",foldername,"PV_inputResistance") 

//Input resistance
IC_AMP = 0.05 //(nA)
for runs = 0, TOTALRUNS-1 {
//PVautapses(runs)
//	currentClamp() 
//noise(runs)
//	KblockNassiOLD()  //mono gia tous NMDA
//	vclamp()	
//	PC2PV()
//	print IC_AMP
//	rec_soma_Voltage()
//	rec_VClamp_Current()
//addgraph_2("vc.i", 0,tstop, -0.1, 0.1)
//	run()

//	save_soma_Voltage(filename)
//	save_VClamp_Current(filename)
//	IC_AMP = IC_AMP+0.05

//PV NMDA 2 AMPA ratio:
/*
PVNMDA_AMPA(runs, 1) //1=NMDA, 2=AMPA
vclamp(60,1000)
rec_VClamp_Current()
run()
sprint(filename,"%s/%s",foldername,"PVNMDA_curr") 
save_VClamp_Current(filename)
*/

PVNMDA_AMPA(runs, 2) //1=NMDA, 2=AMPA
vclamp(-70,1000)
rec_VClamp_Current()
run()
sprint(filename,"%s/%s",foldername,"PVAMPA_curr") 
save_VClamp_Current(filename)

}



