//--------------Set parameters and run this for the net (4 Pcells and 1 Interneuron)
//--------------Written 8-5-08, modified 08-10-08
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//----------------------------------------Set parameters--------------------------------------------------------------//
/*nPCcells=1

if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}   */
//override parameters for this validation runs:
nPCcells=1
PARALLEL = 0
objref PC

tstop=1300
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
TOTALRUNS = 21
PLOT = 0
DEBUG = 0

objref cv
cv=new CVode(0)

if(cv.active(0)){print "ERRORRRR!"}	     //Do NOT use CVODE solver!
if(!cv.use_long_double(1)){print "ERRORRRR!"}//was cvode
if(!cv.cache_efficient(1)){print "ERRORRRR!"}

PYID = 22 //initially load morphology #0
stimIntensity = 12


SIMPLIFIED = 0
MODE = 7

if (name_declared("MODE")!=5) { 
MODE = 0 
printf("No 'MODE' argument passed; reverting to default...\n\n")
}else{
printf("'MODE' argument is %f\n\n",MODE)
}

/*  MODEs   */
/*  MODE 1   */
/*  MODE 2 FS2PC mIPSC GABAa (Woo, 2007)   */


//procedure to choose which Pyramidal morphologies we want in network
if(!xopen("chooseMorphologies.hoc")){print "ERROR	Failed to load choose morphologies!"}
//argument: percentage of IB cells morphologies in network, random seed:
chooseMorphologies(60,0)
if(!xopen("../../lib/basic-graphics.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("../define_objects.hoc")){print "ERROR	Failed to import parameters!"}

if(!xopen("../RS1cell.hoc")){print "ERROR	Failed to load interneuron hoc!"}
//	PCcells.o(0){ print L}
if(!xopen("importBackgroundStimParams.hoc")){print "ERROR	Failed to import network parameters!"}
if(!xopen("RAPIDimportBackgroundStimParams.hoc")){print "ERROR	Failed to import RAPID parameters!"}

//--------------------------------------Graphs
//addgraph_2("PCcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)


//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//

//---------------------------------Procedure for various checks------------------------------------------------//


// train for fADP validation:
objref icTrain[5]

proc train() {
initDelay = 1000
for i=0,4 {
		PCcells.o(0).soma { icTrain[i]=new IClamp(0.5) }
		icTrain[i].del=initDelay	
		icTrain[i].dur=5
		icTrain[i].amp=3//(nA)
		initDelay = initDelay + 50
}}

//--------------------------------------------------------------IClamp
objref ic
proc currentClamp() { 
	PCcells.o(0).soma { ic=new IClamp(0.5) }
	ic.del=400
	ic.dur=500//2000
	ic.amp=$1
}

//--------------------------------------------------------------VClamp
objref vc[2]
proc vclamp() {
	objref vc[2]
	PCcells.o(0).soma { vc[$3] = new VClamp(0.5) }
	vc[$3].amp[0] = $1 //FREAKING NEURON WANTS THIS AS AN ARRAY POINTER!!!
	vc[$3].dur[0] = $2//tstop
//for FS autapses testing...
	/*vc.amp[1] = 10
	vc.dur[1] = 1
	vc.amp[2] = -70
	vc.dur[2] = 1999*/
}

objref vsoma[TOTALRUNS], volt[TOTALRUNS],curr[TOTALRUNS], time[TOTALRUNS]
proc rec_soma_Voltage(){
	volt[runs]=new Vector(n)
	time[runs]=new Vector(n) //different dt vector needed from $@#%@$#% NEURON..
	for j=0,n-1 {time[runs].x[j]=j*dt }
	PCcells.o(0).soma { cv.record(&v(0.5),volt[runs],time[runs],1) }
}
proc save_soma_Voltage() {
	vsoma[runs] = new File()		
	sprint(temp,"%s_%d.txt", $s1,runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, volt.size()-1 { 
		vsoma.printf ("%f\n",volt[runs].x[sb])
	}
	vsoma.close()
}
proc rec_VClamp_Current(){
	curr[runs]=new Vector(n)
	time[runs]=new Vector(n) 
	for j=0,n-1 {time[runs].x[j]=j*dt }
	cv.record(&vc[$1].i,curr[runs],time[runs],1)
}

proc save_VClamp_Current() {    
	vsoma[runs] = new File()		
	sprint(temp,"%s_%d.txt", $s1, runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, curr.size()-1 { 
		vsoma.printf ("%f\n",curr[runs].x[sb])
	}
	vsoma.close()
}



//---------------------------------Procedure for various checks------------------------------------------------//	
objref ampau[TOTALRUNS][100][stimIntensity], nmdau[TOTALRUNS][100][stimIntensity], gabaau[TOTALRUNS][100][stimIntensity]
objref gabaa_mIPSC, gabaad[4], gababd[4], fsgabaac[4], rsgabaac[12]
objref nsu,ns40, nsr
nsu=new NetStim(0.5)
nsu.interval=10//(in ms!!!)// 20ms in NMDA SPIKES
nsu.number=1 //Unitary NetStim
nsu.start=0
nsu.noise=0
ns40=new NetStim(0.5)
ns40.interval=10//100Hz
ns40.number=40 //Thomson 1996 (?)
ns40.start=0
ns40.noise=0
nsr=new NetStim(0.5)
nsr.interval=50//(in ms!!!)// 20ms in NMDA SPIKES
nsr.number=1 //Unitary NetStim
nsr.start=0
nsr.noise=0

objref nc_mIPSC, nc_gabaad[4], nc_gababd[4], nc_fsgabaac[4], nc_rsgabaac[12]
objref nc_a[TOTALRUNS][100][stimIntensity]
objref nc_n[TOTALRUNS][100][stimIntensity]
		
proc mIPSC() { localobj r
	r = new Random($1)
	r.uniform(0,1)
	PID=r.repick()
	PCcells.o[0].soma {
		gabaa_mIPSC = new GABAa(PID)
		nc_mIPSC=new NetCon(nsu, gabaa_mIPSC)
		nc_mIPSC.delay=400
		nc_mIPSC.weight=0.00068	//According to Woo(2007) 10pA for single GABAa gia -65 VCLAM DONE
		nc_mIPSC.threshold=-20
	}
}


proc GABAa_mv() { localobj r
	r = new Random($1)
	r.uniform(0,1)
	PID=r.repick()
	for cs=0, 3 { // 4 synapses Nassi
		PID=r.repick()
		PCcells.o[0].soma {
			gabaad[cs] = new GABAa(PID)
			nc_gabaad[cs]=new NetCon(ns40, gabaad[cs])
			nc_gabaad[cs].delay=400
			nc_gabaad[cs].weight=0.00068//According to Woo(2007) 10pA for single GABAa gia -65 VCLAM DONE
			nc_gabaad[cs].threshold=-20
		}
	}
}

proc GABAb_mv() { localobj r
	r = new Random($1)
	r.uniform(0,1)
	PID=r.repick()
	for cs=0, 3 { // 4 synapses Nassi
		PID=r.repick()
		PCcells.o[0].soma {
			gababd[cs] = new GABAb(PID)
			nc_gababd[cs]=new NetCon(ns40, gababd[cs])
			nc_gababd[cs].delay=400
			nc_gababd[cs].weight=0.00068*0.13
			nc_gababd[cs].threshold=-20
		}
	}
}

//Cl- ,ecl=-16
proc FSGABAa_curr() { localobj r
	r = new Random($1)
	r.uniform(0,1)
	PID=r.repick()
	for cs=0, 3 { // 4 synapses, Nassi
		PID=r.repick()
		PCcells.o[0].soma {
			fsgabaac[cs] = new GABAa(0.5)
			nc_fsgabaac[cs]=new NetCon(nsu, fsgabaac[cs])
			nc_fsgabaac[cs].delay=400
			nc_fsgabaac[cs].weight=0.00068//According to Woo(2007) 10pA for single GABAa gia -65 VCLAM DONE
			nc_fsgabaac[cs].threshold=-20
		}
	}
}

//Cl- ,ecl=-16
proc RSGABAa_curr() { localobj r, rd
	r = new Random($1)
	rd = new Random($1)
	ApicalNo=0
	forsec PCcells.o[0].apical { ApicalNo+=1 }
	r.uniform(0,ApicalNo-1)
	rd.uniform(0,1)
	for cs=0, 11 { // 12 synapses, Xenia
		PID=rd.repick()
		cd = r.repick()
		PCcells.o[0].soma { distance() }
		PCcells.o[0].apic[cd]{root2here = distance(PID)}
		while (root2here < 200) {
			PID = rd.repick()
			cd = int(r.repick())
			PCcells.o[0].apic[cd]{root2here = distance(PID)}
		}

		PCcells.o[0].apic[cd] {
			rsgabaac[cs] = new GABAa(PID)
			nc_rsgabaac[cs]=new NetCon(nsu, rsgabaac[cs])
			nc_rsgabaac[cs].delay=400
			nc_rsgabaac[cs].weight=0.000045 //according to Xiang 2002 DONE
			nc_rsgabaac[cs].threshold=-20
		}
	}
}



// Create synapses at random basal dendrite locations:
proc AMPA_Curr() { localobj r
	r = new Random($1)
	BasalNo=0
	forsec PCcells.o[0].basal { BasalNo+=1 }
	r.uniform(0,BasalNo-1)
		for cs=0, stimIntensity-1 {
			PID=0.5 //BUG: difficult to converge when I changes randomly..
			cd = r.repick()
			PCcells.o[0].dend[cd] {
				nmdau[runs][cd][cs] = new nmda_segev(PID)
				nc_a[runs][cd][cs]=new NetCon(ns2, nmdau[runs][cd][cs])
				nc_a[runs][cd][cs].delay=400
				nc_a[runs][cd][cs].weight=0.468750//0.00015//0.000065//*11// Validated for 1.2
				nc_a[runs][cd][cs].threshold=-20
			}
		}
}


gabaweight=0.0006		//According to Woo(2007) 10pA for single GABAa gia -65 VCLAM DONE
gabaweightb=gabaweight*0.13	//According to Thomson(1999) DONE 
proc FSGABA_Curr() {

		for cs=0, 4{ //4 synapses, Nassi
			PID=0.5 //BUG: difficult to converge when I changes randomly..
			PCcells.o[0].soma[0] {
				gabaau[runs][cd][cs] = new GABAa(PID)
				nc_a[runs][cd][cs]=new NetCon(ns2, gabaau[runs][cd][cs])
				nc_a[runs][cd][cs].delay=400
				nc_a[runs][cd][cs].weight=gabaweight//0.00015//0.000065//*11// Validated for 1.2
				nc_a[runs][cd][cs].threshold=-20
			}
		}
}

RSgabaweight=0.00005 //according to Xiang 2002 DONE
proc RSGABA_Curr() { localobj r, rd
	r = new Random($1)
	rd = new Random($1)
	ApicalNo=0
	forsec PCcells.o[0].apical { ApicalNo+=1 }
	r.uniform(0,ApicalNo-1)
	rd.uniform(0,1)
		for cs=0, 3 { 
			PID=rd.repick()
			cd = r.repick()
			PCcells.o[0].soma { distance() }
			PCcells.o[0].apic[cd]{root2here = distance(PID)}
			while (root2here < 200) {
				PID = rd.repick()
				cd = int(r.repick())
				PCcells.o[0].apic[cd]{root2here = distance(PID)}
			}

			PCcells.o[0].apic[cd] {
				gabaau[runs][cd][cs] = new GABAa(PID)
				nc_a[runs][cd][cs]=new NetCon(ns2, gabaau[runs][cd][cs])
				nc_a[runs][cd][cs].delay=400
				nc_a[runs][cd][cs].weight=RSgabaweight//0.00015//0.000065//*11// Validated for 1.2
				nc_a[runs][cd][cs].threshold=-20
			}
		}
}

ISgabaweight=0.00006 //according to Xiang 2002 DONE
proc ISGABA_Curr() { localobj r, rd
	r = new Random($1)
	rd = new Random($1)
	ApicalNo=0
	forsec PCcells.o[0].apical { ApicalNo+=1 }
	r.uniform(0,ApicalNo-1)
	rd.uniform(0,1)
	for cs=0, 9 { //10 synapses CR2PC (Xenia paper)
		PID=rd.repick()
		cd = r.repick()
		PCcells.o[0].soma { distance() }
		PCcells.o[0].apic[cd]{root2here = distance(PID)}
		while (root2here < 200) {
			PID = rd.repick()
			cd = int(r.repick())
			PCcells.o[0].apic[cd]{root2here = distance(PID)}
		}
		PCcells.o[0].apic[cd] {
			gabaau[runs][cd][cs] = new GABAa(PID)
			nc_a[runs][cd][cs]=new NetCon(nsu, gabaau[runs][cd][cs])
			nc_a[runs][cd][cs].delay=400
			nc_a[runs][cd][cs].weight=ISgabaweight//0.00015//0.000065//*11// Validated for 1.2
			nc_a[runs][cd][cs].threshold=-20
		}
	}
}

objref tmpnmdaa[200], tmpampaa[200],tmpnmdab[200], tmpampab[200], tmpampar[200],tmpnmdar[200]
objref nc_tmpaa[200], nc_tmpna[200],nc_tmpab[200], nc_tmpnb[200],nc_tmpar[200], nc_tmpnr[200]
objref vstima[600], vstimb[600], vstimr[600]


proc simple_stimulation(){ local ApicalNo, BasalNo, cs, cd, ca, PID  localobj ra, rb, rn
	ra = new Random($1)
	rb = new Random($1)
	rn = new Random($1)
	ApicalNo = 0
	BasalNo = 0
	forsec PCcells.o[0].apical { ApicalNo+=1 }
	ra.uniform(0,ApicalNo-1)
	forsec PCcells.o[0].basal { BasalNo+=1 }
	rb.uniform(0,BasalNo-1)
	rn.uniform(0,1)

	for cs=0, BG_apicSyn-1 {
		PID=rn.repick()
		ca = ra.repick()
		PCcells.o[0].apic[ca] {
			vstima[cs] = new VecStim(0.5)
			vstima[cs].delay = 0
			vstima[cs].play(BG_Stim_Apic[0][cs])

			tmpnmdaa[cs] = new nmda_segev(PID)
			nc_tmpna[cs]=new NetCon(vstima[cs], tmpnmdaa[cs])
			nc_tmpna[cs].delay=400
			nc_tmpna[cs].weight= 0.6250//0.7812 //VALIDATED Segev = 0.6250
			nc_tmpna[cs].threshold=-20
			
			tmpampaa[cs] = new GLU(PID)
			nc_tmpaa[cs]=new NetCon(vstima[cs], tmpampaa[cs])
			nc_tmpaa[cs].delay=400
			nc_tmpaa[cs].weight= 0.0001526 //VALIDATED
			nc_tmpaa[cs].threshold=-20
		}
	}

	for cs= 0,BG_dendSyn-1{
		PID=rn.repick()
		cd = rb.repick()
		PCcells.o[0].dend[cd] {
			vstimb[cs] = new VecStim(0.5)
			vstimb[cs].delay = 0
			vstimb[cs].play(BG_Stim_Dend[0][cs])

			tmpnmdab[cs] = new nmda_segev(PID)
			nc_tmpnb[cs]=new NetCon(vstimb[cs], tmpnmdab[cs])
			nc_tmpnb[cs].delay=400
			nc_tmpnb[cs].weight=   0.6250//0.7812 //VALIDATED KIKIS W = 0.0005341
			nc_tmpnb[cs].threshold=-20
			
			tmpampab[cs] = new GLU(PID)
			nc_tmpab[cs]=new NetCon(vstimb[cs], tmpampab[cs])
			nc_tmpab[cs].delay=400
			nc_tmpab[cs].weight= 0.0001526 //VALIDATED
			nc_tmpab[cs].threshold=-20
		}
	}
	
/*
	for cs= 0,BG_rapid-1{
		PID=rn.repick()
		cd = rb.repick()
		PCcells.o[0].dend[cd] {
			vstimr[cs] = new VecStim(0.5)
			vstimr[cs].delay = 0
			vstimr[cs].play(BG_Stim_Rapid[0][cs])

			tmpnmdar[cs] = new nmda_segev(PID)
			nc_tmpnr[cs]=new NetCon(vstimr[cs], tmpnmdar[cs])
			nc_tmpnr[cs].delay=0
			nc_tmpnr[cs].weight= 0.6250 //VALIDATED
			nc_tmpnr[cs].threshold=-20
		
			tmpampar[cs] = new GLU(PID)
			nc_tmpar[cs]=new NetCon(vstimr[cs], tmpampar[cs])
			nc_tmpar[cs].delay=0
			nc_tmpar[cs].weight= 0.0001526 //VALIDATED
			nc_tmpar[cs].threshold=-20
		}
	}*/

}

objref nmdavc[1000], nmdanc[1000]
// Create synapses at random basal dendrite locations:
proc NMDAVC() { localobj r,rp
	r = new Random($1)
	rp = new Random($1+2)
	BasalNo=0
	forsec PCcells.o[0].basal { BasalNo+=1 }
	r.uniform(0,BasalNo-1)
	rp.uniform(0,1)
	cd = 0//r.repick()
		for cs=0, 1000-1 {
			PID = rp.repick() //0.5
			
			PCcells.o[0].dend[cd] {
				nmdavc[cs] = new nmda_segev(PID)
				nmdanc[cs]=new NetCon(nsu, nmdavc[cs])
				nmdanc[cs].delay=1000
				nmdanc[cs].weight = 0.6250 
				nmdanc[cs].threshold=-20
			}
		}
}

objref ampavc[1], ampanc[1]
// Create synapses at random basal dendrite locations:
proc AMPAVC() { localobj r
	r = new Random($1)
	BasalNo=0
	forsec PCcells.o[0].basal { BasalNo+=1 }
	r.uniform(0,BasalNo-1)
	cd = 0//r.repick()
		for cs=0, 10-1 {
			PID=0.5 
			
			PCcells.o[0].dend[cd] {
				ampavc[0] = new nmda_segev(PID)
				ampanc[0]=new NetCon(nsu, ampavc[0])
				ampanc[0].delay=1000
				ampanc[0].weight = 0.6250
				ampanc[0].threshold=-20
			}
		}
}


//------------------------------------Pharmacological procedures
fadp=0//2//0.5//0.23
proc sadp_soma() {
	forsec PCsoma_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*fadp } 
		}}}
proc sadp_dend() {
	forsec PCdend_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*0.1*fadp} 
		}}}
proc sadp_apical() {
	forsec PCapical_list {
		for(x) {
			if(ismembrane("ican"))  for(x) { gbar_ican(x)= 0.0001*0.1*fadp} 
		}}}

proc KblockNassiOLD(){
forall{
for(x){
	fk=0
	//if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	// H Nassi DEN to mplokare (commented) //den mplokarontai apo tous blockers tou Kaliou!
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }}  //slow Ca
	if(ismembrane("mykca")) { for(x) {  gkbar_mykca(x)= gkbar_mykca(x)*fk }} //fast Ca
	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
	if(ismembrane("can")) for(x) {  gcalbar_can(x)= gcalbar_can(x)*0 }
	if(ismembrane("cat")) for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*0 } //mplokaroume k ta Ca, giati den kanoun diafora sto amplitude, alla einai pio sta8era sto Vclamp!	
	if(ismembrane("cal")) for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*0 }
	//if(ismembrane("calc")) for(x) {  gcabar_calc(x)= gcabar_calc(x)*0 }
	if(ismembrane("car")) for(x) {  gcabar_car(x)= gcabar_car(x)*0 }
	}}}

proc TTX() {
forall {
    for(x) {
    if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
    if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
    }}}

//-----------------------------------------------------Multiple Runs

strdef syscmd, foldername, filename
foldername = "valid_PC"

//sprint(filename,"%s/%s",foldername,"PC_inputResistance")
 

//Input resistance
vclampa = -100
for runs = 0, TOTALRUNS-1 {
runs
//for multiple runs validate the AMPA current depolarization:

if (MODE==2){
	vclamp(-65, 1000)
	mIPSC(runs) 	
	rec_VClamp_Current()
	addgraph_2("vc.i", 0,tstop, 0.4, 0)
	run()
	sprint(filename,"%s/%s",foldername,"mIPSC") 
	save_VClamp_Current(filename)
}
if (MODE==3){
//NA TA TREXW XWRIA TA A,B GIATI TO !@#$!#$@ NEURON ME DOULEVEI KANONIKA..
	GABAa_mv(runs)
	rec_soma_Voltage()
	addgraph_2("PCcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)
	run()
	sprint(filename,"%s/%s",foldername,"GABAa_mV")
	save_soma_Voltage(filename)

	GABAb_mv(runs)
	rec_soma_Voltage()
	addgraph_2("PCcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)
	run()
	sprint(filename,"%s/%s",foldername,"GABAb_mV")
	save_soma_Voltage(filename)
}
if (MODE==4){
	/*//GABAa Cl- ,ecl=-16
	vclamp(-80, 1000,0)
	FSGABAa_curr(runs)
	rec_VClamp_Current(0)
	addgraph_2("vc[0].i", 0,tstop, 0.4, 0)
	run()
	sprint(filename,"%s/%s",foldername,"FSGABAa_curr") 
	save_VClamp_Current(filename)*/

	//GABAa Cl- ,ecl=-16
	vclamp(-80, 1000,1)
	RSGABAa_curr(runs)
	rec_VClamp_Current(1)
	addgraph_2("vc[1].i", 0,tstop, 0.4, 0)
	run()
	sprint(filename,"%s/%s",foldername,"RSGABAa_curr") 
	save_VClamp_Current(filename)
}
if(MODE==5){
	vclamp(-80, 1000,1)
	ISGABA_Curr(runs) //VALIDATION WRONG BECAUSE OF WRONG NO O FYNAPSES!!
	rec_VClamp_Current(1)
	addgraph_2("vc[1].i", 0,tstop, 0.4, 0)
	run()
	sprint(filename,"%s/%s",foldername,"ISGABAa_curr") 
	save_VClamp_Current(filename)
}


if(MODE==6){
	//Simple Stimulation MODE:
	simple_stimulation(runs)
	//vclamp(60, tstop,0)
	//KblockNassiOLD()
	sadp_soma()
	sadp_dend()
	sadp_apical()
	//rec_soma_Voltage()
	addgraph_2("PCcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)
	//addgraph_2("vc[0].i", 0,tstop, 0,250)
	run()
	//sprint(filename,"%s/%s",foldername,"simple_stim") 
	//save_soma_Voltage(filename)
}


if(MODE==7){
	NMDAVC(runs)
	//AMPAVC(runs)
	vclamp(vclampa, tstop,0)
	print "VClamp @ ", vclampa
	KblockNassiOLD()
	//TTX()
	addgraph_2("vc[0].i", 0,tstop, -0.01, 0.01)
	rec_VClamp_Current(0)
	run()
	sprint(filename,"%s/%s",foldername,"NMDAVC") 
	save_VClamp_Current(filename)
	vclampa += 5
}





//	FSGABA_Curr(runs) //Simulate ONE AMPA synapse and measure the depolarization in the soma
//	currentClamp(0.25) 
//	KblockNassiOLD()  //mono gia tous NMDA
//	PC2PV()

}



