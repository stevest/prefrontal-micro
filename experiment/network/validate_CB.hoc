//--------------Set parameters and run this for the net (4 Pcells and 1 Interneuron)
//--------------Written 8-5-08, modified 08-10-08
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
//----------------------------------------Set parameters--------------------------------------------------------------//
//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}   
//override parameters for this validation runs:
nPCcells=1
nCBcells=1
PARALLEL = 0
objref PC

tstop=1000
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
TOTALRUNS = 10
PLOT = 0
DEBUG = 0

objref cv
cv=new CVode(0)

cv.active(0)	     //Do NOT use CVODE solver!
cv.use_long_double(1) //was cvode
cv.cache_efficient(1)

if(!xopen("../../lib/basic-graphics.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("../define_objects.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("cb.hoc")){print "ERROR	Failed to load interneuron hoc!"}

ampaweight_pc2cb = 0.000058//Symfwna me Wang,Gao,2009Table1 //0.000029		//Angulo/Wang validated 28/05/2010
nmdaweight_pc2cb = 0.000066

//--------------------------------------Graphs
//addgraph_2("CBcells.o(0).soma.v(0.5)", 0,tstop, -70, 50)



//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//

//---------------------------------Procedure for various checks------------------------------------------------//


// train for fADP validation:
objref icTrain[5]

proc train() {
initDelay = 1000
for i=0,4 {
		CBcells.o(0).soma { icTrain[i]=new IClamp(0.5) }
		icTrain[i].del=initDelay	
		icTrain[i].dur=5
		icTrain[i].amp=3//(nA)
		initDelay = initDelay + 50
}}

//--------------------------------------------------------------IClamp
objref ic
proc currentClamp() {
	CBcells.o(0).soma { ic=new IClamp(0.5) }
	ic.del=$1
	ic.dur=$2
	ic.amp=$3
}

//--------------------------------------------------------------VClamp
objref vc
proc vclamp() {
	CBcells.o(0).soma { vc = new VClamp(0.5) }
	vc.amp[0] = $1 //FREAKING NEURON WANTS THIS AS AN ARRAY POINTER!!!
	vc.dur[0] = $2
}

objref vsoma, volt,curr, time
proc rec_soma_Voltage(){
	volt=new Vector(n)
	time=new Vector(n) //different dt vector needed from $@#%@$#% NEURON..
	for j=0,n-1 {time.x[j]=j*dt }
	CBcells.o(0).soma { cv.record(&v(0.5),volt,time,1) }
}
proc save_soma_Voltage() {
	vsoma = new File()		
	sprint(temp,"%s_%d.txt", $s1,runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, volt.size()-1 { 
		vsoma.printf ("%f\n",volt.x[sb])
	}
	vsoma.close()
}
proc rec_VClamp_Current(){
  curr=new Vector(n)
  time=new Vector(n) 
  for j=0,n-1 {time.x[j]=j*dt }
  CBcells.o(0).soma cv.record(&vc.i,curr,time,0) 
}

proc save_VClamp_Current() {    
	vsoma = new File()		
	sprint(temp,"%s_%d.txt", $s1,runs)  //RS/IB classification!
	vsoma.wopen(temp)
	for sb=0, curr.size()-1 { 
	  vsoma.printf ("%f\n",curr.x[sb])
	}
	vsoma.close()
}


proc KblockNassiOLD(){
forall{
for(x){
	fk=0
	//if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	// H Nassi DEN to mplokare (commented) //den mplokarontai apo tous blockers tou Kaliou!
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }}  //slow Ca
	if(ismembrane("mykca")) { for(x) {  gkbar_mykca(x)= gkbar_mykca(x)*fk }} //fast Ca
	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
	if(ismembrane("can")) for(x) {  gcalbar_can(x)= gcalbar_can(x)*0 }
	if(ismembrane("cat")) for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*0 } //mplokaroume k ta Ca, giati den kanoun diafora sto amplitude, alla einai pio sta8era sto Vclamp!	
	if(ismembrane("cal")) for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*0 }
	//if(ismembrane("calc")) for(x) {  gcabar_calc(x)= gcabar_calc(x)*0 }
	if(ismembrane("car")) for(x) {  gcabar_car(x)= gcabar_car(x)*0 }
	}}}

//PC2PV 12 synapses : Xenia paper
objref cb_nmda[14], cb_ampa[14], nc_ampa[14], nc_nmda[14]
objref ns
ns = new NetStim(0.5)
ns.interval = 10
ns.number = 1
ns.noise = 0
ns.start = 0
proc PC2CB() { local PID localobj r
	r = new Random(150)
	PID = r.uniform(0,1)
	for syn = 0, 13{
		CBcells.o(0).dend {cb_ampa[syn] = new GLUIN(0.5)}
		CBcells.o(0).dend {cb_nmda[syn] = new NMDA(0.5)}
		nc_ampa[syn]  = new NetCon(ns, cb_ampa[syn])
		nc_ampa[syn].delay = 0
		nc_ampa[syn].weight = ampaweight_pc2cb
		nc_ampa[syn].threshold = -20
		nc_nmda[syn]  = new NetCon(ns, cb_nmda[syn])
		nc_nmda[syn].delay =0
		nc_nmda[syn].weight = nmdaweight_pc2cb
		nc_nmda[syn].threshold = -20

	}
}


gabaweightcr2cb = 0.0083*0.25  //Xenia GABAa CR2CB (uIPSC) curr 25.4pA 
objref gabaacrcb[2]
objref congabaacrcb[2]
proc cr2cb() {localobj fcrp,r
	fcrp = new Random($1*9)
	r = new Random($1)
	r.uniform(0,1)
	delstimcrp=fcrp.normal(1.8, 0.8)	//latency from CB-Pc, according to Thomson(2007)
	//-----------------------------Connect
	for k=0, (2-1) { //Xenia
		//delstimcrp=fcrp.repick()
		//if (delstimcrp<0) {delstimcrp=delstimcrp*(-1)}
		CBcells.o(0).dend {gabaacrcb[k] = new GABAa(r.repick())}
		CBcells.o(0).dend {congabaacrcb[k] = new NetCon(ns, gabaacrcb[k], -20, 400, gabaweightcr2cb)}
	}
}

objref cb_nmda[14], cb_ampa[14], nc_ampa[14], nc_nmda[14],nc_gabaa[14], cb_gabaa[14]
cb_w_nmda = 0.000067 //NMDA amp=51.3 pA as in Wang, Gao , 2009
cb_w_ampa = 0.000058	 //AMPA amp=53 pA as in Wang, Gao , 2009

	
proc CBNMDA_AMPA() { local PID localobj r
	r = new Random(150+$1)
	PID = r.uniform(0,1)
	for syn = 0, 14-1{ //PC2CB 14 synapses, Xenia
		if($2==1){
			CBcells.o(0).dend {cb_nmda[syn] = new NMDA(PID)}
			nc_nmda[syn]  = new NetCon(ns, cb_nmda[syn])
			nc_nmda[syn].delay =400
			nc_nmda[syn].weight = cb_w_nmda
			nc_nmda[syn].threshold = -20
		}else{
			CBcells.o(0).dend {cb_ampa[syn] = new GLUIN(PID)}
			nc_ampa[syn]  = new NetCon(ns, cb_ampa[syn])
			nc_ampa[syn].delay = 400
			nc_ampa[syn].weight = cb_w_ampa
			nc_ampa[syn].threshold = -20
		}
	}
}

objref  gabaacb[2], nc_gaba[2]
objref gabaa_mIPSC, gabaad[4], gababd[4], fsgabaac[4], rsgabaac[12]
RSgabaweight=0.00006 //according to Xiang 2002 (?) , symfwna me Xenia
proc RSGABA_Curr() { localobj r
	r = new Random($1)
	r.uniform(0,1)
	for cs=0, 2-1 { //2 synapses CR2CB(Xenia paper)
		CBcells.o[0].dend {
			gabaacb[cs] = new GABAa(r.repick())
			nc_gaba[cs]=new NetCon(ns, gabaacb[cs])
			nc_gaba[cs].delay=400
			nc_gaba[cs].weight=RSgabaweight
			nc_gaba[cs].threshold=-20
		}
	}
}


//-----------------------------------------------------Multiple Runs
createCBs()
strdef syscmd, foldername, filename
foldername = "valid_CB"
//sprint(syscmd,"mkdir -p /%s/",foldername) 
//system(syscmd) 
sprint(filename,"%s/%s",foldername,"CB_inputResistance") 
//test code

//Input resistance
//IC_AMP = 0.2//(nA)
for runs = 0, TOTALRUNS-1 {
//print runs
	currentClamp(400, 500, -0.1) 
//	RSGABA_Curr(runs) 
//	KblockNassiOLD()
//	vclamp(-80,1000)
//	cr2cb(runs)
//	PC2CB()
//	print IC_AMP
	rec_soma_Voltage()
//	rec_VClamp_Current()
//	addgraph_2("vc.i", 0,tstop, -0.1, 0.1)
	run()
	save_soma_Voltage(filename)
//	sprint(filename,"%s/%s",foldername,"CRCB_GABAa") 
//	save_VClamp_Current(filename)
	//IC_AMP = IC_AMP+0.05





//CB NMDA 2 AMPA ratio:
/*
CBNMDA_AMPA(runs, 1) //1=NMDA, 2=AMPA
vclamp(60,1000)
rec_VClamp_Current()
run()
sprint(filename,"%s/%s",foldername,"CBNMDA_curr") 
save_VClamp_Current(filename)
*/
/*
CBNMDA_AMPA(runs, 2) //1=NMDA, 2=AMPA
vclamp(-70,1000)
rec_VClamp_Current()
run()
sprint(filename,"%s/%s",foldername,"CBAMPA_curr") 
save_VClamp_Current(filename)
*/


}


