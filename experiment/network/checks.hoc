//--------------Set parameters and run this for the net (4 Pcells and 1 Interneuron)
//--------------Written 8-5-08, modified 08-10-08
load_file("nrngui.hoc")          //load main NEURON library
cvode.active(0)     
    
////////////////////////////////////////////
////////////////////////////////////////////
//----------------------------------------Set parameters--------------------------------------------------------------//
tstop=800 //was 700 for AMPA
steps_per_ms=10
dt=0.1
celsius=34
//-------------------Set synaptic weights
ampaweightpr=	0.00013			//Initial stimulus
nmdaweightpr=	0.00018			//Initial stimulus
ampaweight=	0.00019		//According to Wang(2008)
nmdaweight=	0.52//51//0.41			//ratio inmda/iampa in basal dendrites:1 (Wang,Gao,2008)
gabaweight=	6.9e-4 			//According to Woo(2007)
//gabaweightb=	0.654e-4
ampaweightin=	7.5e-4			//according to Wang,Gao,2009
nmdaweightin=	3.2e-4			//ratio inmda/iampa for interneuron *0.5(Wang,Gao,2009)
autogabaweight=	5.1e-4			//According to Bacci (2003) 
//------------------Set # of synapses
inmaxsyn=	90			//initial stimulation
maxsyn=		22	 //was5		//PC-PC connections
automaxsyn=	1			//autosynapses (one third, Lubke, 1996)
maxsyn1=	12			//IN-IN connections
maxsyn2=	2			//PC-IN connections (Thomson, 2007)
maxsyn3=	4			//IN-PC connections (Peters,2008,Tamas,1997,J.Physiology,Perez,Larkum,2006)

xopen("../../lib/basic-graphics.hoc")
xopen("../define_objects.hoc")
xopen("../RS1cell.hoc") 
xopen("incell.hoc")	
xopen ("net.hoc")                    	//load net structure


//------------------------------------Pharmacological procedures
fadp=1.117*0//0.5//0.23
proc sadp_soma() {
	forsec soma_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*fadp } 
		}}}
proc sadp_dend() {
	forsec dend_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*0.1*fadp} 
		}}}

//--------------------------------------Graphs
//for j=0, (nPcells-1) {addgraph_2("Pcells[j].soma.v(0.5)", 0,tstop, -70, 50)}
addgraph_2("Pcells[0].soma.v(0.5)", 0,tstop, -70, 50)
//addgraph_2("Pcells[5].soma.v(0.5)", 0,tstop, -70, 50)
addgraph_2("INcells[0].soma.v(0.5)", 0,tstop, -80, 50)
splot=new Shape()
//forsec Pcells[0].somatic {shape.color(2)}
//forsec Pcells[0].axonal {shape.color(5)}
//forsec Pcells[0].basal {shape.color(3)}
//forsec Pcells[0].apical {shape.color(6)}

//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//
//---For many experiments
strdef syscmd, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr 
//-----Variables
n=int(tstop/dt)
//-----Objects for record data
objref cv
cv=new CVode(0)
objref PCv[nPcells], PCi[nPcells], PCt[nPcells], INv[nINcells], INt[nINcells]
printf("DEBUG: PFC NEURONS No: %d\n",nPcells)
printf("DEBUG: INTERNEURONS No: %d\n",nINcells)
strdef temp
objref vsoma1, vsoma2, vsoma3, vsoma4, insoma, insomab, curampa, curnmda, curgabaa, curgabab, DendDist, Params
objref campa[maxsyn], ct[8][inmaxsyn], cnmda[maxsyn], cnmdat[inmaxsyn], cgabaa[maxsyn3], campaa[automaxsyn], cnmdaa[automaxsyn], campain[inmaxsyn], cnmdain[inmaxsyn], cgabaat[maxsyn3], cgabab[maxsyn3], cgababt[maxsyn3], ampac, nmdac, gabaac, gababc	
objref gababweights, nmdaweights, adpweights
//----record total cell population spike activity
objref timevec, idvec, recncs, tobj, nil, total_activity
xopen("values_gabaweight.hoc")
xopen("values_nmda.hoc")
xopen("values_adp.hoc")


//---------------------------------Procedure for various checks------------------------------------------------//
objref r1
//r1=new Random(0)
//PID1=r1.uniform(0,1)
//rsid = new Random(1)	
objref conpyr1pyr2[100], nconpyr1pyr2[100], ampapyr1pyr2[100], nmdapyr1pyr2[100]
ns2=new NetStim(0.5)
ns2.interval=50 //(in ms!!!)// 20ms in NMDA SPIKES
ns2.number=1
ns2.start=0
ns2.noise=0
init_TAU1 = 90//90
init_TAU2 = 7.75//5
init_ALPHA = 10//10
init_BETA = 0.1//0.61
TAU1 = init_TAU1
TAU2 = init_TAU2 
ALPHA = init_ALPHA
BETA = init_BETA

proc later() {
r1=new Random(1)
rsid = new Random(2)
// Create synapses at random basal dendrites:
for cn=0, (nPcells-1) { //for current cell
	forsec Pcells[cn].basal { //access cell from template!
		//print secname()
		auxilist_basal[cn].append( new SectionRef() )
		//print L
	}
	//printf("DEBUG: NoSynapses: %d...\n", maxsyn)
	random_basal[cn].remove(random_basal[cn])
	
	for cs=0, 4{ //for c5 dends
		num = rsid.uniform(0,auxilist_basal[cn].count())
		num = int(num)
		print num
		asec_basal = auxilist_basal[cn].o(num)
		asec_basal.sec random_basal[cn].append()
		//printf("DEBUG: Choosing synapse No %d ...\n", cs)
	}	
	
	auxilist_basal[cn].remove_all()	

		cs=0
		forsec random_basal[cn] {
			PID = r1.uniform(0,1)
			print PID
			ampa[cn][cs] = new GLU(PID)
			nmda[cn][cs] = new nmda_segev(PID)
			splot.point_mark(ampa[cn][cs],cn+1) //colorize

			//DO NOT CONNECT AMPA in NMDA VClamp!!!!!
			/*
			nc3[cn][cs]=new NetCon(ns2, ampa[cn][cs])
			nc3[cn][cs].delay=500
			nc3[cn][cs].weight=0.00015//0.000065//*11
			nc3[cn][cs].threshold=-20
			*/
			nc4[cn][cs]=new NetCon(ns2, nmda[cn][cs])
			nc4[cn][cs].delay=500
			nc4[cn][cs].weight=0.37//0.025//.000065*35//*0.1
			nc4[cn][cs].threshold=-20
			

			nmda[cn][cs].tau1 = ($1)
			nmda[cn][cs].tau2 = ($2)
			ampa[cn][cs].Alpha =($3)
			ampa[cn][cs].Beta = ($4)

			cs = cs+1
		}
	}

}

proc Kblock(){
forall{
for(x){
	fk=0
	//if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	//den mplokarontai apo tous blockers tou Kaliou!
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	//if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }} 
	//if(ismembrane("mykca")) { for(x) {  gk_mykca(x)= gk_mykca(x)*fk }} 
	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
	if(ismembrane("can")) for(x) {  gcalbar_can(x)= gcalbar_can(x)*0 }
	if(ismembrane("cat")) for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*0 }			
	if(ismembrane("cal")) for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*0 }
	//if(ismembrane("calc")) for(x) {  gcabar_calc(x)= gcabar_calc(x)*0 }
	if(ismembrane("car")) for(x) {  gcabar_car(x)= gcabar_car(x)*0 }
	}}}
	
	


proc pyr1pyr2 () {
	for j=0, (23) { //26
PID1=0.5
INcells[0].soma ampapyr1pyr2[j]=new GLU(PID1)
//INcells[0].soma nmdapyr1pyr2[j]=new NMDA(PID1)

Pcells[1].axon conpyr1pyr2[j] = new NetCon(&v(1), ampapyr1pyr2[j], -20, 1.5, ampaweightin)
//Pcells[1].axon nconpyr1pyr2[j] = new NetCon(&v(1), nmdapyr1pyr2[j], -20, 1.5, ampaweightin*0.6)
}}
	
//--------------------------------------------------------------IClamp
proc IClump() {
amp=0.25//(nA)
Pcells[0].soma ic1=new IClamp(0.5)
ic1.del=100
ic1.dur=500
ic1.amp=amp
}

//--------------------------------------------------------------Vclamp
objref vc, vcdend
proc vclamp() {
access Pcells[0].soma
vc = new VClamp(0.5)
access Pcells[0].soma 
vc.amp[0]= 60 //NMDA 60//AMPA -70
vc.dur[0]=tstop
/*vc.amp[1]=10
vc.dur[1]=1
vc.amp[2]=-70
vc.dur[2]=100*/
}

//-----------------------------------Pharmacological procedures

//-------------------------------------------Graphs
//xopen("../bash_templates/basic-graphics.hoc") 	

for j=0, (nPcells-1) {
addgraph_2("Pcells[j].soma.v(0.5)", 0,tstop, -70, 50)
}

/////////////////////////////////
//-----------------------------------------------------Multiple Runs
n=int(tstop/dt)
objref cv
cv=new CVode(0)
objref PCv[nPcells]
objref PCi[nPcells]
objref PCt[nPcells]
objref INv[nINcells]
objref INt[nINcells]
strdef temp, tmpstr
objref vsoma1, vsoma2, vsoma3, vsoma4, insoma, curampa, curnmda, curgabaa, curgabab
objref campa[maxsyn+automaxsyn], campat[maxsyn+automaxsyn], cnmda[maxsyn+automaxsyn], cnmdat[maxsyn+automaxsyn], cgabaa[maxsyn3], cgabaat[maxsyn3], cgabab[maxsyn3], cgababt[maxsyn3], ampac, nmdac, gabaac, gababc, generalfile	


for Fincrement = 1,1{
for runs = 0, 0 {

//--------------------------------------Call procedures


//stimulation(runs,0)
//pyramidals()
//interneurons(runs)
//pyrin()
//inpyr()
//noise(runs)
//later(TAU1, TAU2, ALPHA, BETA)
//pyramidals()
//vclamp()
IClump()
//pyr1pyr2()
sadp_soma()
sadp_dend()
//ttx()
//ttxin()
//calcium_block()
//validateNMDA()
//Kblock() //for NMDAs
//------------------------------------initialize and run
//addgraph_2("nmdapr[0][0].iNMDA",0,tstop,-1,1)
//addgraph_2("ampal[0][0].i",0,tstop,-1,1)
//addgraph_2("nmdal[0][0].i",0,tstop,-1,1)
//addgraph_2("vc.i",0,tstop,0, -0.5)

//-------------------------------------Record & Save data data
run()
} 
}

//That's the end!

