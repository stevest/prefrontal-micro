//--------------Set parameters and run this for the net (generated from MATBAL scripts)
//--------------Written 1/8/13 Stefanos
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
cvode.active(0)	     //Do NOT use CVODE solver!
cvode.use_long_double(1)
cvode.cache_efficient(1)
//----------------------------------------Set parameters--------------------------------------------------------------//
// Numbers of cells
nPCcells=40
nPVcells=7
nCBcells=3
nCRcells=3
tstop=150
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
TOTALRUNS = 0
PLOT = 0
DEBUG = 0

//-------------------------------------------------------------
//Primary synapses (Xenia)
Stim_MaxSyn=200//120	//initial stimulation
PC2PC_MaxSyn=5//24 //Xenia had 24	//PC-PC connections Thomson 2007, (to have 87% excitatory synapses, Peters, 2008)
PC_MaxAutosyn=1//8 //Xenia had 8?!?	//autosynapses (one third, Lubke, 1996)
PV2PV_MaxSyn=12//1	//IN-IN connections
PC2PV_MaxSyn=2//12	//PC-IN connections (Thomson, 2007) (Markram, 2004sup2)
PV2PC_MaxSyn=13//15//Xenia had 15	//IN-PC connections to soma (Peters,2008,Tamas,1997,J.Physiology,Perez,Larkum,2006)(15-Tamas 1997, Markram 2004)
PC2CB_MaxSyn=14	//PC-CB connections - 8.2+-5 According to Markram, 2004 sup2
CB2PC_MaxSyn=12	+4+4 //CB-PC connections to d2- 11.2+-5 .5 According to Markram, 2004 sup2, Tamas, 1997 ~12.5

ampaweightin=	7.5e-4			//according to Wang,Gao,2009
nmdaweightin=	3.2e-4			//ratio inmda/iampa for interneuron *0.5(Wang,Gao,2009)
autogabaweight =	0.0073*0.85	//0.00073*11		//0.0073*0.75	xenia//According to Bacci (2003) validated 31/05/2010
gabaweight_pv2pc_a = 6.9e-4 *0.3	//0.00075 kiki		//According to Woo(2007)
gabaweight_pv2pc_b = gabaweight_pv2pc_a 	* 0.7//STEFANOS
ampaweight_pc2cb = 0.000029		//Angulo/Wang validated 28/05/2010
nmdaweight_pc2cb = ampaweight_pc2cb*0.86		//Wang validated me 50 pyrcb synapses gia ratio 0.8 28/05/2010
gabaweight_cb2pc = 0.0006*1.5          *0.3        	//cb-pc connections - according to Xiang, 2009


//--------------------Background activity 
objref vstim[nPCcells][500]
objref ampaBG[nPCcells][500]
objref VSvector[nPCcells][500]
objref BG1[nPCcells][500]
//PC-PC connections
//autosynapses
objref autoampaOnPC[nPCcells][PC_MaxAutosyn]
objref autonmdaOnPC[nPCcells][PC_MaxAutosyn]
objref conautoampaPC2PC[nPCcells][PC_MaxAutosyn]
objref conautonmdaPC2PC[nPCcells][PC_MaxAutosyn]
//recurrent synapses
objref ampaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref nmdaOnPC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref conampaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
objref connmdaPC2PC[nPCcells][nPCcells][PC2PC_MaxSyn]
//PV-PV connections
objref gabaOnPV_A[nPVcells][nPVcells][PV2PV_MaxSyn]
objref congabaPV2PV_A[nPVcells][nPVcells][PV2PV_MaxSyn]
//PC-PV connections
objref ampaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref nmdaOnPV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref conampaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]
objref connmdaPC2PV[nPCcells][nPVcells][PC2PV_MaxSyn]
//--------------------PV-PC connections
objref gabaOnPC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref gabaOnPC_B[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_A[nPVcells][nPCcells][PV2PC_MaxSyn]
objref congabaPV2PC_B[nPVcells][nPCcells][PV2PC_MaxSyn]
//PC-CB connections
objref ampaOnCB[nPCcells][nCBcells][PC2CB_MaxSyn]
objref nmdaOnCB[nPCcells][nCBcells][PC2CB_MaxSyn]
objref conampaPC2CB[nPCcells][nCBcells][PC2CB_MaxSyn]
objref connmdaPC2CB[nPCcells][nCBcells][PC2CB_MaxSyn]
//--------------------CB-PC connections
objref gabaOnPC_CB_A[nCBcells][nPCcells][CB2PC_MaxSyn]
objref congabaCB2PC_A[nCBcells][nPCcells][CB2PC_MaxSyn]


//-----Objects for record data
objref cv
cv=new CVode(0)
objref PCv[nPCcells], PCt[nPCcells], PVv[nPVcells], PVt[nPVcells]

objref PC
strdef sout
if (name_declared("PARALLEL")!=5) { // PARALLEL has not been assigned a numerical value from command line
	PARALLEL = 0 //Default single core
}
if(PARALLEL){
	PC=new ParallelContext()
	if(PC.id==0){printf("Microcircuit running in %d CORES !\n\n", PC.nhost)}
}else{
	printf("Microcircuit running in 'SINGLE CORE' !\n\n")
}

// given a cell index ($1) and the type of cell ($2), return the gid
// As for $2, 0 stands for pyramidal cells, 1 for PVs, 2 for CBs, and 3 for CRs
objref offsets
{offsets = new Vector()}
{offsets.append(0,nPCcells,nPVcells,nCBcells,nCRcells)}
{offsets.append(offsets.sum(0,offsets.size()-1))}
//global_gid=offsets.v[offsets.size()-1]  // points to the next available gid
func ind2gid(){local i  
  if(numarg()<2) { printf("wrong number of arguments to func ind2gid") }
  i=$1+offsets.sum(0,$2)
  if(i>=offsets.sum(0,$2+1)) { i-=1 }   
  return i 
}

// register the connection target locally given a synapse gid and a synapse mechanism as arguments
// if given additional arguments, it will set them as weight, delay, and threshold, respectively
// http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2158
obfunc makeSynapse(){ localobj nc, src
	if(PARALLEL){
		nc=PC.gid_connect($3,$o4)
	
	}else{
		src = $o1
		access src.o($2).axon
		nc = new NetCon(&v(x),$o4)
	}
	nc.threshold = $5
	nc.delay = $6
	nc.weight = $7
	return nc
}

func gid2local(){local i localobj arg
	arg = $o1
	for i=0, arg.size()-1 {
		if(arg.x(i) == $2){
			return i
		}
	}
	return -1 //if error
}

//Define objects and stirings used in the hoc files....
init_of_objects=300

//For intial parameters
strdef accstr, tmpstr, tmp_str, cell_name  

//For membrane noise, Random processes
//objref w[10][init_of_objects], sinw[init_of_objects]
objref w[init_of_objects], sinw,rpid, rsid, rtid 

//---For synaptic stimulation
//Basal
objref auxlist_basal, original_list_basal, cluster_list_basal, asec_basal
objref ampab[init_of_objects], nmdab[init_of_objects], conampab[init_of_objects], connmdab[init_of_objects]

//proximal-Apical(<200)
objref auxlist_proximal, original_list_proximal, cluster_list_proximal, asec_proximal
objref ampap[init_of_objects], nmdap[init_of_objects], conampap[init_of_objects], connmdap[init_of_objects]

//distal-Apical(>200)
objref auxlist_distal, original_list_distal, cluster_list_distal, asec_distal
objref ampad[init_of_objects], nmdad[init_of_objects], conampad[init_of_objects], connmdad[init_of_objects]

//---For graphics
objref splot, shape

//Define objects for recording
objref vsoma
strdef temp, data_dir
objref somaref

objref pidData

// RS1 cell:
//Template for layer V prefrontal pyramidal neurons

func num2ind(){ // a mapping from numbers to morphology file indices
    return ($1 % 56)
}

begintemplate PCcell
external PARALLEL,PLOT,DEBUG

create soma[1], axon[7], dend[50], apic[27] 
public gid
public ApicNo, DendNo //OBJECT: properties of the cell
public position, x, y, z

public all, somatic, axonal, basal, apical, soma, axon, dend, apic

public PCsoma_list ,PCbasal_list,PCapical_list ,PCdend_list ,PCcell_list, cell0_list
objref all, somatic, axonal, basal, apical

strdef sectype
objref CAN_temp, CAL_temp, CAT_temp, KAD_temp, KAP_temp, NA_temp

// Initializing Procedure:
proc init() {
	create soma[1], axon[7], dend[50], apic[27] 

	if(PARALLEL){gid=$1}
	x = y = z = 0 // only change via position

	maximum_segment_length=75
	if(1){printf("loading morphology from file %s\n",$s2)}
	xopen($s2)

	//OBJECT: properties of the cell
	//MUST BE INITIALIZED !!!
	ApicNo=0
	DendNo=0
	max_ar2=0
	min_ar2=0
	decay_start=0   
	decay_end=0

	// Set passive membrane properties
	Rm_default=30000 
	Rm_dend=15000
	Ra_default= 100	//MARIA 210	
	Cm_default = 1.2	
	Cm_dend = 2.0
	v_init = -66

	// SEVERELY affects experiment results  

	cut_sections(maximum_segment_length)

	// Set initial conductance values 

	//Sodium - Potassium properties
	gna_default = 0.031 	 //STEFANOS
	gkdrbar_default=0.045      //*0.12//STEFANOS :DONG, WHITE, 2003 

	//Calcium currents
	soma_caN = 0.3e-4        //STEFANOS
	soma_caL = 3e-4 //20
	soma_car = 3e-5*25  *0.5 //FOR RS	//MARIA 3e-5
	soma_caT = 1e-5*10 //MARIA 1e-5	

	//Calcium activated K+ currents
	soma_kca =   0.005*5*0.5      //*3.5//STEFANOS:villalobos 2005 //*6 	//MARIA 0.025	
	mykca_init = 0.006*5*0.001  //* 0.1//STEFANOS EDIT    //MARIA 0.003

	//Potassium current

	kad_init =  0.00075*1.2    //*8 //STEFANOS:DONG,WHITE,2003  //MARIA 0.00075 	 	
	soma_kdBG =  0.0012*4.4      //*0.003 //STEFANOS:DONG,WHITE,2003  //MARIA 0.0012
	soma_hbar =  1.872e-5*0.5    	//MARIA 1.872e-5

	//Persistent sodium
	soma_nap =  1.2e-5  *0.5      //for RS  //MARIA 1e-5
	//----------------------------------------------------------------------------    
	//for sadp induction	  
	gCAN = 0.0001 	 		 	
	//=====================================================================================
 
	
	forsec somatic {
		nseg = 3//21

		insert pas    // leak conductance
		g_pas =  1/Rm_default
		e_pas = v_init
		Ra    = Ra_default *1.35
		cm = Cm_default
		
		insert h     // h current 
		gbar_h  = soma_hbar
		K_h     = 8.8
		vhalf_h = -82

		insert Naf
		gnafbar_Naf = gna_default*5 
		insert kdr
		gkdrbar_kdr = gkdrbar_default

		insert kad  // proximal A current  
		gkabar_kad = kad_init

		insert cal 
		gcalbar_cal=soma_caL   // suspect

		insert can
		gcalbar_can=soma_caN   // suspect

		insert kca
		gbar_kca = soma_kca

		insert mykca 
		gkbar_mykca = mykca_init

		insert cad

		insert Ks
		gKsbar_Ks = soma_kdBG

		insert cat 
		gcatbar_cat = soma_caT 

		insert car
		gcabar_car=soma_car  // suspect
		insert nap	
		gnabar_nap=soma_nap*0.1

		insert ican  
		gbar_ican  = gCAN // suspect
	}

	forsec axonal {
		nseg=3//5

		insert Naf
		gnafbar_Naf = gna_default*10
		insert kdr
		gkdrbar_kdr = gkdrbar_default  
		insert pas  // leak conductance
		g_pas       = 1/Rm_default
		e_pas       = v_init
		Ra          = Ra_default
		cm          = Cm_default

		//$o1.tmpo2.color(1)

		//MARIA:
		
		//insert kad  
		//gkabar_kad     = kad_init*10
		//insert Ks
		//gKsbar_Ks = soma_kdBG
		
	}

	access soma
	distance()


	forsec apical {
		insert Naf
		gnafbar_Naf = gna_default*0.2 
		insert kdr 
		gkdrbar_kdr=gkdrbar_default*0.001   

		insert pas // leak conductance

		e_pas          = v_init                 
		Ra             = Ra_default*0.5	//MARIA Ra_default
		cm             = 1.2  
		Rm_sigmoid_apical()         	 

		//add ICAN  in dendrites but smaller
		insert ican
		gbar_ican  = gCAN*0.1

		apical_mechanisms()   

		// Set the Na+ spike attenuation variable (linearly decreasing from soma to 300 um)
		max_ar2=0.95
		min_ar2=0.30
		decay_end=300.0
		decay_start=50.0
		m_ar2 = (max_ar2 - min_ar2)/(decay_start - decay_end)
		for (x) {
			xdist = distance(x)
			if (xdist < decay_start) { 
				ar2_Naf(x) = max_ar2 
			} else if (xdist > decay_end) {               
				ar2_Naf(x) = min_ar2 
			} else {               
				ar2_Naf(x) = max_ar2 + m_ar2*xdist
			}
		}
	}

	access soma
	distance()


	forsec basal {
		insert Naf
		gnafbar_Naf = gna_default*0.1
		insert kdr
		gkdrbar_kdr=gkdrbar_default*0.09  

		insert pas // passive properties
		e_pas          = v_init
		Ra             = Ra_default  
		cm             = Cm_dend
		Rm_sigmoid_basal()  

		//add ICAN  in dendrites but smaller
		insert ican
		gbar_ican  = gCAN*0.1

		// Set the Na+ spike attenuation variable (linearly decreasing from soma to 300 um)
		max_ar2=0.95
		min_ar2=0.30
		decay_end=50.0
		decay_start=20.0

		m_ar2 = (max_ar2 - min_ar2)/(decay_start - decay_end)
		for (x) {
			xdist = distance(x)
			if (xdist < decay_start) { 
				ar2_Naf(x) = max_ar2 
			} else if (xdist > decay_end) {               
				ar2_Naf(x) = min_ar2 
			} else {               
				ar2_Naf(x) = max_ar2 + m_ar2*xdist
			}
		}
	} 

	khbasal_fixed()
	forsec somatic { g_pas=1/Rm_default }

	forall {
		if (ismembrane("Naf")) {ena = 55}
		if (ismembrane("k_ion")) { ek = -85}

		if(ismembrane("ca_ion")) {
			eca = 140
			cai0_ca_ion =  2.4e-6 // for pump  
			cao = 2
			ion_style("ca_ion",3,2,1,1,1)
		}
	}

} //END INIT() PROC


proc cut_sections() {  
	forall {
		nseg=3//1+int(L/$1)
	}
}


proc khbasal_fixed() { local i,x,d

	forsec basal {
		//increase H along the basal dendrites	
		insert h //no gradient in somatosensory according to schiller
		gbar_h = soma_hbar
		insert kad
		insert can
		insert cad
		insert nap	
		gnabar_nap=soma_nap

		for (x) {  
			xdist = distance(x)
			fr = xdist/50
			if (xdist < 50) {        
				gcalbar_can(x) = soma_caN/30
				gkabar_kad(x) = kad_init*2 
			} else {
				gkabar_kad(x) = kad_init*5  
				gcalbar_can(x) = soma_caN*0.1
			}
		}
	}
}

proc Rm_sigmoid_apical() { local rm
	Rm_soma = Rm_default
	Rm_end=  Rm_default*0.5
	Rm_dhalf=300 //was 500
	Rm_steep=50

	for (x) {  
		xdist = distance(x)    
		rm = Rm_soma + (Rm_end - Rm_soma)/(1.0 + exp((Rm_dhalf-xdist)/Rm_steep))
		g_pas(x) = 1.0/rm
	}
}

proc Rm_sigmoid_basal() { local rm
	Rm_soma = Rm_default
	Rm_end=  Rm_default*0.5
	Rm_dhalf=10 
	Rm_steep=5

	for (x) {  
		xdist = distance(x)    // calc. path distance     
		rm = Rm_soma + (Rm_end - Rm_soma)/(1.0 + exp((Rm_dhalf-xdist)/Rm_steep))
		g_pas(x) = 1.0/rm
	}
}

proc apical_mechanisms(){
	//Insert h-current, sigmoidally increasing in the dendrites
	gh_soma=soma_hbar
	gh_end=soma_hbar*10
	H_dhalf=300
	H_steep=50

	for (x) {  
		xdist = distance(x)  //calc. perpedicular distance
		insert h
		gbar_h(x) = gh_soma + (gh_end - gh_soma)/(1.0 + exp((H_dhalf-xdist)/H_steep))
	}

	kap_distal_maxfactor=1
	kap_distal_distance=100
	kad_distal_maxfactor=0.1
	kad_distal_distance=300  

	//for cortical cell, data is up to 400um
	for (x) {  
		xdist=distance(x) + 0.0000001 //Division by zero...
		fr1= kad_distal_distance/xdist
		insert kad
		insert Ks


		if (xdist < kap_distal_distance ) {
			gkabar_kad(x) = kad_init*kap_distal_maxfactor
			gKsbar_Ks(x) = soma_kdBG*kap_distal_maxfactor  
		} else if (xdist < kad_distal_distance ) {
			gkabar_kad(x) = kad_distal_maxfactor*kad_init*fr1
			gKsbar_Ks(x) = soma_kdBG*kad_distal_maxfactor*fr1
		} else {
			gkabar_kad(x) = kad_distal_maxfactor*kad_init
			gKsbar_Ks(x) = soma_kdBG*kad_distal_maxfactor  
		}
	}


	insert cad    // calsium pump/buffering mechanism

	//insert calcium mechanisms and persistent sodium

	insert car	
	insert nap
	insert cal
	insert can
	insert cat
	insert kca
	insert mykca

	for (x) {  
		xdist = distance(x)
		fr = xdist/200 //+ 0.00000001 //ivision by zerooo

		if (xdist < 200) {                	
			gcabar_car(x) = soma_car*0.5 	
			gnabar_nap(x) = soma_nap
			gcalbar_can(x) = soma_caN/30
			gcalbar_cal(x) soma_caL
			gcatbar_cat(x) = soma_caT
			gbar_kca = soma_kca*0.1
			gkbar_mykca = mykca_init*0.05
		} else {
			gcabar_car(x) = soma_car*fr   
			gnabar_nap(x) = soma_nap*fr*5
			gcalbar_can(x) = soma_caN*fr*3.2
			gcalbar_cal(x) = soma_caL/(30*fr)
			gcatbar_cat(x) = soma_caT*fr  			
			gbar_kca = soma_kca*0.001
			gkbar_mykca = mykca_init *0.001
		}
	}
}

endtemplate PCcell

objref FL[1]
FL[0]=new String("simple.hoc")


objref PCcells, PCgids
PCcells=new List()
PCgids=new Vector()
strdef filename,basename
basename="../../morphology/smith_new_axon/"
proc createPyrs(){ local i,host,gid localobj cell,mynil
	if(PARALLEL){
	{PC.barrier()}
	if(PC.id==0) {printf("initializing PCs...\n") }     
	for i=0,nPCcells-1{ //(i=PC.id;i<nPcells;i+=PC.nhost) { 
	host=i%PC.nhost
	gid=ind2gid(i,0)

	if(host==PC.id){
	PCgids.append(gid)  

	//sprint(filename,"%s%s",basename,FL[num2ind(int(PcellIDlist.x[i]))].s)
	sprint(filename,"%s%s",basename,FL[0].s)      
	print "@ ",host, "GID ", gid, " Creating morph:"     
	cell = new PCcell(gid,filename)
	//cell.position((i+.5)*len/nPCcells, 0, 0)
	PC.set_gid2node(gid,PC.id)
	cell.axon {//synapse_source(gid)//,&v(1))
	PC.cell(gid,new NetCon(&v(1), mynil),1)
	}  
	PC.threshold(gid,-20)          
	PCcells.append(cell)  
	}    
	}
	}else{
		for i = 0, (nPCcells-1) {
			//sprint(filename,"%s%s",basename,FL[num2ind(int(PcellIDlist.x[i]))].s)
			sprint(filename,"%s%s",basename,FL[0].s)  
			cell = new PCcell(i,filename)
			PCcells.append(cell) 
			PCgids.append(i)
		}
	}

}

createPyrs()

//Create a list with segments for all neurons
objref PCsoma_list, PCbasal_list, PCapical_list, PCdend_list, PCcell_list, cell0_list

PCsoma_list = new SectionList()
PCbasal_list = new SectionList()
PCapical_list = new SectionList()
PCdend_list = new SectionList()
PCcell_list = new SectionList()
cell0_list=new SectionList()


for i=0, PCcells.count()-1 {

	PCcells.o(i).soma PCsoma_list.append()
	PCcells.o(i).DendNo=0
	forsec PCcells.o(i).basal {
		PCbasal_list.append()  
		PCdend_list.append()
		PCcells.o(i).DendNo+=1 
	}

	PCcells.o(i).ApicNo=0
	forsec PCcells.o(i).apical {
		PCapical_list.append()  
		PCdend_list.append()
		PCcells.o(i).ApicNo+=1 
	}
	forsec PCcells.o(i).all {
		PCcell_list.append()
	}

}

proc current_balance() {
	finitialize($1)
	print $1
	fcurrent()	
	forsec PCcell_list {
		for (x) {
			if (ismembrane("na_ion")) {e_pas(x)=v(x)+ina(x)/g_pas(x)} 
			if (ismembrane("k_ion")) {e_pas(x)=e_pas(x)+ik(x)/g_pas(x)} 
			if (ismembrane("ca_ion")) {e_pas(x)=e_pas(x)+ica(x)/g_pas(x)}
			if (ismembrane("in_ion")) {e_pas(x)=e_pas(x)+in(x)/g_pas(x)} //ican
			if (ismembrane("h")) {e_pas(x)=e_pas(x)+ihi(x)/g_pas(x)}

			fcurrent()
		}
	}
	fcurrent()
	if (cvode.active()) {
		cvode.re_init()
	}else {
		fcurrent()
	}
	frecord_init()
}
{current_balance(v_init)}


//PV cells
begintemplate PVcell
external PARALLEL

public position, x, y, z
public soma, axon, dend
create soma, axon, dend

proc init() {
x = y = z = 0 // only change via position

if(PARALLEL){gid=$1}

create soma, axon, dend

soma_nafin=0.045*3//*0.025//0.055*3
soma_kdrin=0.018*2//*0.028//0.0018*2
soma_Kslowin=0.000725*0.1//*0.00006*0.1//0.000725*0.1
soma_hin=0.00001//*
soma_kapin=0.0032//*0.001
soma_canin=0.0003//*
soma_kctin=0.0001
soma_kcain=20*0

soma {
     nseg=1
     L=27//42
     diam=29//42

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/10000//1/30000// //mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initin//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initin= -73
	Ra=150 

     insert Nafx
     gnafbar_Nafx= soma_nafin

     insert kdrin
     gkdrbar_kdrin= soma_kdrin

     insert IKs	
     gKsbar_IKs= soma_Kslowin

     insert hin
     gbar_hin=soma_hin

     insert kap
     gkabar_kap=soma_kapin

     insert can
     gcalbar_can=soma_canin

     insert mykca
     gkcbar_mykca=soma_kctin

     insert kcain
     gbar_kcain=soma_kcain

     insert cadynin

}

axon {
	nseg=1
	L=115//113.22 
	diam=1.5//1.1
	

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/10000//1/10000//mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initin//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initin= -73
	Ra=150 

	insert Nafx
	gnafbar_Nafx=soma_nafin*10//0.025*10 

	insert kdrin
	gkdrbar_kdrin=soma_kdrin*0.5//0.0018
}

dend {
	nseg=1
	L=22//20
	diam=7//5


	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/10000//1/30000//mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initin//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initin= -73
	Ra=150

	insert Nafx
	gnafbar_Nafx=0.018*5//soma_nafin*0.1

	insert kdrin
	gkdrbar_kdrin=0.018*0.5//soma_kdrin*0.1

     	insert kap
    	gkabar_kap=soma_kapin*10

}


	ko0_k_ion = 3.82   //mM
 	ki0_k_ion = 140    //mM
	//celsius   = 34//23 changed due to issues in parallel code
	connect axon(0), soma(0.5)
	connect dend(0), soma(0) 
}

endtemplate PVcell


//Creating new PV interneurons
objref PVcells, PVgids
PVcells = new List() 
PVgids=new Vector()

proc createPVs(){local i,host,gid localobj cell,mnil
	if(PARALLEL){
		{PC.barrier()}
		  if(PC.id==0) { printf("initializing %d PVs...\n",nPVcells) }
		    for i=0,(nPVcells-1){ //(i=PC.id;i<nPcells;i+=PC.nhost) { 
		      host=i%PC.nhost
		      gid=ind2gid(i,1)
		      if(host==PC.id){
			 PVgids.append(gid)  
			cell = new PVcell(gid)
			//cell.position((i+.5)*len/nPVcells, -100, 0)  // equal spacing of interneurons. Ignores clustering effects     
			PC.set_gid2node(gid,PC.id)
			cell.axon {//synapse_source(gid)//,&v(1))
			  PC.cell(gid,new NetCon(&v(1), mnil),1)
			}        
			PC.threshold(gid,-20)          
			PVcells.append(cell)      
		      }  
		  }

	}else{
		for i = 0, nPVcells-1 {
			cell = new PVcell(i)
			PVcells.append(cell)
			PVgids.append(i)
		}
	}
}

createPVs()

//Create list with segments
objref PVsoma_list
PVsoma_list = new SectionList()


for i=0,PVcells.count()-1 {		
	PVcells.o(i).soma PVsoma_list.append() 
}

proc current_balancePV() {
  finitialize($1)
  fcurrent()
  forsec PVsoma_list {
    for (x) {
    	if (ismembrane("na_ion")) {e_pas(x)=v(x)+ina(x)/g_pas(x)} 
   	if (ismembrane("k_ion")) {e_pas(x)=e_pas(x)+ik(x)/g_pas(x)} 
      	if (ismembrane("ca_ion")) {e_pas(x)=e_pas(x)+ica(x)/g_pas(x)}     
       	if (ismembrane("h")) {e_pas(x)=e_pas(x)+ihi(x)/g_pas(x)}
    }
  }
}
{current_balancePV(-70) }

//CB cells
begintemplate CBcell
external PARALLEL

public position, x, y, z
public soma, axon, dend, gid

create soma, axon, dend

proc position() { local i // taken from Migliore 2010
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
  }
  x = $1  y = $2  z = $3
}


proc init () {
if(PARALLEL){gid=$1}
x = y = z = 0 // only change via position

create soma, axon, dend

soma_nafcb=0.075 //0.018 (Fast Na+ channel, added the 's' attenuation system from hha2.mod)
soma_kdrcb=0.018 //0.018//0.09 (Delayed rectifier K+ channel)
soma_Kslowcb=0.000725*0//0.4315//0.000725 (to krataw miden simfwna me anafora Toledo-Rodriguez, 2004 gia ta cluster)
soma_hcb=0.000002 //0.000025 // (H-current that uses Na ions)
soma_kapcb=0.007*5 //0.007 // (K-A channel)
soma_iCcb=0.00001*0 //(to krataw miden  simfwna me anafora Toledo-Rodriguez, 2004 gia ta cluster)
soma_calcb=100*0//(to krataw miden simfwna me anafora Toledo-Rodriguez, 2004 gia ta cluster)
soma_catcb=0.003 // (t-type calcium channel with low threshold for activation used in somatic and dendritic regions)

soma {
     nseg=1
     L=42 //10 //(15.5+-2.5-Kawaguchi k Kubota, 1993)
     diam=42 //13 (11+-1.7 - Kawaguchi k Kubota, 1993)


	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/40000//(klairy)1/58000//1/14000//mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initcb//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initcb= -64
	Ra=150 



     insert Nafx
     gnafbar_Nafx= soma_nafcb

     insert kdrcb //delayed rectifier potassium current
     gkdrbar_kdrcb= soma_kdrcb

     insert IKscb	//slowly inactivating potassium (D-type?)
     gKsbar_IKscb= soma_Kslowcb

     insert hcb
     gbar_hcb= soma_hcb

     insert kapcb
     gkabar_kapcb= soma_kapcb

     insert iCcb //fast Ca2+/V-dependent K+ channel
     gkcbar_iCcb= soma_iCcb

     insert calcb
     gcalbar_calcb= soma_calcb 

     insert catcb
     gcatbar_catcb=soma_catcb

     insert cadyn
}

axon {
	nseg=1
	L=113.22 //(horizontal axonal spread 710+-210 Kawaguchi, 1993)
	diam=1.1

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/40000//1/14000//mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initcb//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initcb= -64
	Ra=150 
	
	insert Nafx
	gnafbar_Nafx= soma_nafcb*10

	insert kdrcb
	gkdrbar_kdrcb= soma_kdrcb*0.5
}

dend {
	nseg=1
	L=22
	diam=7


	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/40000//1/14000//mho/cm2   (oso anevazw ton paranomasti anevainei to input resistance)
	e_pas = v_initcb//(Kawaguchi k Kubota, 1993 --> -73+-3.9)
	v_initcb= -64
	Ra=150 
	
	insert Nafx
	gnafbar_Nafx=0.018

	insert kdrcb
	gkdrbar_kdrcb=0.018*0.5

  	insert kapcb
     	gkabar_kapcb=0.00875


}

	ko0_k_ion = 3.82   //mM
 	ki0_k_ion = 140    //mM
	//celsius   = 23 it is necessary? when different than initial -> different results than the parallel
	connect axon(0), soma(0.5)
	connect dend(0), soma(0)
	
 	//xopen("../bash_templates/current-balancecb.hoc")
	//current_balancecb(v_initcb)  
}

endtemplate CBcell

//Creating new interneurons
objref CBcells, CBgids
CBcells = new List() 
CBgids=new Vector()
proc createCBs(){local i,gid_offset localobj cell,mynil
	if(PARALLEL){
		{PC.barrier()}
		  if(PC.id==0) {printf("initializing CBs...\n")   }   
		    for i=0,nCBcells-1{ //(i=PC.id;i<nPcells;i+=PC.nhost) { 
		      host=i%PC.nhost
		      gid=ind2gid(i,2)
		     
		      if(host==PC.id){
			 CBgids.append(gid)
			cell = new CBcell(gid)
			//cell.position((i+.5)*len/nCBcells, -100, 0)  // equal spacing of interneurons. Ignores clustering effects     
			PC.set_gid2node(gid,PC.id)
			cell.axon {//synapse_source(gid)//,&v(1))
			  PC.cell(gid,new NetCon(&v(1), mynil),1)
			}   
			PC.threshold(gid,-20) 
			CBcells.append(cell)
		      }    
		  }
	}else{
		for i = 0, nCBcells-1 {
			cell = new CBcell()
			CBcells.append(cell)
			CBgids.append(i)
		}
	}
}

createCBs()

//Create list with segments
objref CBsoma_list, CBcell_list
CBsoma_list = new SectionList()
CBcell_list = new SectionList()

for i=0,CBcells.count()-1{
	CBcells.o(i).soma CBsoma_list.append()
	CBcells.o(i).soma CBcell_list.append()
	CBcells.o(i).axon CBcell_list.append()
	CBcells.o(i).dend CBcell_list.append()
}

proc current_balanceCB() {

  finitialize($1)
  fcurrent()
  forsec CBcell_list{
   for (x) {
    	if (ismembrane("na_ion")) {e_pas(x)=v(x)+ina(x)/g_pas(x)} 
   	if (ismembrane("k_ion")) {e_pas(x)=e_pas(x)+ik(x)/g_pas(x)} 

      	if (ismembrane("ca_ion")) {e_pas(x)=e_pas(x)+ica(x)/g_pas(x)}
        if (ismembrane("in_ion")) {e_pas(x)=e_pas(x)+in(x)/g_pas(x)} //ican
       if (ismembrane("h")) {e_pas(x)=e_pas(x)+ihi(x)/g_pas(x)}
    }
  }
fcurrent()
}

{current_balanceCB(-64) } 

/*
//CR cells
begintemplate CRcell
external PARALLEL

public position, x, y, z
public soma, axon, dend, gid

create soma, axon, dend[2]

proc position() { local i
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
  }
  x = $1  y = $2  z = $3
}

proc init () {
if(PARALLEL){gid=$1}
x = y = z = 0 // only change via position

create soma, axon, dend[2]

soma_nafcr=0.015
soma_kdrcr=0.018 
soma_Kslowcr=0.000725
soma_iCcr=0.00003
soma_kadcr=0.003
soma_cancr=0.001

soma {
	nseg=1
	L=27
	diam=27

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/20000
	e_pas = v_initcr
	v_initcr= -70
	Ra=150 



	insert Nafcr
	gnafbar_Nafcr= soma_nafcr

	insert kdrcr
	gkdrbar_kdrcr= soma_kdrcr

	insert IKscr
	gKsbar_IKscr= soma_Kslowcr

	insert iCcr
	gkcbar_iCcr= soma_iCcr

	insert kadcr
	gkabar_kadcr= soma_kadcr

	insert cancr
	gcatbar_cancr=soma_cancr

	insert cadyn
}

axon {
	nseg=1
	L=113.22 //(horizontal axonal spread 710+-210 Kawaguchi, 1993)
	diam=1.1

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/20000
	e_pas = v_initcr
	v_initcr= -70
	Ra=150 
	
	insert Nafcr
	gnafbar_Nafcr= soma_nafcr*10

	insert kdrcr
	gkdrbar_kdrcr= soma_kdrcr*0.5
}

dend[0] {
	nseg=1
	L=22
	diam=7

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/20000
	e_pas = v_initcr
	v_initcr= -70
	Ra=150 

	insert Nafcr
	gnafbar_Nafcr=0.018*5

	insert kdrcr
	gkdrbar_kdrcr=0.018*0.5
}

dend[1] {
	nseg=1
	L=22
	diam=7

	//insert kdyn
	insert pas
	cm=1.2            //microF/cm2
	g_pas =1/20000
	e_pas = v_initcr
	v_initcr= -70
	Ra=150 

	insert Nafcr
	gnafbar_Nafcr=0.018*5

	insert kdrcr
	gkdrbar_kdrcr=0.018*0.5
}


	ko0_k_ion = 3.82   //mM
 	ki0_k_ion = 140    //mM
	//celsius   = 23 it is necessary? when different than initial -> different results than the parallel

	connect dend[0](0), soma(0)
	connect dend[1](0), soma(1)
	connect axon(0), soma(0.5)
	
 	//xopen("../bash_templates/current-balancecr.hoc")
	//current_balancecr(v_initcr) 
}

endtemplate CRcell

//Creating new interneurons
objref CRcells, CRgids
CRcells = new List() 
CRgids=new Vector()
proc createCRs(){local i,gid_offset localobj cell,nil
if(PARALLEL){
	{PC.barrier()}
	if(PC.id==0) {printf("initializing CRs...\n")  }    
	for i=0,nCRcells-1{ //(i=PC.id;i<nPcells;i+=PC.nhost) { 
		host=i%PC.nhost
		gid=ind2gid(i,3)

		if(host==PC.id){
				CRgids.append(gid)
			//        if(PC.id==0) { printf("initializing IN %d\n",i)  }
			cell = new CRcell(gid)
			//cell.position((i+.5)*len/nCRcells, -100, 0)  // equal spacing of interneurons. Ignores clustering effects     
			PC.set_gid2node(gid,PC.id)
			cell.axon {//synapse_source(gid)//,&v(1))
			PC.cell(gid,new NetCon(&v(1), nil),1)
		}   
		PC.threshold(gid,-20) 
		CRcells.append(cell)        
	}    
	}
}else{
	for i = 0, nCRcells-1 {
		cell = new CRcell()
		CRcells.append(cell)
		CRgids.append(i)
	}
}
}

createCRs()

//Create list with segments
objref CRsoma_list, CRcell_list

CRsoma_list = new SectionList()
CRcell_list = new SectionList()


for i=0,(CRcells.count()-1) {      
	CRcells.o(i).soma CRsoma_list.append()
	CRcells.o(i).soma CRcell_list.append()
	CRcells.o(i).axon CRcell_list.append()
	CRcells.o(i).dend CRcell_list.append()
}

proc current_balanceCR() {
  finitialize($1)
  fcurrent()

  forsec CRcell_list{
   for (x) {
    	if (ismembrane("na_ion")) {e_pas(x)=v(x)+ina(x)/g_pas(x)} 
   	if (ismembrane("k_ion")) {e_pas(x)=e_pas(x)+ik(x)/g_pas(x)} 

      	if (ismembrane("ca_ion")) {e_pas(x)=e_pas(x)+ica(x)/g_pas(x)}
        if (ismembrane("in_ion")) {e_pas(x)=e_pas(x)+in(x)/g_pas(x)} //ican
       if (ismembrane("h")) {e_pas(x)=e_pas(x)+ihi(x)/g_pas(x)}
    }
  }
fcurrent()
}

{current_balanceCR(-70) } 
*/

//NETWORK
objref nsAMPA[nPCcells][Stim_MaxSyn],nsNMDA[nPCcells][Stim_MaxSyn],ncAMPA[nPCcells][Stim_MaxSyn],ncNMDA[nPCcells][Stim_MaxSyn]
objref ampapr[nPCcells][Stim_MaxSyn], nmdapr[nPCcells][Stim_MaxSyn]


proc stimulation() { local i,j,PID,ApicalNo,rApicIdx,BasalNo,rBasalIdx, interval, number  localobj r,rApic,rBasal
interval = 50//50
number = 20

if(PARALLEL){ PC.barrier() }


r = new Random($1+165)
PID = r.uniform(0, 1)
rApic = new Random($1+12)
rBasal = new Random($1+67)

for i=0, PCcells.count() - 1  { 
	
	//Basal input:
	for j=(Stim_MaxSyn/2), (Stim_MaxSyn-1) {
		PID=0.5//r.repick()

		rBasalIdx = 0//int(rBasal.uniform(0,PCcells.o(i).DendNo-1))
		PCcells.o(i).dend[rBasalIdx] ampapr[i][j]=new GLU(PID)// sta apical!!!!!
		PCcells.o(i).dend[rBasalIdx] nmdapr[i][j]=new NMDA(PID)//nmda_segev(PID)

		nsAMPA[i][j]=new NetStim(0.5) //was 0.5
		nsAMPA[i][j].interval=interval
		nsAMPA[i][j].number=number
		nsAMPA[i][j].start=0
		nsAMPA[i][j].noise=0

		nsNMDA[i][j]=new NetStim(0.5) //was 0.5
		nsNMDA[i][j].interval=interval
		nsNMDA[i][j].number=number
		nsNMDA[i][j].start=0
		nsNMDA[i][j].noise=0

		ncAMPA[i][j]=new NetCon(nsAMPA[i][j], ampapr[i][j])
		ncAMPA[i][j].delay=50 //+ PID*2
		ncAMPA[i][j].weight = 0.162//ampaArr.x[PcellIDlist.x[PCgids.x(i)]]  //*0.7
		ncAMPA[i][j].threshold=-20 

		ncNMDA[i][j]=new NetCon(nsNMDA[i][j], nmdapr[i][j])
		ncNMDA[i][j].delay=50 //+ PID*2 
		ncNMDA[i][j].weight = 0.763//nmdaArr.x[PcellIDlist.x[PCgids.x(i)]]  *0.8                 
		ncNMDA[i][j].threshold= -20 
		//if(PLOT){splot.point_mark(nmdapr[i][j],2)} //colorize
	}	
}
} //end proc

proc clampStim() { local i,j,PID,ApicalNo,rApicIdx,BasalNo,rBasalIdx, interval, number  localobj r,rApic,rBasal
	duration = 500//50
	amplitude = 2

	if(PARALLEL){ PC.barrier() }
		for i=0, PCcells.count() - 1  { 
			PCcells.o(i).soma {nsAMPA[i][j]=new IClamp(0.5)} //was 0.5
			nsAMPA[i][j].dur=duration
			nsAMPA[i][j].amp=amplitude			
	}
} //end proc



// ---------------------------------PC-PC connections, basal dendrite(Thomson, 1997)------------------------------------//
proc connectPC2PC() { local i,j,FIDp,PID,BasalNo,rDendidx,synCtr,trg,src,syn,bool,localID,trgGID,srcGID localobj r,fp,rDend
	if(PARALLEL){ PC.barrier() }

	r = new Random($1 + 350)
	PID = r.uniform(0,1)
	fp = new Random($1+3)	
	rDend = new Random($1+4)
	//rDendidx = rDend.uniform(0,17)	
	FIDp=fp.normal(1.7,0.9)	//According to Thomson(2007)


	//--------------------------Create SectionReference list for basal dendrites---------------//
	// connect PC 2 PC with connectivity/weights from MATLAB:
	synCtr = 0
	for trg=0, nPCcells-1 { 
		for src=0,nPCcells-1 {
			//if(connMatrix.x[PCgids.x(src)][PCgids.x(trg)]){
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,0) //PC cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PCgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				for syn=0, (PC2PC_MaxSyn-1) { //for current syn
					PID=r.repick()
					FIDp=abs(fp.repick())
					if(FIDp<steps_per_ms){FIDp=steps_per_ms+1}

					rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
					//PCcells.o(localID).dend[rDendidx] ampaOnPC[src][trg][syn] = new GLU(PID)
					PCcells.o(localID).dend[rDendidx] nmdaOnPC[src][trg][syn] = new NMDA(PID)//nmda_segev(PID)

					//conampaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,ampaOnPC[src][trg][syn],-20,FIDp,0.1 )
					connmdaPC2PC[src][trg][syn] = makeSynapse(PCcells,src,srcGID,nmdaOnPC[src][trg][syn],-20,FIDp,0.1 )

					//if(PLOT){splot.point_mark(nmdaOnPC[src][trg][syn],4)} //colorize
					synCtr = synCtr+1 //because we have multiple cells
				}
			}
			//}
		}
		synCtr = 0
	}
} //END procedure initPC


//---------------------------------------------PV-PV connections--------------------------------------------------------//
proc connectPV2PV() { local delstimpvpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fpvpv
	if(PARALLEL){ PC.barrier() }
	r = new Random($1 + 250)
	PID = r.uniform(0,1)
	fpvpv = new Random($1-100)
	delstimpvpv=fpvpv.normal(1.76,0.07)		//latency from IN-IN, according to Bacci (2003)   

	for src=0, nPVcells-1 {
		for trg=0, nPVcells-1 {
			//if (connMatrix.x[PVgids.x(src)][PVgids.x(trg)]) { //NO NEED to account for PC overhead in matrix, gid are GLOBAL ID ;)
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,1) //PV cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PVgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				
				for syn=0, (PV2PV_MaxSyn-1) {
					PID = r.repick ()
					delstimpvpv=abs(fpvpv.repick())
					if(delstimpvpv<steps_per_ms){delstimpvpv=steps_per_ms+1}
					PVcells.o(localID).soma gabaOnPV_A[src][trg][syn] = new GABAain(PID)
					congabaPV2PV_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID,gabaOnPV_A[src][trg][syn],-20,delstimpvpv,autogabaweight )
				}
			}
		}
	}
} // End procedure initPV


//----------------------------------------------PC-PV connections-------------------------------------------------------//
proc connectPC2PV() { local delstimpcpv,PID,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fpcpv
	if(PARALLEL){ PC.barrier() }
	r = new Random($1 + 150)
	PID = r.uniform(0,1)
	fpcpv = new Random($1+2)
	delstimpcpv=fpcpv.normal(0.6, 0.2)		//latency from Pc-In, according to Thomson(2007), also Angulo,Audinat(1999)

	for src=0, nPCcells-1 {
		for trg=0, nPVcells-1 {
			//if (connMatrix.x[PCgids.x(src)][PVgids.x(trg)]) { //if connection exists; account for PC overhead in matrix
			trgGID = ind2gid(trg,1) //PV cells!
			srcGID = ind2gid(src,0) //PC cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PVgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				for syn=0, (PC2PV_MaxSyn-1) {
					PID = r.repick ()
					delstimpcpv = 10//abs(fpcpv.repick())
					if(delstimpcpv<steps_per_ms){delstimpcpv=steps_per_ms+1}
					PVcells.o(localID).soma ampaOnPV[src][trg][syn] = new GLUIN(PID) //no Dends available in the model!
					PVcells.o(localID).soma nmdaOnPV[src][trg][syn] = new NMDA(PID)

					conampaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, ampaOnPV[src][trg][syn], -20, delstimpcpv, ampaweightin)//STEFANOS
					connmdaPC2PV[src][trg][syn] = makeSynapse(PCcells,src,srcGID, nmdaOnPV[src][trg][syn], -20, delstimpcpv, nmdaweightin)//STEFANOS
				}
			}
		}
	}
} //end procedure initPC2PV

//------------------------------------------------PV-PC connections-----------------------------------------------------//
proc connectPV2PC() {local delstimpvpc,PID,NoSynapsesSoma,NoSynapsesDend,BasalNo,rDendidx,src,trg,syn,bool,localID,trgGID,srcGID localobj r,fpvpc,rDend
	if(PARALLEL){ PC.barrier() }
	r = new Random($1 + 180)
	PID = r.uniform(0,1)
	fpvpc = new Random($1*8)
	rDend = new Random($1+5)
	delstimpvpc=fpvpc.normal(1.8, 0.8)	//latency from IN-Pc, according to Thomson(2007)
	NoSynapsesSoma = int(PV2PC_MaxSyn * 46 / 100) //percentage (paper?)
	NoSynapsesDend = PV2PC_MaxSyn - NoSynapsesSoma

	//-----------------------------Connect
	for src=0, nPVcells-1 {
		for trg=0,nPCcells-1 {
			//if (connMatrix.x[PVgids.x(src)][PCgids.x(trg)]) { //if connection exists; account for PC overhead in matrix
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,1) //PV cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PCgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				//----------------------------Insert synapses at dendrites
				for syn=0,(NoSynapsesDend-1) { 
					PID = r.repick()
					rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
					PCcells.o(localID).dend[rDendidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
					PCcells.o(localID).dend[rDendidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
					//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn],5)} //colorize
				}
				//----------------------------Insert synapses at soma
				for syn=0,(NoSynapsesSoma-1) { 
					PID = r.repick()					
					PCcells.o(localID).soma gabaOnPC_A[src][trg][syn+NoSynapsesDend] = new GABAa(PID) //carefull not to overwrite array!
					PCcells.o(localID).soma gabaOnPC_B[src][trg][syn+NoSynapsesDend] = new GABAb(PID)

					//if(PLOT){splot.point_mark(gabaOnPC_A[src][trg][syn+NoSynapsesDend],5)} //colorize
				}

				for syn=0, (PV2PC_MaxSyn-1) { //for total number of IN-PC synapses
					delstimpvpc=abs(fpvpc.repick())
					if(delstimpvpc<steps_per_ms){delstimpvpc=steps_per_ms+1}
					congabaPV2PC_A[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_A[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_a)
					congabaPV2PC_B[src][trg][syn] = makeSynapse(PVcells,src,srcGID, gabaOnPC_B[src][trg][syn], -20, delstimpvpc, gabaweight_pv2pc_b)
				}
			}
		}
	}
}  //end procedure initPV2PC

//----------------------------------------------PC-CB connections-------------------------------------------------------//
proc connectPC2CB() {local i, j, k,delstimpccb,src,trg,syn,bool,localID,trgGID,srcGID localobj fpccb
	if(PARALLEL){ PC.barrier() }
	fpccb = new Random($1*2)
	delstimpccb=fpccb.normal(0.6, 0.2)		//latency from Pc-Cb, according to Thomson(2007), also Angulo,Audinat(1999)

	for src=0, nPCcells-1 {
		for trg=0, nCBcells-1 {
			//if (connMatrix.x[PCgids.x(src)][CBgids.x(trg)]) { 
			trgGID = ind2gid(trg,2) //CB cells!
			srcGID = ind2gid(src,0) //PC cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(CBgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				//----------------------------Insert synapses at dendrites
				for syn=0,(PC2CB_MaxSyn-1) { 
					delstimpccb=abs(fpccb.repick())
					if(delstimpccb<steps_per_ms){delstimpccb=steps_per_ms+1}
					CBcells.o(localID).dend ampaOnCB[src][trg][syn] = new GLUIN(0.5) //TO SEE XENIA, 6/07/11
					CBcells.o(localID).dend nmdaOnCB[src][trg][syn] = new NMDA(0.5)

					conampaPC2CB[src][trg][syn] = makeSynapse(PCcells,src,srcGID, ampaOnCB[src][trg][syn], -20, delstimpccb, ampaweight_pc2cb)
					connmdaPC2CB[src][trg][syn] = makeSynapse(PCcells,src,srcGID, nmdaOnCB[src][trg][syn], -20, delstimpccb, nmdaweight_pc2cb)
					//if(PLOT){splot.point_mark(ampaOnCB[src][trg][syn],5)} //colorize
				}
			}
		}
}
}//proc pyrcb()

//------------------------------------------------CB-PC connections to d2--------------------------------------------------//
proc connectCB2PC() {local BasalNo,PID,delstimcbpc,rDendidx,src,trg,syn,bool,localID,trgGID,srcGID  localobj r,fcbpc,rDend
	if(PARALLEL){ PC.barrier() }
	r = new Random($1 + 170)
	PID = r.uniform(0,1)
	rDend = new Random($1+6)
	fcbpc = new Random($1*9)
	delstimcbpc=fcbpc.normal(1.8, 0.8)	//latency from CB-Pc, according to Thomson(2007)
	//delstimcbp=1.8

	for src=0, CBcells.count()-1 {
		for trg=0,PCcells.count()-1 {
			//if (connMatrix.x[CBgids.x(src)][PCgids.x(trg)]) { //if connection exists; account for PC overhead in matrix
			trgGID = ind2gid(trg,0) //PC cells!
			srcGID = ind2gid(src,2) //CB cells!
			if(PARALLEL){
				bool = PC.gid_exists(trgGID)
				localID = gid2local(PCgids,trgGID) //target cell
			}else{
				bool=1
				localID = trg
			}
			if (bool) { 
				//----------------------------Insert synapses at distal dendrites
				rDendidx = int(rDend.uniform(0,PCcells.o(localID).DendNo-1) )
				for syn=0,(CB2PC_MaxSyn-1) { 
					delstimcbpc=abs(fcbpc.repick())
					if(delstimcbpc<steps_per_ms){delstimcbpc=steps_per_ms+1}
					PCcells.o(localID).dend[rDendidx] gabaOnPC_CB_A[src][trg][syn] = new GABAa(1)//cheating! must find distal basal somehow. //GABAa has exp issues
					congabaCB2PC_A[src][trg][syn]  = makeSynapse(CBcells,src,srcGID, gabaOnPC_CB_A[src][trg][syn], -20, delstimcbpc, gabaweight_cb2pc)
					//if(PLOT){splot.point_mark(gabaOnPC_CB_A[src][trg][syn],5)} //colorize
				}
			}
		}
	}
}// proc cbpyr2()


// see this here on the topic of storing membrane voltage in a parallel context: http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=1987
objref r_volts[offsets.x[offsets.size()-1]],r_msec[offsets.x[offsets.size()-1]]
// each recorded range variable must have a separate tvec which will be different for different cells
objref recordedCells
recordedCells = new Vector()
// recording routines for the parallel context
proc par_rec_membrane_voltage(){local i,s,q  // use gid as parameter

	if (PC.gid_exists($1)) { 
		if(DEBUG){printf("Recording cell %d voltage on node %d\n", $1,PC.id)}
		s=recordedCells.size()
		r_volts[s]=new Vector(n)
		r_msec[s]=new Vector(n)
		//Also a known bug:
		//http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2046
		for q=0,n-1 {r_msec[s].x[q]=q*dt }
		PC.gid2cell($1).soma {cv.record(&v(0.5),r_volts[s],r_msec[s],0)}
		recordedCells.append($1)
	}
}

// store voltage currents to files
strdef vfilePC_filename
strdef data_dir, basename
data_dir = "multi_core"
//basename = "soma_run"

strdef syscmd

proc par_save_membrane_voltage() {local i,s localobj vfilePC

if (PC.id == 0) {
		sprint(syscmd,"mkdir -p %s",data_dir)
		system(syscmd)
}
{ PC.barrier() } 

for i=0, PC.nhost-1 {
	if (PC.id == i) {
		for s=0,recordedCells.size()-1{
			vfilePC = new File()	
			sprint(vfilePC_filename,"%s/%d_%d.txt", data_dir, recordedCells.x(s), runs)  
			vfilePC.wopen(vfilePC_filename)
			r_volts[s].printf(vfilePC,"%8.4f\n")
			vfilePC.close()
		}
	}
}

{ PC.barrier() } 

}

proc report_gidvecs() { local i, rank
	// reports distribution of cells across hosts
	PC.barrier()  // wait for all hosts to get to this point
	if (PC.id==0) printf("\ngidvecs on %d host(s)\n",PC.nhost)
	for rank=0, PC.nhost-1 {  // host 0 first, then 1, 2, etc.
		if (rank==PC.id) {
			//printf("@host %d: %dPC, %dPV, %dCB, %dCR\n",PC.id,PCcells.count(), PVcells.count(), CBcells.count(), CRcells.count() )
			PCgids.printf()          
		}
	{ PC.barrier() } // wait for all hosts to get to this point
	}
}


//RUN
//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//
//---For many experiments
strdef syscmd, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr 

strdef temp

//----record total cell population spike activity
objref timevec, idvec, recncs, tobj, nil, total_activity


strdef foutput

fadp=0.99// (maximum ~7mV (normal gyrw sta 4mV)me train sta 20Hz (5 clamps diarkeias 1ms, ana 50 ms)current clamp)
objref PCvsoma,PVvsoma
proc rec_membrane_voltage(){ local i,j,k,l,m
	for (i=0;i<nPCcells;i=i+1) {
		PCv[i]=new Vector(n)
		PCt[i]=new Vector(n)
		for m=0,n-1 {PCt[i].x[m]=m*dt }
		PCcells.o(i).soma {cv.record(&v(0.5),PCv[i],PCt[i],0) }
	}
	/*for (j=0;j<nPVcells;j=j+1) {
		PVv[j]=new Vector(n)
		PVt[j]=new Vector(n)
		for m=0,n-1 {PVt[j].x[m]=m*dt }
	    	PVcells.o(j).soma cv.record(&v(0.5),PVv[j],PVt[j],0)
	}*/

}
		

proc save_membrane_voltage() { //local ctr
	lets=1+runs
	for sa=0, (nPCcells-1) {
		PCvsoma = new File()		
		sprint(temp,"%s/PCsomaV_%d_run_%d.txt", foutput, sa,lets)
		PCvsoma.wopen(temp)
		for sb=0, PCv[sa].size()-1 { 
			PCvsoma.printf ("%f\n",PCv[sa].x[sb])
		}
		PCvsoma.close()
		//ctr=ctr+1
	}
	/*for sa=0, (nPVcells-1) {
		PVvsoma = new File()		
		sprint(temp,"%s/PVsomaV_%d_run_%d.txt", foutput, sa,lets)
		PVvsoma.wopen(temp)
		for sb=0, PVv[sa].size()-1 { 
			PVvsoma.printf ("%f\n",PVv[sa].x[sb])
		}
		PVvsoma.close()
		//ctr=ctr+1
	}*/

}

for runs = 0, TOTALRUNS {
	if(PARALLEL){
		if(DEBUG){report_gidvecs()}
		{ PC.barrier()	}
		{ PC.set_maxstep(steps_per_ms) }
		if (PC.id==0){ 
			printf("Current run is: %d\n",runs)
			print "Loading ... ",runs, " in host ", PC.id
			print "maxstep=",steps_per_ms
		}  
	}else{
		foutput = "single_core"
		sprint(syscmd,"mkdir -p %s/",foutput) 	
		system(syscmd)
	}
	stimulation(runs)
	//clampStim(runs)
	connectPC2PC(runs) //has mechanism issues
	//connectPV2PV(runs)
	//connectPC2PV(runs)
	//connectPV2PC(runs)
//	connectPC2CB(runs)
	//connectCB2PC(runs) //has mechanism issues

	if(PARALLEL){
		for lala=0,40-1{ // record all cells!
		  par_rec_membrane_voltage(lala)
		}

		stdinit()
		runtime=startsw()
		PC.psolve(tstop)
		runtime = startsw() - runtime

		if (PC.id==0){
		print "node ", PC.id, "reached tstop"
		}

		{ PC.barrier()	} 
		par_save_membrane_voltage()
	}else{
		rec_membrane_voltage()

		runtime=startsw()
		run()
		runtime = startsw() - runtime
		printf("Runtime: %10.4g\n", runtime)

		save_membrane_voltage()
	}
}

if(PARALLEL){
	print "Work done on node ", PC.id
	printf("Runtime: %10.4g\n", runtime)
	{ PC.runworker() }
	{ PC.done() }// tell workers to quit
	quit()
}

