//--------------Set parameters and run this for the net 
//--------------Written 8-5-08, modified 08-10-08
//////////  SERIAL VERSION!  /////////////
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library

//----------------------------------------Set parameters--------------------------------------------------------------//
//Import netrork parameters (Connectivity, synaptic weights etc..) from MATLAB
//if(!xopen("importNetworkParameters.hoc")){print "ERROR	Failed to import network parameters!"}
//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}

// Experimental setup
nPCcells = 1
objref PCv[nPCcells], PCt[nPCcells]
tstop=150
SDELAY = 50
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
//TOTALRUNS = 9
PLOT = 1
DEBUG = 1

//-----Objects for record data
objref cv
cv=new CVode(0)

if(cv.active(0)){print "ERRORRRR!"}	     //Do NOT use CVODE solver!
if(!cv.use_long_double(1)){print "ERRORRRR!"}//was cvode
if(!cv.cache_efficient(1)){print "ERRORRRR!"}

objref PC
strdef sout
PARALLEL = 0 //Default single core
SIMPLIFIED = 0 //Default complex morphologies



//procedure to choose which Pyramidal morphologies we want in network
if(!xopen("chooseMorphologies.hoc")){print "ERROR	Failed to load choose morphologies!"}
//argument: percentage of IB cells morphologies in network, random seed:
chooseMorphologies(60,0)

///////////   Import/set GLOBAL variables (in capital)    //////////////////
if (name_declared("PYID")!=5) { // PYID has not been assigned a numerical value from command line
PYID = 0 //Default cell morphology ID
printf("No 'PYID' argument passed; reverting to default...\n")
}else{
printf("'PYID' argument is %d\n",PYID)
}
if (name_declared("MODE")!=5) { // PYID has not been assigned a numerical value from command line
MODE = 0 //Default mode: NMDA
printf("No 'MODE' argument passed; reverting to default...\n")
}else{
printf("'MODE' argument is %d\n",MODE)
}
if (name_declared("RUN_NO")!=5) { // PYID has not been assigned a numerical value from command line
RUN_NO = 0 //Default number of runs: 0
printf("No 'RUN_NO' argument passed; reverting to default...\n")
}else{
printf("'RUN_NO' argument is %d\n",RUN_NO)
}
if (name_declared("OPTVAR")!=5) { // PYID has not been assigned a numerical value from command line
OPTVAR = 0 //Default value of variable to optimize: OPTVAR
printf("No 'OPTVAR' argument passed; reverting to default...\n")
}else{
printf("'OPTVAR' argument is %f\n",OPTVAR)
}
	
////////////////////////////////////////////
////////////////////////////////////////////
//----------------------------------------Set parameters--------------------------------------------------------------//

if(!xopen("../../lib/basic-graphics.hoc")){print "ERROR	Failed to import parameters!"}
if(!xopen("../define_objects.hoc")){print "ERROR	Failed to import parameters!"}


//Bias choosing the morphology to wanted ID (PYID argument):
objref PcellIDlist
PcellIDlist = new Vector(nPCcells)
PcellIDlist.x[0] = PYID

if(!xopen("../RS1cell.hoc") ){print "ERROR	Failed to load L5Pyramidal hoc!"}


//------------------------------------Pharmacological procedures
fadp=0//2//0.5//0.23
proc sadp_soma() {
	forsec PCsoma_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*fadp } 
		}}}
proc sadp_dend() {
	forsec PCdend_list{
		for(x) {
			if(ismembrane("ican")) for(x) { gbar_ican(x)= 0.0001*0.1*fadp} 
		}}}
proc sadp_apical() {
	forsec PCapical_list {
		for(x) {
			if(ismembrane("ican"))  for(x) { gbar_ican(x)= 0.0001*0.1*fadp} 
		}}}




//---------------------------------------------Multiple Experiments/Runs---------------------------------------------//
//---For many experiments
strdef syscmd, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr 
//-----Variables

printf("DEBUG: PFC NEURONS No: %d\n",nPCcells)
//printf("DEBUG: INTERNEURONS No: %d\n",nINcells)
strdef temp
objref gababweights, nmdaweights, adpweights
//----record total cell population spike activity
objref timevec, idvec, recncs, tobj, nil, total_activity


//---------------------------------Procedure for various checks------------------------------------------------//
objref r1
objref ns1, ns2, ic1, ic2
//r1=new Random(0)
//PID1=r1.uniform(0,1)
//rsid = new Random(1)	
objref conpyr1pyr2[100], nconpyr1pyr2[100], ampapyr1pyr2[100], nmdapyr1pyr2[100]
ns2=new NetStim(0.5)
ns2.interval=20//(in ms!!!)// 20ms in NMDA SPIKES
ns2.number=1 //Single-Paired stimulation
ns2.start=0 //0
ns2.noise=0


total=5

objref ampa[total], nmda[total]

objref nc_s1[total]
//objref nc_s2[500]
objref ic2[5]

// Create synapses at random basal dendrite locations:
proc halfAmpl() { local BasalNo, cs, cd localobj r, rn
	r = new Random($1)
	rn = new Random($1+2)
	BasalNo=0
	forsec PCcells.o[0].basal { BasalNo+=1 }
	r.uniform(0,BasalNo-1)
	rn.uniform(0,1)

	if(PLOT==1){splot.point_mark_remove()}

	for cs=0, 4 { //5 synapses
			/*if(runs){			
				PID = r1.uniform(0,1)
			}else{PID=0.5 }*/
		PID=rn.repick() //BUG: difficult to converge when I changes randomly..
		cd = r.repick()
		PCcells.o[0].dend[cd] {
			//printf("CD: %d , CS: %d, PID: %.3f returns PathDistance: %.3f \n",cd,cs,PID,distance(PID))
			//printf("CD: %d , CS: %d\n",cd,cs)

			if(MODE==2){
				ampa[cs] = new GLU(PID)
				nc_s1[cs]=new NetCon(ns2, ampa[cs])
				nc_s1[cs].delay=SDELAY
				nc_s1[cs].weight=OPTVAR//0.00015//0.000065//*11// Validated for 1.2
				nc_s1[cs].threshold=-20
				if(PLOT==1){			
					splot.point_mark(ampa[cs],cd+1) //colorize
				}
			}else{
				nmda[cs] = new nmda_segev(PID)
				nc_s1[cs]=new NetCon(ns2, nmda[cs])
				nc_s1[cs].delay=SDELAY
				nc_s1[cs].weight=OPTVAR//.000065*35//*0.1 Validated for 1.1:0.39, for 2.3:0.83
				nc_s1[cs].threshold=-20
				if(PLOT==1){			
					splot.point_mark(nmda[cs],cd+1) //colorize
				}
			}
		}
	}
}


proc KblockNassiOLD(){
forall{
for(x){
	fk=0
	//if(ismembrane("kdr")) for(x) { gkdrbar_kdr(x)= gkdrbar_kdr(x)*fk }	// H Nassi DEN to mplokare (commented) //den mplokarontai apo tous blockers tou Kaliou!
	if(ismembrane("kad")) for(x) { gkabar_kad(x)= gkabar_kad(x)*fk }
	if(ismembrane("Ks"))  for(x) { gKsbar_Ks(x)= gKsbar_Ks(x)*fk } 
	if(ismembrane("kca")) { for(x) {  gbar_kca(x)= gbar_kca(x)*fk }}  //slow Ca
	if(ismembrane("mykca")) { for(x) {  gkbar_mykca(x)= gkbar_mykca(x)*fk }} //fast Ca
	if(ismembrane("Naf")) for(x) {  gnafbar_Naf(x)= gnafbar_Naf(x)*0 }
	if(ismembrane("nap")) for(x) {  gnabar_nap(x)= gnabar_nap(x)*0 }
	if(ismembrane("can")) for(x) {  gcalbar_can(x)= gcalbar_can(x)*0 }
	if(ismembrane("cat")) for(x) {  gcatbar_cat(x)= gcatbar_cat(x)*0 } //mplokaroume k ta Ca, giati den kanoun diafora sto amplitude, alla einai pio sta8era sto Vclamp!	
	if(ismembrane("cal")) for(x) {  gcalbar_cal(x)= gcalbar_cal(x)*0 }
	//if(ismembrane("calc")) for(x) {  gcabar_calc(x)= gcabar_calc(x)*0 }
	if(ismembrane("car")) for(x) {  gcabar_car(x)= gcabar_car(x)*0 }
	}}}
	


//--------------------------------------------------------------Vclamp
objref vc, vcdend
proc vclamp() {
	PCcells.o[0].soma {
		vc = new VClamp(0.5)
		if(MODE==1){
			vc.amp[0]= 60
		}else{
			vc.amp[0]= -70 
		}
		vc.dur[0]=tstop
	}
}

// recording/saving processes:
proc rec_VClamp_Current(){
	PCv[0]=new Vector(n)
	PCt[0]=new Vector(n) 
	for j=0,n-1 {PCt[0].x[j]=j*dt }
	PCcells.o[0].soma cv.record(&vc.i,PCv[0],PCt[0],0) 
}


strdef syscmd, data_dir
objref vsoma
proc save_VClamp_Current() {    
	vsoma = new File()		
	sprint(data_dir,"data/NMDA_AMPA_ratio/%d",MODE)
	sprint(syscmd,"mkdir -p %s",data_dir)
	system(syscmd)

	if(MODE==1){
		sprint(temp,"%s/NMDA_%d_%d.txt", data_dir, PYID, runs) 
	} else {
		sprint(temp,"%s/AMPA_%d_%d.txt", data_dir, PYID, runs) 
	}
	vsoma.wopen(temp)
	for sb=0, PCv[0].size()-1 { 
		vsoma.printf ("%f\n",PCv[0].x[sb])
	}
	vsoma.close()
}

//--------------------------------------Graphs
if(PLOT==1){
//for j=0, (nPCcells-1) {addgraph_2("Pcells[j].soma.v(0.5)", 0,tstop, -70, 50)}
//addgraph_2("Pcells[0].dend[15].v(0.5)", 0,tstop, -70, 50)
//addgraph_2("dend[7].v(1)",0,tstop,-75,110) //basal 151um
//addgraph_2("vc.i", 0,tstop, -70, 50)
//addgraph_2("INcells.o(0).soma.v(0.5)", 0,tstop, -80, 50)
splot=new Shape()
//forsec Pcells.o(0).somatic {shape.color(2)}
//forsec Pcells.o(0).axonal {shape.color(5)}
//forsec Pcells.o(0).basal {shape.color(3)}
//forsec Pcells.o(0).apical {shape.color(6)}
}


//////////////////////////////////
//-----------------------------------------------------Multiple Runs

 
r1=new Random(PYID+1)
rsid = new Random(PYID+2)

for runs=0,RUN_NO-1{
	//objref nc_s1[500]
	//objref nc_s2[500] //ginontai overwrite etsi ki alliws afou cs ==5 se ka8e run

	halfAmpl(runs)

	vclamp()

	//if(PLOT==1){addgraph_2("vc.i", 0,tstop, 0, 250)}
	sadp_soma()
	sadp_dend()
	sadp_apical()
	if(MODE==1) {
		KblockNassiOLD() //USE IN NMDA VCLAMP ONLY!
	}

	rec_VClamp_Current()

	run()

	save_VClamp_Current() 
 }
//}
