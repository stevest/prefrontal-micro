// Size of area, after Migliore 2010
//len = 1000 // size of the linear domain, mitral positions range from 0 to len

// Experimental setup
//tstop=10 //defined externaly
//steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
//TOTALRUNS = 1//9
PLOT = 0
DEBUG = 1


//-------------------------------------------------------------
//Primary synapses (Xenia)
Stim_MaxSyn_apic=100//16 min by Nassi criterion	//initial stimulation
Stim_MaxSyn_basal=100//16 min by Nassi criterion	//initial stimulation
Stim_MaxSyn = Stim_MaxSyn_apic+Stim_MaxSyn_basal
PC2PC_MaxSyn = 5//24 //Xenia had 24	//PC-PC connections Thomson 2007, (to have 87% excitatory synapses, Peters, 2008)
PC_MaxAutosyn=1//XENIA //1	//autosynapses (one third, Lubke, 1996)
PV2PV_MaxSyn=12//NASSI	//IN-IN connections
PC2PV_MaxSyn=2//XENIA//2//12	//PC-IN connections (Thomson, 2007) (Markram, 2004sup2)
PV2PC_MaxSyn=4//NASSI//15//XENIA	13//IN-PC connections to soma (Peters,2008,Tamas,1997,J.Physiology,Perez,Larkum,2006)(15-Tamas 1997, Markram 2004)
PC2CB_MaxSyn=14	//PC-CB connections - 8.2+-5 According to Markram, 2004 sup2
PC2CR_MaxSyn=7//XENIA //8	//PC-CR connections - to be changed
CR2CB_MaxSyn=2	//CR-CB connections - to be changed
CB2PC_MaxSyn=12//XENIA//12	+4+4 //CB-PC connections to d2- 11.2+-5 .5 According to Markram, 2004 sup2, Tamas, 1997 ~12.5
CR2PC_MaxSyn=10//XENIA//1	//CR-PC connections to d2 - Tamas, 1997 for cat visual cortex 10

//-------------------------------------------------------------


// Scale NMDA to AMPA ratio (NOT recommended! run validation script instead):
NMDAfactor = 1//3.8//3.8//3.8 gia ta random connected //1.6//0.987
AMPAfactor = 1
NMDAfactor_bg = 1 //0.5 gia diaforetika kyttara...
GABAaFactor = 1.0//2.3 //test if results in stable PA (nonepileptic)
GABAbFactor = 1.0 //test if results in stable PA (nonepileptic)
StimFactor = 2 // NMDA and AMPA seight bias (instead of increasing synapse number).

//-----Objects for record data
objref cv, vc, ic[10]
cv=new CVode(0)

if(cv.active(0)){print "ERRORRRR!"}	     //Do NOT use CVODE solver!
if(!cv.use_long_double(1)){print "ERRORRRR!"}//was cvode
if(!cv.cache_efficient(1)){print "ERRORRRR!"}


//objref PCv[nPCcells], PCt[nPCcells], PVv[nPVcells], PVt[nPVcells]
//...............
ampaweightin=	0.0008//VALIDATED // 7.5e-4	/6 //more synapses means less weight!		//according to Wang,Gao,2009
nmdaweightin=	0.000324 //VALIDATED // 3.2e-4	/6		//ratio inmda/iampa for interneuron *0.5(Wang,Gao,2009)
autogabaweight = 0.0006424//VALIDATED // 	0.0073*0.85	//0.00073*11		//0.0073*0.75	xenia//According to Bacci (2003) validated 31/05/2010
ampaweight_pc2cb = 0.000058 //VALIDATED // 0.000029		//Angulo/Wang validated 28/05/2010
nmdaweight_pc2cb = 0.000067//VALIDATED // ampaweight_pc2cb*0.86		//Wang validated me 50 pyrcb synapses gia ratio 0.8 28/05/2010
ampaweight_pc2cr = 0.00012//VALIDATED //   0.000046			//20pA sta -72 --> 28/05/2010	
nmdaweight_pc2cr = 0.000145 //VALIDATED // ampaweight_pc2cr*2.2	//validated gia 30pyrcr synapses 28/05/2010
gabaweight_pv2pc_a = 0.00068  //VALIDATED // 6.9e-4		//*0.1//STEFANOS	//0.00075 kiki		//According to Woo(2007)
gabaweight_pv2pc_b = 0.00068*0.13 //VALIDATED // gabaweight_pv2pc_a 	//*0.1//STEFANOS
gabaweight_cb2pc = 0.000045 //VALIDATED // 0.0006*1.5          //*0.1        	//cb-pc connections - according to Xiang, 2009
gabaweight_cr2pc = 0.00006 //VALIDATED // 0.00087*3           //*0.1      	//cr-pc connections - validated na einai peripou sta idia epipeda me cr-cb & in-in
gabaweight_cr2cb = 0.00006 //VALIDATED // 0.0083*0.25                	//cr-cb connections - according to Bacci, 2003b 31/05/2010


objref PC
strdef sout
if (name_declared("CLUSTER_ID")!=5){
	CLUSTER_ID = 0//default cluster
}

if (name_declared("EXPERIMENT")!=5){
	exit(1)
}


if (name_declared("ST")!=5){
	exit(1)
}





if (name_declared("PARALLEL")!=5) { // PARALLEL has not been assigned a numerical value from command line
	PARALLEL = 0 //Default single core
}
if(PARALLEL){
	{PC=new ParallelContext()}
	if(PC.id==0){ printf("Microcircuit running in %d CORES !\n\n", PC.nhost()) }
}else{
	 printf("Microcircuit running in 'SINGLE CORE' !\n\n") 
}
//process to print only on node zero (if parallel):
strdef pprintStr
proc pprint(){
	if (name_declared("PC")==2){
		if(PC.id==0){print $s1}
	} else {
		print $s1
	} 
}

if (name_declared("ID")!=5){
	exit(1)
} else {
	sprint(pprintStr,"Experiment ID is: %d",ID)
	pprint(pprintStr)
}

if (name_declared("SN")!=5){
	exit(1)
} else {
	sprint(pprintStr,"Experiment Serial Number is: %d",SN)
	pprint(pprintStr)
	
	strdef EXP
	if( EXPERIMENT ){
		sprint(EXP,"STR_SN%d_ST%d",SN,ST)
	} else {
		sprint(EXP,"RND_SN%d_ST%d",SN,ST)
	}
}

if (name_declared("SIMPLIFIED")!=5) { // PARALLEL has not been assigned a numerical value from command line
	SIMPLIFIED = 0 //Default complex morphologies
}
if(SIMPLIFIED){
	NMDA_MECH = "nmda_segev"
	sprint(pprintStr,"Microcircuit running with simplified morphologies !\n\n")
	pprint(pprintStr)
}else{
	NMDA_MECH = "nmda_segev"	
	sprint(pprintStr,"Microcircuit running with complex morphologies !\n\n")
	pprint(pprintStr)
}

if (name_declared("VCLAMP")!=5) { // Do Vclamp to check UP/DOWN states conductance
	VCLAMP = 0 //If ==0 No vclamp
}else{ 
	sprint(pprintStr,"VCLAMP value is %f", VCLAMP )
	pprint(pprintStr)
}

if (name_declared("ISBINARY")!=5){
	exit(1)
}

if (name_declared("CLUSTBIAS")!=5){
	exit(1)
}

if (name_declared("GPYID")!=5) { // Do Vclamp to check UP/DOWN states conductance
	GPYID = 0 //If ==0 No vclamp
}else{ 	
	sprint(pprintStr,"GPYID value is %d", GPYID )
	pprint(pprintStr)
}

/*//Global mechanism definitions:
if (name_declared("NMDA_MECH")!=5) { // Which NMDA mechanism to be used?
	NMDA_MECH = "nmda_segev" //If ==0 No vclamp
}else{ print "NMDA_MECH value is ", NMDA_MECH}
*/

// given a cell index ($1) and the type of cell ($2), return the gid
// As for $2, 0 stands for pyramidal cells, 1 for PVs, 2 for CBs, and 3 for CRs
objref offsets
{offsets = new Vector()}
{offsets.append(0,nPCcells,nPVcells,nCBcells,nCRcells)}
{offsets.append(offsets.sum(0,offsets.size()-1))}

//global_gid=offsets.v[offsets.size()-1]  // points to the next available gid
func ind2gid(){local i  
  if(numarg()<2) { printf("wrong number of arguments to func ind2gid") }
  i=$1+offsets.sum(0,$2)
  if(i>=offsets.sum(0,$2+1)) { i-=1 }   
  return i 
}


// register the connection target locally given a synapse gid and a synapse mechanism as arguments
// if given additional arguments, it will set them as weight, delay, and threshold, respectively
// http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2158
obfunc makeSynapse(){ localobj nc, src
	if(PARALLEL){
		nc=PC.gid_connect($3,$o4)

	}else{
		src = $o1
		access src.o($2).axon
		nc = new NetCon(&v(x),$o4)
	}
	nc.threshold = $5
	nc.delay = $6
	nc.weight = $7
	return nc
}

func gid2local(){local i localobj arg
	arg = $o1
	for i=0, arg.size()-1 {
		if(arg.x(i) == $2){
			return i
		}
	}
	return -1 //if error
}



strdef mname,sprop,tempString
objref mt,pp,mechFile

proc sectionPointMechSnapshot(){ local z localobj lo,mt
	mechFile = new File()
	mechFile.wopen($s1)
	mt = new MechanismType(1)
	for z=0,mt.count()-1{
		mt.select(z)
		mt.selected(mname)
		mt.internal_type()
		for (pp = mt.pp_begin(); object_id(pp) != 0; pp = mt.pp_next()) {
			x = pp.get_loc()
			//printf("%s located at %s(%g)\n", pp, secname(),x)
			mechFile.printf("%s located at %s(%g)\n", pp, secname(),x)
			pop_section()
		}
	}
	mechFile.close()
}

proc sectionMembraneMechSnapshot(){ local z,j,val localobj lo,mt,ms
	mechFile = new File()
	mechFile.wopen($s1)
	//printf("Snapshot: %15s -> %20s -> %s \n","Mechanism","Property","Value")	
	mechFile.printf("Snapshot: %15s -> %20s -> %s \n","Mechanism","Property","Value")
	mt = new MechanismType(0)
	for z=0,mt.count()-1{
		mt.select(z)
		mt.selected(mname)

		ms = new MechanismStandard(mname, 0)
		for j=0, ms.count()-1 {
			k = ms.name(sprop, j)
			val = ms.get(sprop)
			//printf("Snapshot: %15s -> %20s -> %010.30f \n",mname,sprop, val)
			mechFile.printf("Snapshot: %15s -> %20s -> %010.30f \n",mname,sprop, val)
		}
		
	}
	mechFile.close()
}

