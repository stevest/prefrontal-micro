//Set parameters and run this for the net (generated from MATLAB scripts)
//Written 1/8/13 stamatiad.st@gmail.com
//Simplified version to check for pesky bugs, yuck..
DEBUG=1
ISBINARY=0
strdef pprintStr
strdef PATH, PPRINT_CMD
strdef STDOUT, PPRINT_CMD
strdef EXEC_CMD
strdef syscmd, data_dir, data_dira, data_dirb, data_dirc, data_dird, running, tmpstr
strdef s
strdef temp
strdef foutput
strdef str, vfilePC_filename, EXEC_CMD
objref PC
objref PcellStimList
objref PcellIDlist
objref timevec, idvec, recncs, tobj, nil, total_activity
PATH = SIMHOME
inittime=startsw()
//define a basic assert function:
proc assert(){ 
	if(!$1){	
		print "Assertion error. Exiting..."
		quit()
	}
}
if (name_declared("PARALLEL")!=5) { // PARALLEL has not been assigned a numerical value from command line
        PARALLEL = 0 //Default single core
}
if(PARALLEL){
        {PC=new ParallelContext()}
        if(PC.id==0){ printf("Microcircuit running in %d CORES !\n\n", PC.nhost()) }
}else{
         printf("Microcircuit running in 'SINGLE CORE' !\n\n")
}
//process to print only on node zero (if parallel):
proc pprint(){
        //if (name_declared("PC")==2){
        if (PARALLEL){
                if(PC.id==0){print $s1}
        } else {
                print $s1
	}
}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}
{system("echo $(date)", PPRINT_CMD)}
{sprint(STDOUT, "NEURON MPIRUN STARTING AT: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//JOBID is generated from SGE so get it:
{sprint(STDOUT, "JOB NAME: %s",JOBNAME)}
{pprint(STDOUT)}
{system("echo $JOB_ID", PPRINT_CMD)}
{sprint(STDOUT, "JOB ID: %s",PPRINT_CMD)}
{pprint(STDOUT)}
//{system("echo $JOB_NAME	", PPRINT_CMD)}
//{sprint(JOBNAME, "%s",PPRINT_CMD)}
//JOBNAME: read it from arguments, because of envars bug.
{pprint("Git sha1: ")}
{pprint(GITSHA1)}
{sprint(STDOUT,"========================================================================================\n")}
{pprint(STDOUT)}

if(PARALLEL){

} else {
if(!load_file("nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library
}
if(PARALLEL){PC.barrier}
if(1){pprint("Load NEURON environment.")}
//----------------------------------------Set parameters--------------------------------------------------------------//
//Import netrork parameters (Connectivity, synaptic weights etc..) from MATLAB
EXEC_CMD = ""
if (EXPERIMENT) { //if Structured...
	{sprint(EXEC_CMD,"{xopen(\"%simportNetworkParametersSTR_SN%s_Fs_%g_Cl_%g.hoc\")}",PATH,SN,FS,CL)}
} else {
	sprint(EXEC_CMD,"{xopen(\"%simportNetworkParametersRND_SN%s_Fs_%g_Cl_%g.hoc\")}",PATH,SN,FS,CL)
}
if(PARALLEL){PC.barrier}
tstop = 1000 
//Use execute1() instead of execute() feed the bool into assert
//execute1() does not like the ~ (even if documented otherwise...)
//Also the ~ encloses command in {}, but that is not happening. Go figure..
pprint(EXEC_CMD)
if(1){assert(execute1(EXEC_CMD))}
if(1){pprint("Load Network Parameters.")}


{sprint(EXEC_CMD,"{xopen(\"%smain_parameters.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}
//if(!xopen("main_parameters.hoc")){print "ERROR	Failed to load main parameters!"}
if(PARALLEL){PC.barrier}
if(1){pprint("Load Main Parameters.")}
//---For many experiments

if(PARALLEL){PC.barrier}
//parse stimulation parameters

{sprint(EXEC_CMD,"{xopen(\"%spfc_pc_temp.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}

if(PARALLEL){PC.barrier}
if(DEBUG){pprint("Load cell templates.")}

//override complex background spiketrains:
//Background activity like Haider
//PC ~1Hz, PV ~14Hz
BG_dendSyn = BGE//2 synapses as of 1/10/15 

taur_cad = 50//36 //SSS

fadp=0.0//1.27//MUST BE SET FOR EACH MORPHOLOGY!!! //.35// (maximum ~7mV (normal gyrw sta 4mV)me train sta 20Hz (5 clamps diarkeias 1ms, ana 50 ms)current clamp)
//Network handling code:
objref ampaBGd[nPCcells][BG_dendSyn]
objref nmdaBGd[nPCcells][BG_dendSyn]

objref BG_AMPAd[nPCcells][BG_dendSyn]
objref BG_NMDAd[nPCcells][BG_dendSyn]
objref rUniform_dend[nPCcells*BG_dendSyn], rPoisson_dend[nPCcells*BG_dendSyn]
objref nhPoissonStim_dend[nPCcells*BG_dendSyn]
objref rateVect
objref netstim_dend[nPCcells*BG_dendSyn]
if(save_bg_iampa){
	{sprint(EXEC_CMD,"{objref bg_iampa[%d][%d]}",nPCcells,BG_dendSyn)}
	{assert(execute1(EXEC_CMD))}
}
proc backgroundActivity() { local trg,syn_dend,PID,RV,RLB,RLA,localID,trgGID,StimDur,StimFreq,StimNo,SynapsesNo localobj r,rv,rlb,rla
	r = new Random(SNd*$1 + 300 + PC.id)
	rv = new Random(SNd*$1 +400)
	RV = rv.uniform(1, StimDur)
	PID = r.uniform(0,1)
	rlb = new Random(SNd*$1+160)
	rla = new Random(SNd*$1+560)

	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{xopen(\"%sRateVectors/rateVect_%03d.hoc\")}",SIMGLIA,$1)}
	{assert(execute1(EXEC_CMD))}
	lambdaMax = rateVect.max() 

	for trg=0, nPCcells-1 {
		if(PARALLEL){
			trgGID = ind2gid(trg,0) //ONLY FOR PC CELLS!
			bool = PC.gid_exists(trgGID)
			localID = gid2local(PCgids,trgGID) //target cell	
		}else{
			bool=1
			localID = trg
		}

		if(bool){
			RLB = rlb.uniform(0,PCcells.o(localID).DendNo-1)
			RLA = rla.uniform(0,PCcells.o(localID).ApicNo-1)

			if(save_background_locations){
				{sprint(EXEC_CMD,"{bgstimpidPC2PC[%d] = new Vector()}",trgGID)}
				{assert(execute1(EXEC_CMD))}
			}
			for syn_dend=0, BG_dendSyn-1 {
				//RLB = 0
				//PID = (syn_dend+1)/(BG_dendSyn+1)// ?!?!? Why is that?
				PID = 0.5//r.repick()
				if(save_background_locations){
					{sprint(EXEC_CMD,"{bgstimpidPC2PC[%d].append(%f)}",trgGID,PID)}
					{assert(execute1(EXEC_CMD))}
				}
				RLB = 0 // Basals!!
				PCcells.o(localID).soma {ampaBGd[trg][syn_dend]=new GLU(PID)}
				PCcells.o(localID).soma {nmdaBGd[trg][syn_dend]=new nmda_segev(PID)}

				//RLB = rlb.repick()
				rUniform_dend[trg + (nPCcells*syn_dend)] = new Random(trg + (nPCcells*syn_dend))
				rUniform_dend[trg + (nPCcells*syn_dend)].uniform(0,0)
				rPoisson_dend[trg + (nPCcells*syn_dend)] = new Random(trg + (nPCcells*syn_dend))
				rPoisson_dend[trg + (nPCcells*syn_dend)].uniform(trg+1,trg+1)//poisson(lambdaMax)
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)] = new NonHomPoissonStim()
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].getRandObjPtrUniform(rUniform_dend[trg+(syn_dend*nPCcells)])
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].getRandObjPtrPoisson(rPoisson_dend[trg+(syn_dend*nPCcells)])
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].play(rateVect)
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].lambdaMax = lambdaMax 
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].cellid = trg
				nhPoissonStim_dend[trg + (nPCcells*syn_dend)].synid = syn_dend 

				netstim_dend[trg + (nPCcells*syn_dend)] = new NetStim()
				netstim_dend[trg + (nPCcells*syn_dend)].start = trg+1+200 //pws to bazw sto NHPoisson?
				netstim_dend[trg + (nPCcells*syn_dend)].number = 1
				netstim_dend[trg + (nPCcells*syn_dend)].noise = 0

				BG_AMPAd[trg][syn_dend]=new NetCon(netstim_dend[trg + (nPCcells*syn_dend)], ampaBGd[trg][syn_dend]) //vstimd[trg][syn_dend]
				//BG_AMPAd[trg][syn_dend]=new NetCon(nhPoissonStim_dend[trg + (nPCcells*syn_dend)], ampaBGd[trg][syn_dend]) //vstimd[trg][syn_dend]
				BG_AMPAd[trg][syn_dend].delay=0
				BG_AMPAd[trg][syn_dend].weight = 0.00019 //SSS		
				BG_AMPAd[trg][syn_dend].threshold=-10 

				/*BG_NMDAd[trg][syn_dend]=new NetCon(nhPoissonStim_dend[trg + (nPCcells*syn_dend)], nmdaBGd[trg][syn_dend]) //vstimd[trg][syn_dend]
				BG_NMDAd[trg][syn_dend].delay=0
				BG_NMDAd[trg][syn_dend].weight = 0.25 //SSS		
				BG_NMDAd[trg][syn_dend].threshold=-10  
				*/
				if(save_bg_iampa){
						{sprint(EXEC_CMD,"{bg_iampa[%d][%d] = new Vector()}",trg,syn_dend)}
						{assert(execute1(EXEC_CMD))}
						{sprint(EXEC_CMD,"{bg_iampa[%d][%d].record(&ampaBGd[%d][%d].iglu)}",trg,syn_dend,trg,syn_dend)}
						{assert(execute1(EXEC_CMD))}
				}
			}

		}//end bool
	}
}//end proc

objref r_volts[offsets.x[offsets.size()-1]],r_msec[offsets.x[offsets.size()-1]]
objref recordedCells
recordedCells = new Vector()
proc par_rec_membrane_voltage(){local c,i,s,q,trgGID,trg  // use gid as parameter
	trg = $1
	if (PC.gid_exists(trg)) { 
		if ( trg < nPCcells ) {
			trgGID = ind2gid(trg,0) //ONLY FOR PC CELLS!
			s = gid2local(PCgids,trgGID) //target cell	
			print "requesting PC ",trg," record."
		}else{
			trgGID = ind2gid(trg,1) //ONLY FOR PC CELLS!
			s = gid2local(PVgids,trgGID) //target cell	
			print "requesting PV ",trg," record."
		}
		print "cell recording from: ",trg," and localid is: ",s," as reported in PCgids.x[",s,"]=",PCgids.x[s]
		//s=recordedCells.size()
		r_volts[s]=new Vector(n)
		r_msec[s]=new Vector(n)
		//Also a known bug:
		//http://www.neuron.yale.edu/phpbb/viewtopic.php?f=31&t=2046
		for q=0,n-1 {r_msec[s].x[q]=q*dt }
		PC.gid2cell($1).soma {cv.record(&v(0.5),r_volts[s],r_msec[s],0)}
		recordedCells.append($1)
	}
}

proc report_gidvecs() { local i, rank
	PC.barrier()  // wait for all hosts to get to this point
	if (PC.id==0) printf("\ngidvecs on %d host(s)\n",PC.nhost)
	for rank=0, PC.nhost-1 {  // host 0 first, then 1, 2, etc.
		if (rank==PC.id) {
			system("hostname",s)
			print "On host: ",s
			PCgids.printf()      
		}
	{ PC.barrier() } // wait for all hosts to get to this point
	}
}



if(1){report_gidvecs()}
{ PC.barrier()	}
{ PC.set_maxstep(steps_per_ms) }

if(0){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{stimulation(%d,%d)}",0,0)}
	{assert(execute1(EXEC_CMD))}
	//stimulation(0,0)   //synaptic location Random seed, axon conductanse delay Random seed
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}
//ATTENTION TO WEIGHT OF BG SYNAPSES!! CORRECTED FOR FEWER SYNAPSES!!!! SSS
if(1){
	EXEC_CMD = ""
	{sprint(EXEC_CMD,"{backgroundActivity(%d,%d)}",RUN,0)}
	{assert(execute1(EXEC_CMD))}
	//backgroundActivity(RUN,0) //NO PARALLEL SAFE : try producing the sequence in one node then stimulate each cell
	sprint(PPRINT_CMD,"%s executed.\n",EXEC_CMD)
	{pprint(PPRINT_CMD)}
}

recordedCells = new Vector()
for pyr=0,offsets.x[3]-1{ // record all cells!
  par_rec_membrane_voltage(pyr)
}

{pprint("----------------------------------------------------------------------------------------")}
{pprint("Commencing Parallel run!")}
{pprint("----------------------------------------------------------------------------------------")}
inittime = startsw() - inittime
{sprint(PPRINT_CMD,"Network Initialization time: %10.4g minutes.\n", inittime/60)}
{pprint(PPRINT_CMD)}
inittime=startsw()
{sprint(EXEC_CMD,"{xopen(\"%sbalance_compartments.hoc\")}",PATH)}
if(1){assert(execute1(EXEC_CMD))}

//Right balancer!
balance_compartments()

inittime = startsw() - inittime
{sprint(PPRINT_CMD,"Compartment Initialization (stdinit()) time: %10.4g minutes.\n", inittime/60)}
{pprint(PPRINT_CMD)}
runtime=startsw()

{PC.psolve(tstop)}

runtime = startsw() - runtime
sprint(PPRINT_CMD,"All reached tstop: %d ms.\n",tstop)
{pprint(PPRINT_CMD)}
{ PC.barrier()	}

if(1){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_membrane_voltage.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_membrane_voltage(JOBDIR,CLUSTER_ID, ISBINARY)
	{pprint("par_save_membrane_voltage() is active.")}
}

if(save_bg_iampa){
	{sprint(EXEC_CMD,"{xopen(\"%spar_save_bg_iampa.hoc\")}",PATH)}
	if(1){assert(execute1(EXEC_CMD))}
	par_save_bg_iampa(JOBDIR,CLUSTER_ID,0)
	{pprint("par_save_bg_iampa() is active.")}
}


{sprint(PPRINT_CMD,"Runtime: %10.4g minutes.\n", runtime/60)}
{pprint(PPRINT_CMD)}

{ PC.runworker() }
{ PC.done() }// tell workers to quit
//Only master node is active now.
print "Success"
//Run matlab script to analyze the data!.
print "Running epilog script..."
{sprint(EXEC_CMD,"%sepilog.sh \"%s\" \"%s\"",PATH,PATH,JOBDIR)}
exitcode = system(EXEC_CMD)
quit()

