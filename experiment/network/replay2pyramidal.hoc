strdef STDOUT, PPRINT_CMD,EXEC_CMD, PATH, STRING, SIMPATH
SIMPATH = "/home/cluster/stefanos/Documents/GitHub/prefrontal-micro/experiment/network"
PATH = "/home/cluster/stefanos/Documents/Glia/distally_EB25.000_IB5.000_ST40_BGE20_BGI1_GBF15.000_Fs1.000_Cl7_NDS5_NMDAFLAG0.000_CLB1.000_Ss4c6_SN10_r0"
if(!load_file("/home/cluster/stefanos/Libraries/nrn/share/nrn/lib/hoc/nrngui.hoc")){print "ERROR	Failed to load NEURON!"}			//load main NEURON library

objref PC
PC = new ParallelContext()
PARALLEL  = 0

tstop = 3000 
steps_per_ms=10
dt=1/steps_per_ms
n=int(tstop/dt)
celsius=34
DEND_NSEG = 5
EXCITBIAS =25 
INHIBIAS = 5 
NMDABIAS = 2


v_init = -66 
objref cv
cv=new CVode(0)
if(cv.active(0)){print "ERRORRRR!"}	     //Do NOT use CVODE solver!
if(!cv.use_long_double(1)){print "ERRORRRR!"}//was cvode
if(!cv.cache_efficient(1)){print "ERRORRRR!"}

{sprint(EXEC_CMD,"{xopen(\"%s/importNetworkParametersSTR_SN10_Fs_1_Cl_7.hoc\")}",SIMPATH)}
print EXEC_CMD
execute1(EXEC_CMD)

taur_cad = 50//36 //SSS
{xopen("../define_objects.hoc")}
//Create only one cell (called inside pfc_pc_temp.hoc)
nPCcells = 1
{xopen("pfc_pc_temp.hoc")}
nPCcells = 250

ampaweight=	0.00019		//According to Wang(2008)

//Balance each cell compartment to the prefered voltage and comply with NEURON initialization routines.
proc balance_compartments() {
	//Do not call finitialize with v_init argument, because it sets it in all cells
	// created up to this point!
	finitialize()
	forsec PCcell_list {
		for (x) {
			if (ismembrane("na_ion")) {e_passive(x)=v(x)+ina(x)/g_passive(x)} 
			if (ismembrane("k_ion")) {e_passive(x)=e_passive(x)+ik(x)/g_passive(x)} 
			if (ismembrane("ca_ion")) {e_passive(x)=e_passive(x)+ica(x)/g_passive(x)}
			if (ismembrane("in_ion")) {e_passive(x)=e_passive(x)+in(x)/g_passive(x)} //ican
			if (ismembrane("h")) {e_passive(x)=e_passive(x)+ihi(x)/g_passive(x)}
		
		}
	}
	fcurrent()
	if (cv.active()) {
		cv.re_init()
	}       else {
		fcurrent()
	}
	frecord_init()
}

objref vcobj
objref r, PCv,PCi, vsoma
objref PCvd, PCvdd, PCvddd

maxnumber =100
objref ncAMPA[nPCcells][maxnumber], nsNMDA[nPCcells][maxnumber],nsAMPA[nPCcells][maxnumber], ncNMDA[nPCcells][maxnumber], ampapr[nPCcells][maxnumber], nmdapr[nPCcells][maxnumber]
{sprint(EXEC_CMD,"{xopen(\"%s/replay.hoc\")}",PATH)}
print EXEC_CMD
execute1(EXEC_CMD)

ampaweight_stimulus = 0.00024 *5 
nmdaweight_stimulus = 0.22  *5 
gabaweight=	0.00083//XENIA GABAa //6.9e-4 			//According to Woo(2007)
gabaweightb=1.05e-4
GABABFACTOR = 15
gabaweight_pv2pc_a = gabaweight    //3.8// GABA gia to RAND connectivity //OVERRIDED!!
gabaweight_pv2pc_b = gabaweightb   *GABABFACTOR//0.2//0.1//*0.1 is the June working //*0.4//SSS //3.8// GABA gia to RAND connectivity //OVERRIDED!!

objref artcell
artcell = new NetStim()
artcell.interval = 20
artcell.number = 50
artcell.start = 0
artcell.noise = 0//.2

proc stimulation() { local trg,syn,PID,ApicalNo,rApicIdx,localID,trgGID,artgid  localobj rvect,mynil
	trg = $1 //the cell you want to replicate
	trgGID = trg
	localID =0 
	// Apical input:
	if(object_id(stimpidPC2PC[trgGID])){
		for syn=0, stimpidPC2PC[trgGID].size()-1 {
			PID=stimpidPC2PC[trgGID].x(syn)
			rApicIdx = 0 //PROXIMAL!
			PCcells.o(localID).apic[rApicIdx] {ampapr[trg][syn] = new GLU(PID)}
			PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn] = new nmda_segev(PID)}
			//PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn].myflag = 0}
			//PCcells.o(localID).apic[rApicIdx] {nmdapr[trg][syn].cellid = trgGID}

			ncAMPA[trg][syn] = new NetCon(artcell, ampapr[trg][syn]) //vstim_stim[trg][syn]
			ncAMPA[trg][syn].delay=500
			ncAMPA[trg][syn].weight = ampaweight_stimulus// *15//SSS
			ncAMPA[trg][syn].threshold=-10 

			ncNMDA[trg][syn] = new NetCon(artcell, nmdapr[trg][syn])
			ncNMDA[trg][syn].delay=500
			ncNMDA[trg][syn].weight = nmdaweight_stimulus// *15//SSS
			ncNMDA[trg][syn].threshold=-10
		}
	}
} //end proc
objref PCvs[nPCcells][nPCcells]
objref ampaOnPC[nPCcells][nPCcells][maxnumber]
objref nmdaOnPC[nPCcells][nPCcells][maxnumber]
objref conampaPC2PC[nPCcells][nPCcells][maxnumber]
objref connmdaPC2PC[nPCcells][nPCcells][maxnumber]
proc replayonpc(){
	localID = 0
	trg = $1 //the cell we replay
	for src = 0, nPCcells-1{
// cells might be connected but have no incomming spikes:
		if(object_id(pidPC2PC[src][trg]) && object_id(PCvecstim[src][trg])){
print "replaying PC src=",src," trg=",trg," syns=",pidPC2PC[src][trg].size()
			for syn=0, pidPC2PC[src][trg].size()-1 { //for current syn
				PID = pidPC2PC[src][trg].x[syn]
				FIDp = delayPC2PC[src][trg].x[syn]
				PCcells.o(localID).dend[0] {ampaOnPC[src][trg][syn] = new GLU(PID)}
				PCcells.o(localID).dend[0] {nmdaOnPC[src][trg][syn] = new nmda_segev(PID)}
				PCvs[src][trg] = new VecStim()
				PCvs[src][trg].delay = 0
				PCvs[src][trg].play(PCvecstim[src][trg])

				conampaPC2PC[src][trg][syn] = new NetCon(PCvs[src][trg], ampaOnPC[src][trg][syn]) //vstim_stim[trg][syn]
				conampaPC2PC[src][trg][syn].delay=FIDp
				conampaPC2PC[src][trg][syn].weight = ampaweight *  W.x[src][trg] * EXCITBIAS 
				conampaPC2PC[src][trg][syn].threshold=-20 

				connmdaPC2PC[src][trg][syn] = new NetCon(PCvs[src][trg], nmdaOnPC[src][trg][syn])
				connmdaPC2PC[src][trg][syn].delay=FIDp
				connmdaPC2PC[src][trg][syn].weight = 0.25  *  W.x[src][trg] * EXCITBIAS * NMDABIAS 
				connmdaPC2PC[src][trg][syn].threshold=-20
			}
		}
	}
}

objref PVvs[nPVcells][nPCcells]
objref gabaOnPC_A[nPVcells][nPCcells][maxnumber]
objref gabaOnPC_B[nPVcells][nPCcells][maxnumber]
objref congabaPV2PC_A[nPVcells][nPCcells][maxnumber]
objref congabaPV2PC_B[nPVcells][nPCcells][maxnumber]
proc connectPV2PC() {local delstimpvpc,PID,rDendidx,rApicidx,src,trg,syn,localID
	//-----------------------------Connect
	trg = $1
	localID = 0
	for src=0, nPVcells-1 {
		//----------------------------Insert synapses at soma
		if(object_id(pidPV2PC[src][trg]) && object_id(PVvecstim[src][trg])){
print "replaying PV src=",src," trg=",trg," syns=",pidPV2PC[src][trg].size()
			for syn=0,1-1 { 
				PID = pidPV2PC[src][trg].x[syn]
				PCcells.o(localID).soma gabaOnPC_A[src][trg][syn] = new GABAa(PID) //carefull not to overwrite array!
				PCcells.o(localID).soma gabaOnPC_B[src][trg][syn] = new GABAb(PID)

				delstimpvpc=delayPV2PC[src][trg].x[syn]

				PVvs[src][trg] = new VecStim()
				PVvs[src][trg].delay = 0
				PVvs[src][trg].play(PVvecstim[src][trg])

				congabaPV2PC_A[src][trg][syn] = new NetCon(PVvs[src][trg], gabaOnPC_A[src][trg][syn]) //vstim_stim[trg][syn]
				congabaPV2PC_A[src][trg][syn].delay=delstimpvpc
				congabaPV2PC_A[src][trg][syn].weight = gabaweight_pv2pc_a*INHIBIAS
				congabaPV2PC_A[src][trg][syn].threshold=-20 

				congabaPV2PC_B[src][trg][syn] = new NetCon(PVvs[src][trg], gabaOnPC_B[src][trg][syn])
				congabaPV2PC_B[src][trg][syn].delay=delstimpvpc
				congabaPV2PC_B[src][trg][syn].weight = gabaweight_pv2pc_b*INHIBIAS
				congabaPV2PC_B[src][trg][syn].threshold=-20
			}
					//----------------------------Insert synapses at dendrites
			for syn=1,4-1 { 
				PID = pidPV2PC[src][trg].x[syn]
				rDendidx = 0 //dendrites!
				PCcells.o(localID).dend[rDendidx] gabaOnPC_A[src][trg][syn] = new GABAa(PID) //was @ soma initially...
				PCcells.o(localID).dend[rDendidx] gabaOnPC_B[src][trg][syn] = new GABAb(PID)
				delstimpvpc=delayPV2PC[src][trg].x[syn]

				PVvs[src][trg] = new VecStim()
				PVvs[src][trg].delay = 0
				PVvs[src][trg].play(PVvecstim[src][trg])

				congabaPV2PC_A[src][trg][syn] = new NetCon(PVvs[src][trg], gabaOnPC_A[src][trg][syn]) //vstim_stim[trg][syn]
				congabaPV2PC_A[src][trg][syn].delay=delstimpvpc
				congabaPV2PC_A[src][trg][syn].weight = gabaweight_pv2pc_a*0.33*INHIBIAS
				congabaPV2PC_A[src][trg][syn].threshold=-20 

				congabaPV2PC_B[src][trg][syn] = new NetCon(PVvs[src][trg], gabaOnPC_B[src][trg][syn])
				congabaPV2PC_B[src][trg][syn].delay=delstimpvpc
				congabaPV2PC_B[src][trg][syn].weight = gabaweight_pv2pc_b*0.33*INHIBIAS
				congabaPV2PC_B[src][trg][syn].threshold=-20
			}
		}
	}
}  //end procedure initPV2PC

print "---------------------"
replaycellid = 236
print "stimulating..."
stimulation(replaycellid)
print "replaying..."
replayonpc(replaycellid)
connectPV2PC(replaycellid)
print "Done procs.."

PCv = new Vector()
PCv.record(&PCcells.o(0).soma.v(.5)) 
print "recording PC"
//PCi = new Vector()
//PCi.record(&vcobj.i) 
PCvd = new Vector()
PCvd.record(&PCcells.o(0).dend.v(0.1)) 
PCvdd = new Vector()
PCvdd.record(&PCcells.o(0).dend.v(0.5)) 
PCvddd = new Vector()
PCvddd.record(&PCcells.o(0).dend.v(0.9)) 

balance_compartments()
print "balancing compartments"
run()
print "simulation is DONE. Saving..."
vsoma = new File()		

sprint(STRING,"DATA/vsoma.txt")
print STRING
vsoma.wopen(STRING)
for j=0, PCv.size()-1 {
	vsoma.printf ("%f\n",PCv.x[j])
}
vsoma.close()
/*
			sprint(STRING,"DATA/gabai_%.3f.txt",gabaweight_pv2pc_a )
			print STRING
			vsoma.wopen(STRING)
			for j=0, PCi.size()-1 {
				vsoma.printf ("%f\n",PCi.x[j])
			}
			vsoma.close()
*/
/*
vsoma = new File()		
sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.1)
vsoma.wopen(STRING)
for j=0, PCvd.size()-1 {
	vsoma.printf ("%f\n",PCvd.x[j])
}
vsoma.close()

vsoma = new File()		
sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.5)
vsoma.wopen(STRING)
for j=0, PCvdd.size()-1 {
	vsoma.printf ("%f\n",PCvdd.x[j])
}
vsoma.close()

vsoma = new File()		
sprint(STRING,"DATA/dend/nmda_dend_%g.txt", 0.9)
vsoma.wopen(STRING)
for j=0, PCvddd.size()-1 {
	vsoma.printf ("%f\n",PCvddd.x[j])
}
vsoma.close()
*/
